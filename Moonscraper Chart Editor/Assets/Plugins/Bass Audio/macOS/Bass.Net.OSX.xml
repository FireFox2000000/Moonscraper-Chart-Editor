<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Bass.Net.OSX</name>
    </assembly>
    <members>
        <member name="T:Un4seen.Bass.AddOn.Ac3.BassAc3">
            <summary>
            BASS.NET API wrapper for BASS_AC3.DLL
            <para>Requires: bass_ac3.dll - Dolby Digital AC-3 Codec (AC3) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_AC3 is an extension to the BASS audio library, enabling the playback	of AC-3 streams.
            AC-3, often referred to as Dolby Digital, is Dolby's third digital audio coding technology based on a perceptual coding method. It is more advanced than AC-2 and delivers up to 5.1 discrete channels of surround sound in less space than stereo PCM.</para>
            <para>The AC-3 format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.dolby.com">www.dolby.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ac3.BassAc3.BASS_AC3_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a Dolby Digital AC-3 file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ac3.BassAc3.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_ac3.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ac3.BassAc3.SupportedStreamName">
            <summary>
            Supported file format name of the bass_ac3.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Ape.BassApe">
            <summary>
            BASS.NET API wrapper for BASS_APE.DLL
            <para>Requires: bass_ape.dll - Monkey's Audio Codec (APE) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_APE is an extension to the BASS audio library, enabling the playback of Monkey's Audio files.</para>
            <para>Monkey's Audio is a fast and powerful way to compress digital music. Unlike traditional methods, such as MP3, Vorbis or WMA which permanently discard quality to save space, Monkey's Audio makes perfect, lossless copies of your music, while still being able to save a lot of space.</para>
            <para>The Monkey's Audio format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.monkeysaudio.com">www.monkeysaudio.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Monkey's Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Monkey's Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Ape.BassApe.BASS_APE_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Monkey's Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ape.BassApe.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_ape.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Ape.BassApe.SupportedStreamName">
            <summary>
            Supported file format name of the bass_ape.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Dsd.BassDsd">
            <summary>
            BASS.NET API wrapper for BASSDSD.DLL
            <para>Requires: bassdsd.dll - Direct Stream Digital Audio Codec (DSD) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSDSD is an extension to the BASS audio library, enabling the playing of DSD (Direct Stream Digital) data in DSDIFF and DSF containers.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a DSD file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            <list type="table">
            <item><term>BASS_DSD_DOP</term><description>Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the BASS_SAMPLE_FLOAT flag is required.</description></item>
            <item><term>BASS_DSD_RAW</term><description>Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest. DSD data is not playable by BASS, so the BASS_STREAM_DECODE flag is required.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to convert the DSD data to PCM at... 0 = use the BASS_CONFIG_DSD_FREQ config setting. The rate will be rounded up (or down if there are none higher) to the nearest valid rate; the valid rates are 1/8, 1/16, 1/32, etc of the DSD rate down to a minimum of 44100 Hz. This parameter is ignored when the BASS_DSD_DOP or BASS_DSD_RAW flag is specified.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works almost in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.
            <para>All DSD rates (including 48000 Hz variants like 3.072 MHz) with any number of channels are supported, in DSDIFF and DSF containers (DST encoding is not supported). 
            The file's DSD sample rate is available via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_RATE"/> attribute.</para>
            <para>There are a few types of tag that may be available via BASS_ChannelGetTags. DSDIFF files may include artist and title information, which is available via the BASS_TAG_DSD_ARTIST and BASS_TAG_DSD_TITLE tags, which are ASCII strings. 
            DSDIFF files can also include comments, which are available via the BASS_TAG_DSD_COMMENT+index tag (index=0 is the first comment), which gives a pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> structure. DSF files may include ID3v2 tags, which are available via the BASS_TAG_ID3V2 tag.</para>
            <para>DSD is 6dB quieter than PCM, so a 6dB gain will be applied by default when converting to PCM. That can be changed via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_GAIN"/> config option and the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_GAIN"/> attribute.</para>
            <para>The DSD-over-PCM (BASS_DSD_DOP) and raw DSD data (BASS_DSD_RAW) options allow supporting devices to play the DSD data directly, without converting to PCM. 
            In both cases, the data needs to reach the device unmodified, so there can be no effects/resampling/mixing or anything else that will modify the data. 
            Raw DSD data is playable with ASIO drivers that support DSD, eg. via BASSASIO. DSD-over-PCM data can be sent to a supporting device in any way that does not modify the data. If DSD-over-PCM data is played on a device that doesn't support it, then it will produce a low level noise.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a DSD memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            <list type="table">
            <item><term>BASS_DSD_DOP</term><description>Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the BASS_SAMPLE_FLOAT flag is required.</description></item>
            <item><term>BASS_DSD_RAW</term><description>Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest. DSD data is not playable by BASS, so the BASS_STREAM_DECODE flag is required.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to convert the DSD data to PCM at... 0 = use the BASS_CONFIG_DSD_FREQ config setting. The rate will be rounded up (or down if there are none higher) to the nearest valid rate; the valid rates are 1/8, 1/16, 1/32, etc of the DSD rate down to a minimum of 44100 Hz. This parameter is ignored when the BASS_DSD_DOP or BASS_DSD_RAW flag is specified.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works almost in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.
            <para>All DSD rates (including 48000 Hz variants like 3.072 MHz) with any number of channels are supported, in DSDIFF and DSF containers (DST encoding is not supported). 
            The file's DSD sample rate is available via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_RATE"/> attribute.</para>
            <para>There are a few types of tag that may be available via BASS_ChannelGetTags. DSDIFF files may include artist and title information, which is available via the BASS_TAG_DSD_ARTIST and BASS_TAG_DSD_TITLE tags, which are ASCII strings. 
            DSDIFF files can also include comments, which are available via the BASS_TAG_DSD_COMMENT+index tag (index=0 is the first comment), which gives a pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> structure. DSF files may include ID3v2 tags, which are available via the BASS_TAG_ID3V2 tag.</para>
            <para>DSD is 6dB quieter than PCM, so a 6dB gain will be applied by default when converting to PCM. That can be changed via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_GAIN"/> config option and the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_GAIN"/> attribute.</para>
            <para>The DSD-over-PCM (BASS_DSD_DOP) and raw DSD data (BASS_DSD_RAW) options allow supporting devices to play the DSD data directly, without converting to PCM. 
            In both cases, the data needs to reach the device unmodified, so there can be no effects/resampling/mixing or anything else that will modify the data. 
            Raw DSD data is playable with ASIO drivers that support DSD, eg. via BASSASIO. DSD-over-PCM data can be sent to a supporting device in any way that does not modify the data. If DSD-over-PCM data is played on a device that doesn't support it, then it will produce a low level noise.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)">
            <summary>
            Creates a sample stream from a DSD file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            <list type="table">
            <item><term>BASS_DSD_DOP</term><description>Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the BASS_SAMPLE_FLOAT flag is required.</description></item>
            <item><term>BASS_DSD_RAW</term><description>Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest. DSD data is not playable by BASS, so the BASS_STREAM_DECODE flag is required.</description></item>
            </list>
            </param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <param name="freq">Sample rate to convert the DSD data to PCM at... 0 = use the BASS_CONFIG_DSD_FREQ config setting. The rate will be rounded up (or down if there are none higher) to the nearest valid rate; the valid rates are 1/8, 1/16, 1/32, etc of the DSD rate down to a minimum of 44100 Hz. This parameter is ignored when the BASS_DSD_DOP or BASS_DSD_RAW flag is specified.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works almost in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.
            <para>All DSD rates (including 48000 Hz variants like 3.072 MHz) with any number of channels are supported, in DSDIFF and DSF containers (DST encoding is not supported). 
            The file's DSD sample rate is available via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_RATE"/> attribute.</para>
            <para>There are a few types of tag that may be available via BASS_ChannelGetTags. DSDIFF files may include artist and title information, which is available via the BASS_TAG_DSD_ARTIST and BASS_TAG_DSD_TITLE tags, which are ASCII strings. 
            DSDIFF files can also include comments, which are available via the BASS_TAG_DSD_COMMENT+index tag (index=0 is the first comment), which gives a pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> structure. DSF files may include ID3v2 tags, which are available via the BASS_TAG_ID3V2 tag.</para>
            <para>DSD is 6dB quieter than PCM, so a 6dB gain will be applied by default when converting to PCM. That can be changed via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_GAIN"/> config option and the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_GAIN"/> attribute.</para>
            <para>The DSD-over-PCM (BASS_DSD_DOP) and raw DSD data (BASS_DSD_RAW) options allow supporting devices to play the DSD data directly, without converting to PCM. 
            In both cases, the data needs to reach the device unmodified, so there can be no effects/resampling/mixing or anything else that will modify the data. 
            Raw DSD data is playable with ASIO drivers that support DSD, eg. via BASSASIO. DSD-over-PCM data can be sent to a supporting device in any way that does not modify the data. If DSD-over-PCM data is played on a device that doesn't support it, then it will produce a low level noise.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)"/>.</para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            Creates a sample stream from a DSD file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            <list type="table">
            <item><term>BASS_DSD_DOP</term><description>Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the BASS_SAMPLE_FLOAT flag is required.</description></item>
            <item><term>BASS_DSD_RAW</term><description>Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest. DSD data is not playable by BASS, so the BASS_STREAM_DECODE flag is required.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="freq">Sample rate to convert the DSD data to PCM at... 0 = use the BASS_CONFIG_DSD_FREQ config setting. The rate will be rounded up (or down if there are none higher) to the nearest valid rate; the valid rates are 1/8, 1/16, 1/32, etc of the DSD rate down to a minimum of 44100 Hz. This parameter is ignored when the BASS_DSD_DOP or BASS_DSD_RAW flag is specified.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works almost in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.
            <para>All DSD rates (including 48000 Hz variants like 3.072 MHz) with any number of channels are supported, in DSDIFF and DSF containers (DST encoding is not supported). 
            The file's DSD sample rate is available via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_RATE"/> attribute.</para>
            <para>There are a few types of tag that may be available via BASS_ChannelGetTags. DSDIFF files may include artist and title information, which is available via the BASS_TAG_DSD_ARTIST and BASS_TAG_DSD_TITLE tags, which are ASCII strings. 
            DSDIFF files can also include comments, which are available via the BASS_TAG_DSD_COMMENT+index tag (index=0 is the first comment), which gives a pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> structure. DSF files may include ID3v2 tags, which are available via the BASS_TAG_ID3V2 tag.</para>
            <para>DSD is 6dB quieter than PCM, so a 6dB gain will be applied by default when converting to PCM. That can be changed via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_GAIN"/> config option and the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_GAIN"/> attribute.</para>
            <para>The DSD-over-PCM (BASS_DSD_DOP) and raw DSD data (BASS_DSD_RAW) options allow supporting devices to play the DSD data directly, without converting to PCM. 
            In both cases, the data needs to reach the device unmodified, so there can be no effects/resampling/mixing or anything else that will modify the data. 
            Raw DSD data is playable with ASIO drivers that support DSD, eg. via BASSASIO. DSD-over-PCM data can be sent to a supporting device in any way that does not modify the data. If DSD-over-PCM data is played on a device that doesn't support it, then it will produce a low level noise.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.AddOn.Dsd.BassDsd.BASS_DSD_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Dsd.BassDsd.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bassdsd.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Dsd.BassDsd.SupportedStreamName">
            <summary>
            Supported file format name of the bassdsd.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BassEnc">
            <summary>
            BASS.NET API wrapper for BASSENC.DLL
            <para>Requires: bassenc.dll - Encoding support library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSenc is an extension that allows BASS channels to be encoded using any command-line encoder that has STDIN support (LAME/OGGENC/etc).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetVersion">
            <summary>
            Retrieves the version number of the BASSenc.DLL that is loaded.
            </summary>
            <returns>The BASSenc version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc supports all the BASSenc functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASSENCVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassEnc.BASS_Encode_GetVersion()) != BassEnc.BASSENCVERSION )
            {
              MessageBox.Show(this, "Wrong BassEnc Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassEnc.BASS_Encode_GetVersion()) &lt;&gt; BassEnc.BASSENCVERSION Then
              MessageBox.Show(Me, "Wrong BassEnc Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassEnc.BASS_Encode_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassEnc Version!");
            }
            </code>
            <code lang="vbnet">
            If BassEnc.BASS_Encode_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassEnc Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSenc.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSenc version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc supports all the BASSenc functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassEnc.BASS_Encode_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassEnc Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassEnc.BASS_Encode_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassEnc Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="cmdline"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            Starts encoding on a channel.
            <para>This overload implements UNICODE cmdlines. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="cmdline">The encoder command-line, including the executable filename and any options. Or the output filename if the BASS_ENCODE_PCM flag is specified.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_PCM</term><description>Write plain PCM sample data to a file, without an encoder. The output filename is given in the cmdline parameter, or it can be <see langword="null"/> to not write a file.</description></item>
            <item><term>BASS_ENCODE_AIFF</term><description>Send an AIFF header to the encoder instead of a WAVE header.</description></item>
            <item><term>BASS_ENCODE_NOHEAD</term><description>Don't send a WAVE header to the encoder. If this flag is used then the sample format must be passed to the encoder some other way (eg. via the command-line).</description></item>
            <item><term>BASS_ENCODE_RF64</term><description>Write a BWF RF64 WAVE header instead of a standard header.</description></item>
            <item><term>BASS_ENCODE_WFEXT</term><description>Send the sample format information to the encoder in WAVEFORMATEXTENSIBLE form instead of WAVEFORMATEX form. This flag is ignored if the BASS_ENCODE_NOHEAD flag is used.</description></item>
            <item><term>BASS_ENCODE_BIGEND</term><description>Send big-endian sample data to the encoder, else little-endian.</description></item>
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24/32 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_DITHER</term><description>Apply dither (TPDF) when converting floating-point sample data to integer.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_MONO</term><description>Convert to mono (if not already).</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>cmdline is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback. To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para>The encoder must be told (via the command-line) to expect input from STDIN, rather than a file. The command-line should also tell the encoder what filename to write it's output to, unless you're using a callback function, in which case it should be told to write it's output to STDOUT.</para>
            <para>No user interaction with the encoder is possible, so anything that would cause the encoder to require the user to press any keys should be avoided. For example, if the encoder asks whether to overwrite files, the encoder should be instructed to always overwrite (via the command-line), or you should delete the existing file before starting the encoder.</para>
            <para>Standard RIFF files are limited to a little over 4GB in size. When writing a WAV file, BASSenc will automatically stop at that point, so that the file is valid. That does not apply when sending data to an encoder though, as the encoder may (possibly via a command-line option) ignore the size restriction, but if it does not, it could mean that the encoder stops after a few hours (depending on the sample format). If longer encodings are needed, the BASS_ENCODE_NOHEAD flag can be used to omit the WAVE header, and the encoder informed of the sample format via the command-line instead. The 4GB size limit can also be overcome with the BASS_ENCODE_RF64 flag, but most encoders are unlikely to support RF64.</para>
            <para>When writing an RF64 WAV file, a standard RIFF header will still be written initially, which will only be replaced by an RF64 header at the end if the file size has exceeded the standard limit. When an encoder is used, it is not possible to go back and change the header at the end, so the RF64 header is sent at the beginning in that case.</para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if you use the BASS_CONFIG_FLOATDSP option, then the sample data will be 32-bit floating-point, and you'll need to use one of the BASS_ENCODE_FP flags if the encoder does not support floating-point sample data. 
            The BASS_CONFIG_FLOATDSP setting should not be changed while encoding is in progress.</para>
            <para>The encoder DSP has a priority setting of -1000, so if you want to set DSP/FX on the channel and have them present in the encoding, set their priority above that.</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para>When queued encoding is enabled via the BASS_ENCODE_QUEUE flag, the DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call will just buffer the data, and the data will then be fed to the encoder by another thread. The buffer will grow as needed to hold the queued data, up to a limit specified by the BASS_CONFIG_ENCODE_QUEUE config option.
            If the limit is exceeded (or there is no free memory), data will be lost; <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to be notified of that occurrence. The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/>.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> can be used to check that the encoder is still running. When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>The returned process handle can be used to do things like change the encoder's priority and get it's exit code. See the System.Diagnostics namespace for details.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions (ie. BASS_Encode_IsActive/SetPaused/Stop/Write) will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Couldn't start the encoder. Check that the executable exists.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The PCM file couldn't be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>External encoders are not supported on iOS or Windows CE, so only plain PCM file writing with the BASS_ENCODE_PCM flag is possible on those platforms.</para>
            </remarks>
            <example>
            Start encoding a channel to an MP3 file (output.mp3) using LAME with the standard preset settings:
            <code>
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard - output.mp3", 
                    0, null, IntPtr.Zero);
            // start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard - output.mp3", 
                    0, Nothing, IntPtr.Zero)
            ' start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            Start writing a channel to a WAV file (output.wav):
            <code>
            BassEnc.BASS_Encode_Start(channel, "output.wav", 
                    BASSEncode.BASS_ENCODE_PCM, null, IntPtr.Zero);
            // start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            BassEnc.BASS_Encode_Start(channel, "output.wav", 
                    BASSEncode.BASS_ENCODE_PCM, Nothing, IntPtr.Zero)
            ' start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartCAUnicode(System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncode,System.Int32,Un4seen.Bass.AddOn.Enc.ENCODEPROCEX,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="ftype"></param>
            <param name="atype"></param>
            <param name="flags"></param>
            <param name="bitrate"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartCA(System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncode,System.Int32,Un4seen.Bass.AddOn.Enc.ENCODEPROCEX,System.IntPtr)">
            <summary>
            Starts encoding on a channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="ftype">The file type to use.</param>
            <param name="atype">The audio type to use.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24/32 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_DITHER</term><description>Apply dither (TPDF) when converting floating-point sample data to integer.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_MONO</term><description>Convert to mono (if not already).</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>cmdline is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="bitrate">The bitrate to use (bits per second).</param>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback. To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartCAFileUnicode(System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncode,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="ftype"></param>
            <param name="atype"></param>
            <param name="flags"></param>
            <param name="bitrate"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartCAFile(System.Int32,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncode,System.Int32,System.String)">
            <summary>
            Starts encoding on a channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="ftype">The file type to use.</param>
            <param name="atype">The audio type to use.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24/32 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_DITHER</term><description>Apply dither (TPDF) when converting floating-point sample data to integer.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_MONO</term><description>Convert to mono (if not already).</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>cmdline is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="bitrate">The bitrate to use (bits per second).</param>
            <param name="filename">The target filename.</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="cmdline"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <param name="limit"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Int32)">
            <summary>
            Sets up an encoder on a channel.
            <para>This overload implements UNICODE cmdlines. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="cmdline">The encoder command-line, including the executable filename and any options. Or the output filename if the BASS_ENCODE_PCM flag is specified.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_PCM</term><description>Write plain PCM sample data to a file, without an encoder. The output filename is given in the cmdline parameter, or it can be <see langword="null"/> to not write a file.</description></item>
            <item><term>BASS_ENCODE_AIFF</term><description>Send an AIFF header to the encoder instead of a WAVE header.</description></item>
            <item><term>BASS_ENCODE_NOHEAD</term><description>Don't send a WAVE header to the encoder. If this flag is used then the sample format must be passed to the encoder some other way (eg. via the command-line).</description></item>
            <item><term>BASS_ENCODE_RF64</term><description>Write a BWF RF64 WAVE header instead of a standard header.</description></item>
            <item><term>BASS_ENCODE_WFEXT</term><description>Send the sample format information to the encoder in WAVEFORMATEXTENSIBLE form instead of WAVEFORMATEX form. This flag is ignored if the BASS_ENCODE_NOHEAD flag is used.</description></item>
            <item><term>BASS_ENCODE_BIGEND</term><description>Send big-endian sample data to the encoder, else little-endian.</description></item>
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24/32 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_DITHER</term><description>Apply dither (TPDF) when converting floating-point sample data to integer.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_MONO</term><description>Convert to mono (if not already).</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>cmdline is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback. To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="limit">The maximum number of bytes that will be encoded (0=no limit).</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para>This function works exactly like <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>, but with a <paramref name="limit"/> parameter added, which is the maximum number of bytes that will be encoded (0=no limit).
            Once the limit is hit, the encoder will die. <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to be notified of that occurrence.
            One thing to note is that the limit is applied after any conversion due to the BASS_ENCODE_FP flags.</para>
            <para>This can be useful in situations where the encoder needs to know in advance how much data it will be receiving. For example, when using a callback function with a file format that stores the length in the header, as the header cannot then be updated at the end of encoding. The length is communicated to the encoder via the WAVE header, so it requires that the BASS_ENCODE_NOHEAD flag is not used.</para>
            <para>The encoder must be told (via the command-line) to expect input from STDIN, rather than a file. The command-line should also tell the encoder what filename to write it's output to, unless you're using a callback function, in which case it should be told to write it's output to STDOUT.</para>
            <para>No user interaction with the encoder is possible, so anything that would cause the encoder to require the user to press any keys should be avoided. For example, if the encoder asks whether to overwrite files, the encoder should be instructed to always overwrite (via the command-line), or you should delete the existing file before starting the encoder.</para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when you play the channel (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if you use the BASS_CONFIG_FLOATDSP option, then the sample data will be 32-bit floating-point, and you'll need to use one of the BASS_ENCODE_FP flags if the encoder does not support floating-point sample data. 
            The BASS_CONFIG_FLOATDSP setting should not be changed while encoding is in progress.</para>
            <para>The encoder DSP has a priority setting of -1000, so if you want to set DSP/FX on the channel and have them present in the encoding, set their priority above that.</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. Both methods can be used together, but in general, the "automatic" system ought be paused when using the "manual" system, by use of the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function.</para>
            <para>When queued encoding is enabled via the BASS_ENCODE_QUEUE flag, the DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call will just buffer the data, and the data will then be fed to the encoder by another thread. The buffer will grow as needed to hold the queued data, up to a limit specified by the BASS_CONFIG_ENCODE_QUEUE config option.
            If the limit is exceeded (or there is no free memory), data will be lost; <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to be notified of that occurrence. The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/>.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> can be used to check that the encoder is still running. When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to close the encoder.</para>
            <para>The returned process handle can be used to do things like change the encoder's priority and get it's exit code. See the System.Diagnostics namespace for details.</para>
            <para>Multiple encoders can be set on a channel. For simplicity, the encoder functions (ie. BASS_Encode_IsActive/SetPaused/Stop/Write) will accept either an encoder handle or a channel handle. When using a channel handle, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Couldn't start the encoder. Check that the executable exists.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The PCM file couldn't be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>External encoders are not supported on Android or iOS or Windows CE, so only plain PCM file writing with the BASS_ENCODE_PCM flag is possible on those platforms. User-provided encoders can be used via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/>.</para>
            </remarks>
            <example>
            Start encoding a channel to an MP3 file (output.mp3) using LAME with the standard preset settings:
            <code>
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard - output.mp3", 
                    0, null, IntPtr.Zero);
            // start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard - output.mp3", 
                    0, Nothing, IntPtr.Zero)
            ' start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            Start writing a channel to a WAV file (output.wav):
            <code>
            BassEnc.BASS_Encode_Start(channel, "output.wav", 
                    BASSEncode.BASS_ENCODE_PCM, null, IntPtr.Zero);
            // start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            BassEnc.BASS_Encode_Start(channel, "output.wav", 
                    BASSEncode.BASS_ENCODE_PCM, Nothing, IntPtr.Zero)
            ' start the channel playing &amp; encoding
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUserUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="filename"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)">
            <summary>
            Sets up a user-provided encoder on a channel.
            <para>This overload implements UNICODE cmdlines. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="filename">Output filename... <see langword="null"/> = no output file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24/32 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_DITHER</term><description>Apply dither (TPDF) when converting floating-point sample data to integer.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>filename is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the sample data and return the encoded data.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder process handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para>This function allows user-provided encoders to be used, which is most useful for platforms where external encoders are unavailable 
            for use with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>. For example, the LAME library could be used with this function instead of the standalone LAME executable with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.</para>
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the channel. That means when the channel is played (or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> is called 
            if it is a decoding channel), the sample data will be sent to the encoder at the same time. It also means that if the BASS_CONFIG_FLOATDSP option is enabled, the sample data will be 32-bit floating-point, 
            and one of the BASS_ENCODE_FP flags will be required if the encoder does not support floating-point sample data. 
            The BASS_CONFIG_FLOATDSP setting should not be changed while encoding is in progress.</para>
            <para>By default, the encoder DSP has a priority setting of -1000, which determines where in the DSP chain the encoding is performed. That can be changed via the BASS_CONFIG_ENCODE_PRIORITY config option.</para>
            <para>Besides the automatic DSP system, data can also be manually fed to the encoder via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function. 
            Both methods can be used together, but in general, the 'automatic' system ought to be paused when using the 'manual' system, via the BASS_ENCODE_PAUSE flag or the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> function. 
            Data fed to the encoder manually does not go through the source channel's DSP chain, so any DSP/FX set on the channel will not be applied to the data.</para>
            <para>When queued encoding is enabled via the BASS_ENCODE_QUEUE flag, the DSP system or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> call will just buffer the data, 
            and the data will then be fed to the encoder by another thread. The buffer will grow as needed to hold the queued data, up to a limit specified by the BASS_CONFIG_ENCODE_QUEUE config option. 
            If the limit is exceeded (or there is no free memory), data will be lost; <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to be notified of that occurrence. 
            The amount of data that is currently queued, as well as the queue limit and how much data has been lost, is available from <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/>.</para>
            <para>When done encoding, use <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StopEx(System.Int32,System.Boolean)"/> to close the encoder.</para>
            <para>Multiple encoders can be set on a channel. For convenience, most of the encoder functions will accept either an encoder handle or a channel handle. 
            When a channel handle is used, the function is applied to all encoders that are set on that channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file could not be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.IntPtr,System.Int32)">
            <summary>
            Sends a RIFF chunk to an encoder.
            </summary>
            <param name="handle">The encoder handle... a HENCODE.</param>
            <param name="id">The 4 character chunk id (e.g. 'bext').</param>
            <param name="buffer">The pointer to the buffer containing the chunk data (without the id).</param>
            <param name="length">The number of bytes in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            BASSenc writes the minimum chunks required of a WAV file: "fmt" and "data", and "ds64" and "fact" when appropriate. This function can be used to add other chunks. 
            For example, a BWF "bext" chunk or "INFO" tags.
            <para>Chunks can only be added prior to sample data being sent to the encoder. The BASS_ENCODE_PAUSE flag can be used when starting the encoder to ensure that no sample data is sent before additional chunks have been set.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No RIFF headers/chunks are being sent to the encoder (due to the BASS_ENCODE_NOHEAD flag being in effect), or sample data encoding has started.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.Byte[],System.Int32)">
            <summary>
            Sends a RIFF chunk to an encoder.
            </summary>
            <param name="handle">The encoder handle... a HENCODE.</param>
            <param name="id">The 4 character chunk id (e.g. 'bext').</param>
            <param name="buffer">The buffer containing the chunk data (without the id).</param>
            <param name="length">The number of bytes in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSenc writes the minimum chunks required of a WAV file: "fmt" and "data", and "ds64" and "fact" when appropriate. This function can be used to add other chunks. 
            For example, a BWF "bext" chunk or "INFO" tags.
            <para>Chunks can only be added prior to sample data being sent to the encoder. The BASS_ENCODE_PAUSE flag can be used when starting the encoder to ensure that no sample data is sent before additional chunks have been set.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No RIFF headers/chunks are being sent to the encoder (due to the BASS_ENCODE_NOHEAD flag being in effect), or sample data encoding has started.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Adding a BEXT chunk:
            <code>
            BASS_TAG_BEXT bext = new BASS_TAG_BEXT();
            ... set the bext member here
            string codingHistory = "...";
            byte[] bextData = bext.AsByteArray(codingHistory);
            bool ok = BassEnc.BASS_Encode_AddChunk(handle, "bext", bextData, bextData.Length);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)">
            <summary>
            Checks if an encoder is running on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>No encoder is running on the channel.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>There is an encoder running on the channel.</description></item>
            <item><term>BASS_ACTIVE_PAUSED</term><description>There is an encoder running on the channel, but it is paused.</description></item>
            </list>
            </returns>
            <remarks>
            <para>When checking if there's an encoder running on a channel, and there are multiple encoders on the channel, BASS_ACTIVE_PLAYING will be returned if any of them are active.</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
            <example>
            In a recording callback (see <see cref="T:Un4seen.Bass.RECORDPROC"/>) this might be used to check, if recording should be continued:
            <code>
            private bool RecordingCallback(int channel, IntPtr buffer, int length, IntPtr user)
            {
              // continue recording if encoder is alive
              return ( BassEnc.BASS_Encode_IsActive(channel) != BASSActive.BASS_ACTIVE_STOPPED );
            }
            </code>
            <code lang="vbnet">
            Private Function RecordingCallback(channel As Integer, buffer As IntPtr, 
                                               length As Integer, user As IntPtr) As Boolean
              ' continue recording if encoder is alive
              Return BassEnc.BASS_Encode_IsActive(channel) &lt;&gt; BASSActive.BASS_ACTIVE_STOPPED
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)">
            <summary>
            Stops encoding on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function will free an encoder immediately, without waiting for any data that may be remaining in the queue. <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StopEx(System.Int32,System.Boolean)"/> can be used to have an encoder process the queue before it is freed.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StopEx(System.Int32,System.Boolean)">
            <summary>
            Stops async encoding on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="queue">Process the queue first? If so, the encoder will not be freed until after any data remaining in the queue has been processed, and it will not accept any new data in the meantime.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When an encoder is told to wait for its queue to be processed, this function will return immediately and the encoder will be freed in the background after the queued data has been processed.
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to request notification of when the encoder has been freed. <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> (or this function with queue = <see langword="false"/>) can be used to cancel to queue processing and free the encoder immediately.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)">
            <summary>
            Pauses or resumes encoding on a channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="paused">Paused?</param>
            <returns>If no encoder has been started on the channel, <see langword="false"/> is returned, otherwise <see langword="true"/> is returned.</returns>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When an encoder is paused, no sample data will be sent to the encoder "automatically". Data can still be sent to the encoder "manually" though, via the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Sends sample data to the encoder.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A pointer to the buffer containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Single[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed float[] to handover sample data to the encoder (typically not used, since most encoders expect 16-bit, so use the int[] or short[] overload).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (float[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed int[] to handover sample data to the encoder (Note: An int[] is 32-bit. When using 16-bit samples we can keep a stereo pair in here).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (int[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed short[] to handover sample data to the encoder (perfect for 16-bit samples).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (short[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Sends sample data to the encoder.
            <para>This overload uses a managed byte[] to handover sample data to the encoder (perfect for 8-bit samples).</para>
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="buffer">A reference to the first array element (byte[0]) containing the sample data.</param>
            <param name="length">The number of BYTES in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There's usually no need to use this function, as the channel's sample data will automatically be fed to the encoder. But in some situations, it could be useful to be able to manually feed the encoder instead.
            <para>The sample data is expected to be the same format as the channel's, or floating-point if the BASS_CONFIG_FLOATDSP (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>) option is enabled.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The encoder has died.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_UserOutput(System.Int32,System.Int64,System.IntPtr,System.Int32)">
            <summary>
            Receives the output from a user encoder.
            </summary>
            <param name="handle">The encoder.</param>
            <param name="offset">The file offset of the data... -1 = the current end position.</param>
            <param name="buffer">Pointer to the encoded data.</param>
            <param name="length">The amount of data in bytes.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function should only be called from within the encoder's <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODERPROC"/> callback function.
            <para>If a server has been set on the encoder via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> or <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerInit(System.Int32,System.String,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeServer,Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC,System.IntPtr)"/>, the server will not receive the data when offset is behind the current end position. 
            The current end position is available from <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/> with BASS_ENCODE_COUNT_OUT.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder was not started with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/>.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>offset is beyond the end of the file.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)">
            <summary>
            Retrieves the amount of data queued, sent to or received from an encoder, or sent to a cast server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="count">The count to retrieve. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeCount"/>):
            <list type="table">
            <item><term>BASS_ENCODE_COUNT_IN</term><description>Data sent to the encoder.</description></item>
            <item><term>BASS_ENCODE_COUNT_OUT</term><description>Data received from the encoder. This only applies when the encoder outputs to STDOUT or it is an ACM encoder.</description></item>
            <item><term>BASS_ENCODE_COUNT_CAST</term><description>Data sent to a cast server.</description></item>
            <item><term>BASS_ENCODE_COUNT_QUEUE</term><description>Data currently in the queue, waiting to be sent to the encoder, if async encoding is enabled (i.e. the <see cref="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_QUEUE"/> flag was used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>).</description></item>
            <item><term>BASS_ENCODE_COUNT_QUEUE_LIMIT</term><description>The queue's size limit.</description></item>
            <item><term>BASS_ENCODE_COUNT_QUEUE_FAIL</term><description>Data not queued due to the queue being full or out of memory.</description></item>
            </list>
            </param>
            <returns>If successful, the requested count (in bytes) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The queue counts are based on the channel's sample format (floating-point if the BASS_CONFIG_FLOATDSP option is enabled), while the BASS_ENCODE_COUNT_IN count is based on the sample format used by the encoder, which could be different if one of the BASS_ENCODE_FP flags is active or the encoder is using an ACM codec (which take 16-bit data). </para>
            <para>When the encoder output is being sent to a cast server, the BASS_ENCODE_COUNT_CAST count will match the BASS_ENCODE_COUNT_OUT count, unless there have been problems (eg. network timeout) that have caused data to be dropped.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The encoder does not have a queue.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="count"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)">
            <summary>
            Sets a callback function on an encoder (or all encoders on a channel) to receive notifications about its status.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="proc">Callback function to receive the notifications... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When setting a notification callback on a channel, it only applies to the encoders that are currently set on the channel. Subsequent encoders will not automatically have the notification callback set on them, this function will have to be called again to set them up.</para>
            <para>An encoder can only have one notification callback set. Subsequent calls of this function can be used to change the callback function, or disable notifications (proc = <see langword="null"/>).</para>
            <para>The status of an encoder and its cast connection (if it has one) is checked when data is sent to the encoder or server, and by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/>. That means an encoder's death will not be detected automatically, and so no notification given, while no data is being encoded.</para>
            <para>If the encoder is already dead when setting up a notification callback, the callback will be triggered immediately.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Using the callback with a recording caster:
            <code>
            private ENCODENOTIFYPROC _myEndoderNotify;
            private int _encoder = 0;
            private int _recChan = 0;
            private bool _autoreconnect = true;
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, null, IntPtr.Zero);
            Start();
            ...
            private void Start()
            {
              // start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, null, IntPtr.Zero);
              _myEndoderNotify = new ENCODENOTIFYPROC(EncoderNotify);
              // start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      BassEnc.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", null, null, 128, true);
              // notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero);
            }
            
            private void Stop()
            {
              if (_encoder != 0)
              {
                BassEnc.BASS_Encode_SetNotify(_encoder, null, IntPtr.Zero);
                BassEnc.BASS_Encode_Stop(_encoder);
                _encoder = 0;
              }
            }
            
            private void EncoderNotify(int handle, int status, IntPtr user)
            {
              // encoder/connection lost
              Stop();
              if (_autoreconnect)
              {
                // do auto-reconnect...
                Thread.Sleep(1000); // wait a sec
                Start();
              } 
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderNotify As ENCODENOTIFYPROC
            Private _encoder As Integer = 0
            Private _recChan As Integer = 0
            Private _autoreconnect As Boolean = True
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, Nothing, IntPtr.Zero)
            Start()
            ...
            Private Sub Start()
              ' start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, Nothing, IntPtr.Zero)
              _myEndoderNotify = New ENCODENOTIFYPROC(AddressOf EncoderNotify)
              ' start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      Bass.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", Nothing, Nothing, 128, True)
              ' notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero)
            End Sub
            
            Private Sub Stop()
              If _encoder &lt;&gt; 0 Then
                BassEnc.BASS_Encode_SetNotify(_encoder, Nothing, IntPtr.Zero)
                BassEnc.BASS_Encode_Stop(_encoder)
                _encoder = 0
              End If
            End Sub
            
            Private Sub EncoderNotify(handle As Integer, status As Integer, user As IntPtr)
              ' encoder/connection lost
              Stop()
              If _autoreconnect Then
                ' do auto-reconnect...
                Thread.Sleep(1000) ' wait a sec
                Start()
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetChannel(System.Int32,System.Int32)">
            <summary>
            Moves an encoder (or all encoders on a channel) to another channel.
            </summary>
            <param name="handle">The encoder or channel handle... a HENCODE, HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="channel">The channel to move the encoder(s) to... a HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The new channel must have the same sample format (rate, channels, resolution) as the old channel, as that is what the encoder is expecting. 
            A channel's sample format is available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> or <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The new channel's sample format is not the same as the old channel's.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetChannel(System.Int32)">
            <summary>
            Retrieves the channel that an encoder is set on.
            </summary>
            <param name="handle">The encoder to get the channel from.</param>
            <returns>If successful, the encoder's channel handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Initializes sending an encoder's output to a Shoutcast or Icecast server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="server">The server to send to, in the form of "address:port" (Shoutcast v1) resp. "address:port,sid" (Shoutcast v2) or "address:port/mount" (Icecast).</param>
            <param name="pass">The server password. A username can be included in the form of "username:password" when connecting to an Icecast or Shoutcast 2 server.</param>
            <param name="content">The MIME type of the encoder output. This can be one of the following:
            <para><see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_MP3"/>, <see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_OGG"/> or <see cref="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_AAC"/>.</para>
            </param>
            <param name="name">The stream name... <see langword="null"/> = no name.</param>
            <param name="url">The URL, for example, of the radio station's webpage... <see langword="null"/> = no URL.</param>
            <param name="genre">The genre... <see langword="null"/> = no genre.</param>
            <param name="desc">Description... <see langword="null"/> = no description. This applies to Icecast only.</param>
            <param name="headers">Other headers to send to the server... <see langword="null"/> = none. Each header should end with a carriage return and line feed ("\r\n").</param>
            <param name="bitrate">The bitrate (in kbps) of the encoder output... 0 = undefined bitrate. In cases where the bitrate is a "quality" (rather than CBR) setting, the headers parameter can be used to communicate that instead, eg. "ice-bitrate: Quality 0\r\n".</param>
            <param name="pub">Public? If <see langword="true"/>, the stream is added to the public directory of streams, at shoutcast.com or dir.xiph.org (or as defined in the server config).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function sets up a Shoutcast/Icecast source client, sending the encoder's output to a server, which listeners can then connect to and receive the data from. 
            The Shoutcast and Icecast server software is available from <a href="http://www.shoutcast.com/broadcast-tools">www.shoutcast.com/broadcast-tools</a> and <a href="http://www.icecast.org/download.php">www.icecast.org/download</a>, respectively.</para>
            <para>An encoder needs to be started (but with no data sent to it yet) before using this function to setup the sending of the encoder's output to a Shoutcast or Icecast server. 
            If <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> is used, the encoder should be setup to write its output to STDOUT. Due to the length restrictions of WAVE headers/files, the encoder should also be started with the BASS_ENCODE_NOHEAD flag, and the sample format details sent via the command-line.</para>
            <para>Unless the BASS_ENCODE_CAST_NOLIMIT flag is set on the encoder, BASSenc automatically limits the rate that data is processed to real-time speed to avoid overflowing the server's buffer, which means that it is safe to simply try to process data as quickly as possible, eg. when the source is a decoding channel.
            Encoders set on recording channels are automatically exempt from the rate limiting, as they are inherently real-time.
            With BASS 2.4.6 or above, also exempt are encoders that are fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), eg. when the source is a playing channel; that is to avoid delaying the update thread, which could result in playback buffer underruns.</para>
            <para>Normally, BASSenc will produce the encoded data (with the help of an encoder) that is sent to a Shoutcast/Icecast server, but it is also possible to send already encoded data to a server (without first decoding and re-encoding it) via the PCM encoding option.
            The encoder can be set on any BASS channel, as rather than feeding on sample data from the channel, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> would be used to feed in the already encoded data.
            BASSenc does not know what the data's bitrate is in that case, so it is up to the user to process the data at the correct rate (real-time speed).</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerInit(System.Int32,System.String,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeServer,Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC,System.IntPtr)"/> can be used to setup a server that listeners can connect to directly, without a Shoutcast/Icecast server intermediary.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>There is already a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="server"/> doesn't include a port number.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>Couldn't connect to the server.</description></item>
            <item><term>BASS_ERROR_CAST_DENIED</term><description><paramref name="pass"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Start encoding a stereo 44100hz channel to 128kb/s MP3, and send the output to a Shoutcast server:
            <code>
            // setup the encoder
            int encoder = BassEnc.BASS_Encode_Start(channel, "lame -r -x -s 44100 -b 128 -", 
                                  BASS_ENCODE_NOHEAD, null, 0);
            // setup the encoder
            BassEnc.BASS_Encode_CastInit(encoder, "server.com:8000", "password", BassEnc.BASS_ENCODE_TYPE_MP3, 
                                         "name", "url", "genre", null, null, 128, true);
            </code>
            <code lang="vbnet">
            ' setup the encoder
            Dim encoder As Integer = BassEnc.BASS_Encode_Start(channel, "lame -r -x -s 44100 -b 128 -", 
                                             BASS_ENCODE_NOHEAD, Nothing, 0)
            ' setup the encoder
            BassEnc.BASS_Encode_CastInit(encoder, "server.com:8000", "password", BassEnc.BASS_ENCODE_TYPE_MP3, 
                                         "name", "url", "genre", Nothing, Nothing, 128, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)">
            <summary>
            Sets the title of a cast stream (ANSI only).
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="title">The title to set.</param>
            <param name="url">URL to go with the title... <see langword="null"/> = no URL. This applies to Shoutcast only (not Shoutcast 2).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This overload always uses an ANSI character string to update the title/url.
            <para>The ISO-8859-1 (Latin-1) character set should be used with Shoutcast and non-Ogg Icecast servers, and UTF-8 with Shoutcast 2 and Ogg Icecast servers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the BASS_CONFIG_NET_TIMEOUT config option.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Sets the title of a cast stream.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="title">The encoded byte array containing the title to set.</param>
            <param name="url">The encoded byte array containing the URL to go with the title... <see langword="null"/> = no URL. This applies to Shoutcast only (not Shoutcast 2).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This overload allows you to pass an encoded byte array to update the title/url (e.g. when the server expects a specific codepage/character set).
            <para>The ISO-8859-1 (Latin-1) character set should be used with Shoutcast and non-Ogg Icecast servers, and UTF-8 with Shoutcast 2 and Ogg Icecast servers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the BASS_CONFIG_NET_TIMEOUT config option.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Sets a song title using UTF-8:
            <code>
            Encoding utf8 = Encoding.UTF8;
            BassEnc.BASS_Encode_CastSetTitle(encoder, utf8.GetBytes(song+"\0"), null);
            </code>
            <code lang="vbnet">
            Dim utf8 As Encoding = Encoding.UTF8
            BassEnc.BASS_Encode_CastSetTitle(encoder, utf8.GetBytes(song+"\0"), Nothing)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSendMeta(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType,System.Byte[])">
            <summary>
            Sends metadata to a Shoutcast 2 server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="type">The type of metadata (one of the <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType"/> values).
            This is a Shoutcast 2 message class (in bits 12 to 15) and type (bits 0 to 11) that describes what the metadata is. For example, 0x4001 is class 4 and type 1 (which would indicate a station logo in PNG format).</param>
            <param name="buffer">The metadata as an UTF-8 encoded byte array.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method allows you to send an encoded UTF-8 byte array containing XML metadata to the server (SHOUTcast v2).
            <para>Some information on the available metadata options can be found in the Shoutcast 2 specs: <a href="http://wiki.winamp.com/wiki/SHOUTcast_2_(Ultravox_2.1)_Protocol_Details">wiki.winamp.com/wiki/SHOUTcast_2_(Ultravox_2.1)_Protocol_Details</a>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSendMeta(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType,System.String)">
            <summary>
            Sends metadata to a Shoutcast 2 server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="type">The type of metadata (one of the <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType"/> values).
            This is a Shoutcast 2 message class (in bits 12 to 15) and type (bits 0 to 11) that describes what the metadata is. For example, 0x4001 is class 4 and type 1 (which would indicate a station logo in PNG format).</param>
            <param name="xml">The XML metadata to send.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method allows you to send an encoded UTF-8 byte array containing XML metadata to the server (SHOUTcast v2).
            <para>Some information on the available metadata options can be found in the Shoutcast 2 specs: <a href="http://wiki.winamp.com/wiki/SHOUTcast_2_(Ultravox_2.1)_Protocol_Details">wiki.winamp.com/wiki/SHOUTcast_2_(Ultravox_2.1)_Protocol_Details</a>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast set on the encoder.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStatsPtr(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="type"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStats(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)">
            <summary>
            Retrieves stats from the Shoutcast or Icecast server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="type">The type of stats to retrieve. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeStats"/>):
            <list type="table">
            <item><term>BASS_ENCODE_STATS_SHOUT</term><description>Shoutcast stats, including listener information and additional server information.</description></item>
            <item><term>BASS_ENCODE_STATS_ICE</term><description>Icecast mount-point listener information.</description></item>
            <item><term>BASS_ENCODE_STATS_ICESERV</term><description>Icecast server stats, including information on all mount points on the server.</description></item>
            </list>
            </param>
            <param name="pass">Password when retrieving Icecast server stats... <see langword="null"/> = use the password provided in the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> call.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The stats are returned in XML format.
            <para>Each encoder has a single stats buffer, which is reused by each call of this function for the encoder. 
            So if the data needs to be retained across multiple calls, it should be copied to another buffer.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There isn't a cast of the requested type set on the encoder.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the BASS_CONFIG_NET_TIMEOUT config option.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Get the number of listeners for SHOUTcast:
            <code>
            string stats = BassEnc.BASS_Encode_CastGetStats(encoder, 
                                   BASSEncodeStats.BASS_ENCODE_STATS_SHOUT, password);
            if (stats != null)
            {
              int start = stats.IndexOf( "&lt;CURRENTLISTENERS&gt;" );
              int end = stats.IndexOf( "&lt;/CURRENTLISTENERS&gt;" );
              if (start &gt; 0 &amp;&amp; end &gt; 0)
              {
                start += 18;
                count = int.Parse( stats.Substring(start, end-start) );
              }
            }
            </code>
            <code lang="vbnet">
            Dim stats As String = BassEnc.BASS_Encode_CastGetStats(encoder, 
                                          BASSEncodeStats.BASS_ENCODE_STATS_SHOUT, password)
            If Not (stats Is Nothing) Then
              Dim start As Integer = stats.IndexOf("&lt;CURRENTLISTENERS&gt;")
              Dim [end] As Integer = stats.IndexOf("&lt;/CURRENTLISTENERS&gt;")
              If start &gt; 0 AndAlso end &gt; 0 Then
                start += 18
                count = Integer.Parse(stats.Substring(start, end - start))
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerInit(System.Int32,System.String,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeServer,Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC,System.IntPtr)">
            <summary>
            Initializes a server to send an encoder's output to connecting clients.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="port">The IP address and port number to accept client connections on... "xxx.xxx.xxx.xxx:port", <see langword="null"/> = an available port on all local addresses.
            The IP address should be local and the port number should be lower than 65536. If the address is "0.0.0.0" or omitted, then the server will accept connections on all local addresses.
            If the port is "0" or omitted, then an available port will be assigned.</param>
            <param name="buffer">The server's buffer length in bytes.</param>
            <param name="burst">The amount of buffered data to send to new clients. This will be capped at the size of the buffer.</param>
            <param name="flags">A combination of these flags:
            <list type="table">
            <item><term>BASS_ENCODE_SERVER_NOHTTP</term><description>Do not read or send HTTP headers.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive notification of clients connecting and disconnecting... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new server's port number is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows remote (or local) clients to receive the encoder's output by setting up a TCP server for them to connect to, using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> for example. 
            Connections can be refused by the <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC"/> callback function, and already connected clients can be kicked with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerKick(System.Int32,System.String)"/> function.</para>
            <para>The server buffers the data that it receives from the encoder, and the data is then sent from the buffer to the connected clients. The buffer should be at least big enough to account for the time that it takes for the clients to receive the data. If a client falls too far behind (beyond the buffer length), it will miss some data. When a client connects, buffered data can be "burst" to the client, allowing it to prebuffer and begin playback more quickly. If a speed cap is set (in the <paramref name="buffer"/> parameter), that will limit the burst speed.</para>
            <para>An encoder needs to be started, but with no data yet sent to it, before using this function to setup the server. If <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> is used, the encoder should be setup to write its output to STDOUT. Due to the length restrictions of WAVE headers/files, the encoder should also be started with the BASS_ENCODE_NOHEAD flag, and the sample format details sent via the command-line.</para>
            <para>Normally, BASSenc will produce the encoded data (with the help of an encoder) that is sent to a clients, but it is also possible to send already encoded data (without first decoding and re-encoding it) via the PCM encoding option.
            The encoder can be set on any BASS channel, as rather than feeding on sample data from the channel, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> would be used to feed in the already encoded data. BASSenc does not know what the data's bitrate is in that case, so it is up to the user to process the data at the correct rate (real-time speed).</para>
            <para>
            <para>The server supports Shoutcast metadata with any audio format, but Shoutcast traditionally only supports MP3 or AAC encoding, so some players might not read the metadata with other formats. BASS (eg. <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>) does support Shoutcast metadata with any audio format.</para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>There is already a server set on the encoder.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="port"/> is not valid.</description></item>
            <item><term>BASS_ERROR_BUSY</term><description>The port is in use.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>This function is not available on Windows CE.</para>
            </remarks>
            <example>
            Start encoding a stereo 44100Hz channel to 128kb/s MP3, and start a server on port 8000 with a fully burstable 4 second (64KB) buffer:
            <code>
            // setup the encoder
            int encoder = BassEnc.BASS_Encode_Start(channel, "lame -r -s 44100 -b 128 -", 
                                                    BASSEncode.BASS_ENCODE_NOHEAD, null, IntPtr.Zero);
            // start the server
            BassEnc.BASS_Encode_ServerInit(encoder, "8000", 64000, 64000, 
                                           BASSEncodeServer.BASS_ENCODE_SERVER_DEFAULT, null, IntPtr.Zero);
            </code>
            Start encoding a stereo 44100Hz channel to 160kb/s OGG, and start a server on any available port on the loopback address (127.0.0.1) with a fully burstable 2 second (40KB) buffer:
            <code>
            // setup the encoder
            int encoder = BassEnc.BASS_Encode_Start(channel, "oggenc -r -R 44100 -M 160 -m 160 -", 
                                                    BASSEncode.BASS_ENCODE_NOHEAD, null, IntPtr.Zero);
            // start the server
            BassEnc.BASS_Encode_ServerInit(encoder, "127.0.0.1", 40000, 40000, 
                                           BASSEncodeServer.BASS_ENCODE_SERVER_DEFAULT, null, IntPtr.Zero);
            </code>
            Setup PCM encoding on a dummy stream to feed pre-encoded data to a server on port 8000 with a 64KB buffer:
            <code>
            // create a dummy stream to host the encoder
            int dummy = Bass.BASS_StreamCreateDummy(44100, 1, BASSFlag.BASS_STREAM_DECODE, IntPtr.Zero);
            // setup the encoder
            int encoder = BassEnc.BASS_Encode_Start(dummy, null, 
                                                    BASSEncode.BASS_ENCODE_PCM | BASSEncode.BASS_ENCODE_NOHEAD, 
                                                    null, IntPtr.Zero);
            // start the server
            int port = BassEnc.BASS_Encode_ServerInit(encoder, "8000", 64000, 64000, 
                                                      BASSEncodeServer.BASS_ENCODE_SERVER_DEFAULT, null, IntPtr.Zero);
            ...
            // feed encoded data to the encoder/server (repeat periodically)
            BassEnc.BASS_Encode_Write(encoder, data, length);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerKick(System.Int32,System.String)">
            <summary>
            Kicks clients from a server.
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="client">The client(s) to kick... "" (empty string) = all clients. Unless a port number is included, this string is compared with the start of the connected clients' IP address.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The clients may not be kicked immediately, but shortly after the call. If the server has been setup with an <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC"/> callback function, that will receive notification of the disconnections.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No matching clients were found.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>This function is not available on Windows CE.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASSENCVERSION">
            <summary>
            Current BASSenc version (without minor revision).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_MP3">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> content MIME type for MP3
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_OGG">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> content MIME type for OGG (FLAC_OGG or OPUS)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_ENCODE_TYPE_AAC">
            <summary>
            <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/> content MIME type for AAC
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncode">
            <summary>
            BASS Encode Start flags for use with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_DEFAULT">
            <summary>
            Default option, incl. wave header, little-endian and no FP conversion.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_NOHEAD">
            <summary>
            Do NOT send a WAV header to the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_8BIT">
            <summary>
            Convert floating-point sample data to 8-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_16BIT">
            <summary>
            Convert floating-point sample data to 16-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_24BIT">
            <summary>
            Convert floating-point sample data to 24-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_32BIT">
            <summary>
            Convert floating-point sample data to 32-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FP_AUTO">
            <summary>
            Convert floating-point sample data back to channel's format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_BIGEND">
            <summary>
            Big-Endian sample data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_PAUSE">
            <summary>
            Start the encoder paused.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_PCM">
            <summary>
            Write PCM sample data (no encoder).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_RF64">
            <summary>
            Write RF64 WAV header (no encoder).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_MONO">
            <summary>
            Convert to mono (if not already).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_QUEUE">
            <summary>
            Queue data to feed encoder asynchronously.
            <para>The queue buffer will grow as needed to fit the data, but its size can be limited by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_QUEUE"/> config option (0 = no limit); the default is 10000ms.
            If the queue reaches the size limit and data is lost, the <see cref="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_QUEUE_FULL"/> notification will be triggered.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_WFEXT">
            <summary>
            Send the sample format information to the encoder in WAVEFORMATEXTENSIBLE form instead of WAVEFORMATEX form.
            <para>This flag is ignored if the BASS_ENCODE_NOHEAD flag is used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_CAST_NOLIMIT">
            <summary>
            Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.
            <para>With this option you might disable the rate limiting during casting (as it'll be limited by the playback rate anyway if the source channel is being played).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_LIMIT">
            <summary>
            Limit data rate to real-time.
            <para>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns.
            Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_AIFF">
            <summary>
            Send an AIFF header to the encoder instead of a WAVE header.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_DITHER">
            <summary>
            Apply dither when converting floating-point sample data to integer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_AUTOFREE">
            <summary>
            Free the encoder when the channel is freed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_FLAC_NOCOUNT">
            <summary>
            BASSENC_FLAC addon flag: Do not count the encoder output to make available from BASS_Encode_GetCount (with BASS_ENCODE_COUNT_OUT). This saves a bit of processing. It also prevents casting (via BASS_Encode_CastInit) or serving (via BASS_Encode_ServerInit) the data, so it should not be used in those cases
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_UNICODE">
            <summary>
            Cmdline is Unicode (16-bit characters).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> to receive notifications on an encoder's status.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_ENCODER">
            <summary>
            Encoder died.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_CAST">
            <summary>
            Cast server connection died.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_CAST_TIMEOUT">
            <summary>
            Cast timeout.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_QUEUE_FULL">
            <summary>
            Async encoding queue is out of space.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify.BASS_ENCODE_NOTIFY_FREE">
            <summary>
            Encoder has been freed.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeCount">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/> to define the type of count you want to get.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_IN">
            <summary>
            Get the bytes sent to the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_OUT">
            <summary>
            Get the bytes received from the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_CAST">
            <summary>
            Get the bytes sent to the cast server.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_QUEUE">
            <summary>
            Data currently in the queue, waiting to be sent to the encoder (if async encoding is enabled).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_QUEUE_LIMIT">
            <summary>
            The queue's size limit (if async encoding is enabled).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeCount.BASS_ENCODE_COUNT_QUEUE_FAIL">
            <summary>
            Data not queued due to the queue being full or out of memory (if async encoding is enabled).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSendMeta(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType,System.Byte[],System.Int32)"/> to define the type of metadata to send.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_XML_CONTENT">
            <summary>
            SHOUTcast v2 Cacheable Metadata (Content Info Metadata).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_XML_URL">
            <summary>
            SHOUTcast v2 Cacheable Metadata (Url Metadata).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_XML_AOL">
            <summary>
            SHOUTcast v2 Cacheable Metadata (Aol Radio format).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_XML_SHOUTCAST">
            <summary>
            SHOUTcast v2 Cacheable Metadata (SHOUTcast 2.0 format).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_STATIONLOGO_JPG">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/jpeg).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_STATIONLOGO_PNG">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/png).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_STATIONLOGO_BMP">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/bmp).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_STATIONLOGO_GIF">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Station logo image/gif).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_ALBUMART_JPG">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/jpeg).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_ALBUMART_PNG">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/png).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_ALBUMART_BMP">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/bmp).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_BIN_ALBUMART_GIF">
            <summary>
            SHOUTcast v2 Cacheable Binary Metadata (Album art image/gif).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeMetaDataType.BASS_METADATA_XML_TIME_REMAINING">
            <summary>
            SHOUTcast v2 Pass-through Metadata (Time Remaining).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeStats">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStats(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)"/> to define the type of stats you want to get.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeStats.BASS_ENCODE_STATS_SHOUT">
            <summary>
            Shoutcast stats.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeStats.BASS_ENCODE_STATS_ICE">
            <summary>
            Icecast mount-point stats.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeStats.BASS_ENCODE_STATS_ICESERV">
            <summary>
            Icecast server stats.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.BASSEncodeServer">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerInit(System.Int32,System.String,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeServer,Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC,System.IntPtr)"/> to define optional server flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeServer.BASS_ENCODE_SERVER_DEFAULT">
            <summary>
            Default (no options).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeServer.BASS_ENCODE_SERVER_NOHTTP">
            <summary>
            No HTTP headers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Enc.BASSEncodeServer.BASS_ENCODE_SERVER_META">
            <summary>
            Enable Shoutcast metadata.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC">
            <summary>
            User defined callback function to process (receive) encoded sample data.
            </summary>
            <param name="handle">The encoder that the data is from (as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>).</param>
            <param name="channel">The channel that the data is from.</param>
            <param name="buffer">The pointer to the buffer containing the encoded data.</param>
            <param name="length">The number of bytes in the buffer.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>To have the encoded data received by this callback function, the encoder needs to be told to output to STDOUT (instead of a file).</para>
            <para>
            It is clever to NOT alloc any buffer data (e.g. a byte[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'byte[] data = new byte[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            // the encoding callback
            private ENCODEPROC _myEndoderProc;
            private byte[] _encbuffer = new byte[1048510]; // 1MB buffer
            ...
            _myEndoderProc = new ENCODEPROC(MyEncodingWriter);
            // create the encoder (with default setting for lame)
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard", 
                    BASSEncode.BASS_ENCODE_DEFAULT, _myEndoderProc, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false); // start the channel playing &amp; encoding 
            ...
            private bool MyEncodingWriter(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// copy from managed to unmanaged memory
            	Marshal.Copy(buffer, _encbuffer, 0, length);
            	// process the data in _encbuffer, e.g. write to disk or whatever
            	...
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderProc As ENCODEPROC
            Private _encbuffer(1048510) As Byte ' 1MB buffer
            ...
            _myEndoderProc = New ENCODEPROC(AddressOf MyEncodingWriter)
            ' create the encoder (with default setting for lame)
            BassEnc.BASS_Encode_Start(channel, "lame --alt-preset standard", 
                    BASSEncode.BASS_ENCODE_DEFAULT, _myEndoderProc, IntPtr.Zero)
            Bass.BASS_ChannelPlay(channel, False)
            ' start the channel playing &amp; encoding 
            Private Function MyEncodingWriter(handle As Integer, channel As Integer, 
                                              buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              ' copy from managed to unmanaged memory
              Marshal.Copy(buffer, _encbuffer, 0, length)
              ' process the data in _encbuffer, e.g. write to disk or whatever
              ...
            End Function
            </code>
            If you are into C# you might also use native pointer access in an unsafe code block:
            <code>
            // assuming you have created a: BinaryWriter bw = new BinaryWriter(_fs);
            private unsafe bool MyEncodingWriter(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	byte *data = (byte*)buffer;
            	// process the data in 'data', e.g. write to disk or whatever
            	for (int a=0; a&lt;length; a++)
                {
                  // write the received sample data to a local file
                  bw.Write( data[a] );
                }
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODERPROC">
            <summary>
            User defined callback function to encode sample data. 
            </summary>
            <param name="handle">The encoder handle.</param>
            <param name="channel">The channel that the encoder is set on.</param>
            <param name="buffer">Buffer containing the sample data on input, and containing the encoded data on output.</param>
            <param name="length">The number of bytes in the buffer... -1 = the encoder is being freed (no data in the buffer).</param>
            <param name="maxout">The maximum amount of encoded data that can be placed in the buffer.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes of encoded data placed in buffer... -1 = stop encoding.</returns>
            <remarks>
            <para>If the encoder output exceeds the outmax value, then only the first outmax bytes should be delivered and the remainder retained. The function will be called again immediately to get the remainder.</para>
            <para>Instead of returning the data in buffer, it is also possible to provide the encoded data via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_UserOutput(System.Int32,System.Int64,System.IntPtr,System.Int32)"/>, which also adds the ability to update previous data (eg. headers).</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODEPROCEX">
            <summary>
            User defined callback function to process (receive) encoded sample data.
            </summary>
            <param name="handle">The encoder that the data is from.</param>
            <param name="channel">The channel that the data is from.</param>
            <param name="buffer">The pointer to the buffer containing the encoded data.</param>
            <param name="length">The number of bytes in the buffer.</param>
            <param name="offset">The file offset of the data in bytes.</param>
            <param name="user">The user instance data given.</param>
            <remarks>
            <para>To have the encoded data received by this callback function, the encoder needs to be told to output to STDOUT (instead of a file).</para>
            <para>
            It is clever to NOT alloc any buffer data (e.g. a byte[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'byte[] data = new byte[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC">
            <summary>
            User defined callback function to receive notifications on an encoder's status.
            </summary>
            <param name="handle">The encoder that the notification is from (as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/>).</param>
            <param name="status">The encoder's status, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncodeNotify"/>):
            <para>BASS_ENCODE_NOTIFY_ENCODER : The encoder died.</para>
            <para>BASS_ENCODE_NOTIFY_CAST : Cast server connection died.</para>
            <para>BASS_ENCODE_NOTIFY_CAST_TIMEOUT : Cast data sending timeout. The connection is not dead at this point, it may just be a temporary problem.</para>
            <para>BASS_ENCODE_NOTIFY_QUEUE_FULL : The queue length has reached its limit (or out of memory) and data has been dropped. The total amount of dropped data is available from <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_GetCount(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeCount)"/>.</para>
            <para>BASS_ENCODE_NOTIFY_FREE : The encoder has been freed.</para>
            </param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>When setting a notification callback on a channel, it only applies to the encoders that are currently set on the channel. Subsequent encoders will not automatically have the notification callback set on them, this function will have to be called again to set them up.</para>
            <para>An encoder can only have one notification callback set. Subsequent calls of this function can be used to change the callback function, or disable notifications (proc = <see langword="null"/>).</para>
            <para>If the encoder is already dead when setting up a notification callback, the callback will be triggered immediately.</para>
            <para>It is safe to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> to free an encoder from within a notification callback.</para>
            </remarks>
            <example>
            Using the callback with a recording caster:
            <code>
            private ENCODENOTIFYPROC _myEndoderNotify;
            private int _encoder = 0;
            private int _recChan = 0;
            private bool _autoreconnect = true;
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, null, IntPtr.Zero);
            Start();
            ...
            private void Start()
            {
              // start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, null, IntPtr.Zero);
              _myEndoderNotify = new ENCODENOTIFYPROC(EncoderNotify);
              // start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      BassEnc.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", null, null, 128, true);
              // notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero);
            }
            
            private void Stop()
            {
              if (_encoder != 0)
              {
                BassEnc.BASS_Encode_SetNotify(_encoder, null, IntPtr.Zero);
                BassEnc.BASS_Encode_Stop(_encoder);
                _encoder = 0;
              }
            }
            
            private void EncoderNotify(int handle, BASSEncodeNotify status, IntPtr user)
            {
              // encoder/connection lost
              Stop();
              if (_autoreconnect)
              {
                // do auto-reconnect...
                Thread.Sleep(1000); // wait a sec
                Start();
              } 
            }
            </code>
            <code lang="vbnet">
            Private _myEndoderNotify As ENCODENOTIFYPROC
            Private _encoder As Integer = 0
            Private _recChan As Integer = 0
            Private _autoreconnect As Boolean = True
            ...
            _recChan = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, Nothing, IntPtr.Zero)
            Start()
            ...
            Private Sub Start()
              ' start an encoder
              _encoder = BassEnc.BASS_Encode_Start(_recChan, "lame -r -x -s 44100 -b 128 -", 
                                 BASSEncode.BASS_ENCODE_NOHEAD, Nothing, IntPtr.Zero)
              _myEndoderNotify = New ENCODENOTIFYPROC(AddressOf EncoderNotify)
              ' start a caster
              BassEnc.BASS_Encode_CastInit(_encoder, "server.com:8000", "password", 
                      Bass.BASS_ENCODE_TYPE_MP3, "name", "url", "genre", Nothing, Nothing, 128, True)
              ' notify on dead encoder/connection 
              BassEnc.BASS_Encode_SetNotify(_encoder, _myEndoderNotify, IntPtr.Zero)
            End Sub
            
            Private Sub Stop()
              If _encoder &lt;&gt; 0 Then
                BassEnc.BASS_Encode_SetNotify(_encoder, Nothing, IntPtr.Zero)
                BassEnc.BASS_Encode_Stop(_encoder)
                _encoder = 0
              End If
            End Sub
            
            Private Sub EncoderNotify(handle As Integer, status As BASSEncodeNotify, user As IntPtr)
              ' encoder/connection lost
              Stop()
              If _autoreconnect Then
                ' do auto-reconnect...
                Thread.Sleep(1000) ' wait a sec
                Start()
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC">
            <summary>
            User defined callback function to receive notification of client connections and disconnections, and optionally refuse connections.
            </summary>
            <param name="handle">The encoder/server that the client is connecting to or disconnecting from (as returned by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/>).</param>
            <param name="connect">The client is connecting? TRUE = connecting, FALSE = disconnecting.</param>
            <param name="client">The client's IP address and port number... "xxx.xxx.xxx.xxx:port".</param>
            <param name="headers">The request headers... <see langword="null"/> = the client is disconnecting or HTTP headers have been disabled via the BASS_ENCODE_SERVER_NOHTTP flag.
            The headers are in the same form as would be given by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>, which is a series of null-terminated strings, the final string ending with a double null.
            The request headers can optionally be replaced with response headers to send back to the client, each ending with a carriage return and line feed ("\r\n").
            The response headers should not exceed 1KB in length.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerInit(System.Int32,System.String,System.Int32,System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeServer,Un4seen.Bass.AddOn.Enc.ENCODECLIENTPROC,System.IntPtr)"/> was called.</param>
            <returns>If the client is connecting, <see langword="false"/> means the connection is denied, otherwise it is accepted. The return value is ignored if the client is disconnecting.</returns>
            <remarks>
            <para>This function can be used to keep track of how many clients are connected, and who is connected.
            The request headers can be used to authenticate clients, and response headers can be used to pass information back to the clients.
            By default, connecting clients will be sent an "HTTP/1.0 200 OK" status line if accepted, and an "HTTP/1.0 403 Forbidden" status line if denied.
            That can be overridden in the first response header.</para>
            <para>Disconnection notifications will be received for clients that have disconnected themselves or that have been kicked by <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_ServerKick(System.Int32,System.String)"/>, but there will no notification of any clients that are disconnected by the encoder being freed.</para>
            <para>Each server has its own thread that handles new connections and sends data to its clients. The notification callbacks also come from that thread, so the callback function should avoid introducing long delays as that could result in clients missing some data and delay other clients connecting.</para>
            <para>To access the 'headers' data use one of the following utility methods:
            To read the headers use the <see cref="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermAnsi(System.IntPtr)"/> helper method;
            to write to the headers use the <see cref="M:Un4seen.Bass.Utils.StringToNullTermAnsi(System.String,System.IntPtr)"/> helper method.
            </para>
            </remarks>
            <example>
            A callback function that only allows connections from the 196.168/16 network, and only 5 clients:
            <code>
            int _listeners = 0; // client count
            
            private bool EncodeClientProc(int handle, bool connect, string client, IntPtr headers, IntPtr user)
            {
               if (connect)
               {
                   if (_listeners == 5)
                   {
                       // hit client limit
                       string[] resHeaders = new string[1] { "HTTP/1.0 403 Server Full" };
                       // set custom status
                       Utils.StringToNullTermAnsi(resHeaders, headers, true);
                       // refuse the connection
                       return false;
                   }
                   if (!client.StartsWith("192.168."))
                   {
                       // not on the 196.168/16 network
                       // refuse the connection
                       return false;
                   }
                   // increment the client count
                   _listeners++;
               }
               else
               {
                   // decrement the client count
                   _listeners--;
               }
               return true;
            }
            </code>
            A callback function that only allows connections with a particular "User-Agent" request header:
            <code>
            private bool EncodeClientProc(int handle, bool connect, string client, IntPtr headers, IntPtr user)
            {
               if (connect)
               {
                   // get the received headers
                   string[] getHeaders = Utils.IntPtrToArrayNullTermAnsi(headers);
                   // find the User-Agent header
                   foreach (string content in getHeaders)
                   {
                       if (content.StartsWith("User-Agent:"))
                       {
                           // found the User-Agent header
                           if (content.Substring(11) != "Special Agent")
                               return false;
                           break;
                       }
                   }
               }
               return true;
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac">
            <summary>
            BASS.NET API wrapper for BASSenc_FLAC.DLL
            <para>Requires: bassenc_flac.dll - Enc_FLAC Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSenc_FLAC is an extension to the BASSenc add-on that allows BASS channels 
            to be FLAC encoded, with support for FLACENC options. BASS 2.4 and BASSenc 2.4.12 or above are required.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_GetVersion">
            <summary>
            Retrieves the version number of the BASSenc_FLAC.DLL that is loaded.
            </summary>
            <returns>The BASSenc_FLAC version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_FLAC supports all the BASSenc_FLAC functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASSENCFLACVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSenc_FLAC.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSenc_FLAC version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_FLAC supports all the BASSenc_FLAC functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROCEX,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROCEX,System.IntPtr)">
            <summary>
            Sets up an FLAC encoder on a channel.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following reference FLAC encoder style options are supported:
            <para>--ogg, --serial-number, --until, -T / --tag, -P / --padding, --no-padding, -b / --blocksize, -V / --verify, --fast, --best, -0 / --compression-level-0 and the other compression level options. Anything else that is included will be ignored. See the FLAC <a href="https://xiph.org/flac/documentation_tools_flac.html">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>If the encoded data is being written to a file, the resulting file will not be seekable unless the --ogg or --until option is used. "--until=-0" can be used to specify the source channel's full length (according to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>).
            This issue does not apply when using <see cref="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_StartFile(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)"/> to write a file.</para>
            <para>Tags/comments should be in UTF-8 form. This function will take care of that when the BASS_UNICODE flag is used, but otherwise you will need to make sure that any tags included in options are UTF-8 (not ISO-8859-1/etc).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_StartFileUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASS_Encode_FLAC_StartFile(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            Sets up a FLAC encoder on a channel, writing the output to a file.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following reference FLAC encoder style options are supported:
            <para>--ogg, --serial-number, --until, -T / --tag, -P / --padding, --no-padding, -b / --blocksize, -V / --verify, --fast, --best, -0 / --compression-level-0 and the other compression level options. Anything else that is included will be ignored. See the FLAC <a href="https://xiph.org/flac/documentation_tools_flac.html">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT</term><description>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use one of these flags to have the sample data converted to 8/16/24 bit integer data before it's passed on to the encoder. These flags are ignored if the channel's sample data isn't floating-point.</description></item>
            <item><term>BASS_ENCODE_FP_AUTO</term><description>Convert floating-point sample data back to the channel's format (8/16 bit integer) if the data is only floating-point due to the BASS_CONFIG_FLOATDSP option being enabled.</description></item>
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_ENCODE_FLAC_NOCOUNT</term><description>Do not count the encoder output to make available from BASS_Encode_GetCount (with BASS_ENCODE_COUNT_OUT). This saves a bit of processing. It also prevents casting (via BASS_Encode_CastInit) or serving (via BASS_Encode_ServerInit) the data, so it should not be used in those cases.</description></item>
            <item><term>BASS_UNICODE</term><description>options is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="filename">Output filename... <see langword="null"/>=no output file.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Tags/comments should be in UTF-8 form. This function will take care of that when the BASS_UNICODE flag is used, but otherwise you will need to make sure that any tags included in options are UTF-8 (not ISO-8859-1/etc).</para>
            <para>Ogg Vorbis encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file could not be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.EncFlac.BassEnc_Flac.BASSENCFLACVERSION">
            <summary>
            Current BASSenc_FLAC version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3">
            <summary>
            BASS.NET API wrapper for BASSenc_MP3.DLL
            <para>Requires: bassenc_mp3.dll - Enc_MP3 Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BassEnc_Mp3 is an extension to the BASSenc add-on that allows BASS channels
            to be MP3 encoded. BASS 2.4 and BASSenc 2.4.12 or above are required.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASS_Encode_MP3_GetVersion">
            <summary>
            Retrieves the version number of the bassenc_mp3.DLL that is loaded.
            </summary>
            <returns>The BASSenc_MP3 version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_MP3 supports all the BASSenc_MP3 functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASSENCMP3VERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASS_Encode_MP3_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the bassenc_pp3.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSenc_MP3 version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_MP3 supports all the BASSenc_MP3 functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASS_Encode_MP3_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROCEX,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASS_Encode_MP3_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROCEX,System.IntPtr)">
            <summary>
            Sets up an MP3 encoder on a channel.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following LAME style options are supported:
            <para>-b, -B, -v, -V, -q, -m, --abr, --preset, --alt-preset, -Y, --resample, -p, -t, --tt, --ta, --tl, --ty, --tc, --tn, --tg, --tv, --id3v1-only, --id3v2-only, --add-id3v2, --pad-id3v2, --pad-id3v2-size, --noreplaygain. Anything else that is included will be ignored. See the LAME <a href="https://svn.code.sf.net/p/lame/svn/trunk/lame/USAGE">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options is in UTF-16 form. Otherwise it should be UTF-8. (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Each tag should be in either UTF-8 or ISO-8859-1 form (or UTF-16 when the BASS_UNICODE flag is used). ISO-8859-1 tags can be stored in ID3v1 and ID3v2 tag blocks. Unicode tags can only be stored in ID3v2 tag blocks. An ID3v2 tags block will be added automatically when required by the tags, otherwise only an ID3v1 tag block will added by default; this can be changed in options.</para>
            <para>MP3 encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>This function is not available on platforms/architectures without an FPU.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASS_Encode_MP3_StartFileUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASS_Encode_MP3_StartFile(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            Sets up an MP3 encoder on a channel, writing the output to a file.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following LAME style options are supported:
            <para>-b, -B, -v, -V, -q, -m, --abr, --preset, --alt-preset, -Y, --resample, -p, -t, --tt, --ta, --tl, --ty, --tc, --tn, --tg, --tv, --id3v1-only, --id3v2-only, --add-id3v2, --pad-id3v2, --pad-id3v2-size, --noreplaygain. Anything else that is included will be ignored. See the LAME <a href="https://svn.code.sf.net/p/lame/svn/trunk/lame/USAGE">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options and filename are in UTF-16 form. Otherwise options should be UTF-8 on all platforms, and filename should be ANSI on Windows and UTF-8 on other platforms. (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="filename">Output filename... <see langword="null"/>=no output file.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Each tag should be in either UTF-8 or ISO-8859-1 form (or UTF-16 when the BASS_UNICODE flag is used). ISO-8859-1 tags can be stored in ID3v1 and ID3v2 tag blocks. Unicode tags can only be stored in ID3v2 tag blocks. An ID3v2 tags block will be added automatically when required by the tags, otherwise only an ID3v1 tag block will added by default; this can be changed in options.</para>
            <para>MP3 encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file could not be created.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>This function is not available on platforms/architectures without an FPU.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.EncMp3.BassEnc_Mp3.BASSENCMP3VERSION">
            <summary>
            Current BASSenc_MP3 version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg">
            <summary>
            BASS.NET API wrapper for BASSenc_OGG.DLL
            <para>Requires: bassenc_ogg.dll - Enc_OGG Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSenc_OGG is an extension to the BASSenc add-on that allows BASS channels 
            to be Ogg Vorbis encoded, with support for OGGENC options. BASS 2.4 and BASSenc 2.4.12 or above are required.</para>
            <para>Ogg Vorbis encoding is based on libogg/vorbis, Copyright(c) 2002-2015 Xiph.org Foundation.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASS_Encode_OGG_GetVersion">
            <summary>
            Retrieves the version number of the BASSenc_OGG.DLL that is loaded.
            </summary>
            <returns>The BASSenc_OGG version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_OGG supports all the BASSenc_OGG functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASSENCOGGVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASS_Encode_OGG_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSenc_OGG.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSenc_OGG version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_OGG supports all the BASSenc_OGG functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASS_Encode_OGG_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASS_Encode_OGG_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            Sets up an Ogg Vorbis encoder on a channel.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following OGGENC style options are supported:
            <para>-b / --bitrate, -m / --min-bitrate, -M / --max-bitrate, -q / --quality, -s / --serial, -t / --title, -a / --artist, -G / --genre, -d / --date, -l / --album, -N / --tracknum, -c / --comment. Anything else that is included will be ignored. See the OGGENC <a href="http://linux.die.net/man/1/oggenc">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options is Unicode (16-bit characters) (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the sample data and return the encoded data.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Tags/comments should be in UTF-8 form. This function will take care of that when the BASS_UNICODE flag is used, but otherwise you will need to make sure that any tags included in options are UTF-8 (not ISO-8859-1/etc).</para>
            <para>Ogg Vorbis encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>This function is not available on platforms/architectures without an FPU.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASS_Encode_OGG_StartFileUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASS_Encode_OGG_StartFile(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            Sets up an Ogg Vorbis encoder on a channel, writing the output to a file.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following OGGENC style options are supported:
            <para>-b / --bitrate, -m / --min-bitrate, -M / --max-bitrate, -q / --quality, -s / --serial, -t / --title, -a / --artist, -G / --genre, -d / --date, -l / --album, -N / --tracknum, -c / --comment. Anything else that is included will be ignored. See the OGGENC <a href="http://linux.die.net/man/1/oggenc">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options and filename are in UTF-16 form. Otherwise options should be UTF-8 on all platforms, and filename should be ANSI on Windows and UTF-8 on other platforms. (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="filename">Output filename... <see langword="null"/>=no output file.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Tags/comments should be in UTF-8 form. This function will take care of that when the BASS_UNICODE flag is used, but otherwise you will need to make sure that any tags included in options are UTF-8 (not ISO-8859-1/etc).</para>
            <para>Ogg Vorbis encoding involves extensive floating-point operations, so it is not supported on platforms/architectures that do not have an FPU, eg. older ARM platforms/architectures.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file could not be created.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>This function is not available on platforms/architectures without an FPU.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.EncOgg.BassEnc_Ogg.BASSENCOGGVERSION">
            <summary>
            Current BASSenc_OGG version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus">
            <summary>
            BASS.NET API wrapper for BASSenc_OPUS.DLL
            <para>Requires: bassenc_opus.dll - Enc_OPUS Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSenc_OPUS is an extension to the BASSenc add-on that allows BASS channels
            to be Opus encoded, with support for OPUSENC options. BASS 2.4 and BASSenc 2.4.12 or above are required.</para>
            <para>Opus encoding is based on libOpus, Copyright 2001-2011 Xiph.Org,
            Skype Limited, Octasic, Jean-Marc Valin, Timothy B.Terriberry,
            CSIRO, Gregory Maxwell, Mark Borgerding, Erik de Castro Lopo.
            And libSpeexDSP, Copyright 2002-2008 Xiph.Org, Jean-Marc Valin.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASS_Encode_OPUS_GetVersion">
            <summary>
            Retrieves the version number of the BASSenc_OPUS.DLL that is loaded.
            </summary>
            <returns>The BASSenc_OPUS version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_OPUS supports all the BASSenc_OPUS functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASSENCOPUSVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASS_Encode_OPUS_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSenc_OPUS.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSenc_OPUS version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSenc_OPUS supports all the BASSenc_OPUS functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASS_Encode_OPUS_StartUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASS_Encode_OPUS_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)">
            <summary>
            Sets up an Opus encoder on a channel.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following OPUSENC style options are supported:
            <para>--bitrate, --vbr, --cvbr, --hard-cbr, --comp / --complexity, --framesize, --expect-loss, --max-delay, --serial, --comment, --artist, --title, --album, --date, --genre, --padding. Anything else that is included will be ignored. See the OPUSENC <a href="https://mf4.xiph.org/jenkins/view/opus/job/opus-tools/ws/man/opusenc.html">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options is in UTF-16 form. Otherwise it should be UTF-8. (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the sample data and return the encoded data.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Tags/comments should be in UTF-8 form. This function will take care of that when the BASS_UNICODE flag is used, but otherwise you will need to make sure that any tags included in options are UTF-8 (not ISO-8859-1/etc).</para>
            <para>On Windows and Linux, an SSE supporting CPU is required for sample rates other than 48000/24000/16000/12000/8000 Hz.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASS_Encode_OPUS_StartFileUnicode(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            
            </summary>
            <param name="chan"></param>
            <param name="options"></param>
            <param name="flags"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASS_Encode_OPUS_StartFile(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,System.String)">
            <summary>
            Sets up an Ogg Vorbis encoder on a channel, writing the output to a file.
            <para>This overload implements UNICODE options. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="options">Encoder options... <see langword="null"/>=use defaults.
            The following OPUSENC style options are supported:
            <para>--bitrate, --vbr, --cvbr, --hard-cbr, --comp / --complexity, --framesize, --expect-loss, --max-delay, --serial, --comment, --artist, --title, --album, --date, --genre, --padding. Anything else that is included will be ignored. See the OPUSENC <a href="https://mf4.xiph.org/jenkins/view/opus/job/opus-tools/ws/man/opusenc.html">documentation</a> for details on the aforementioned options and defaults.</para>
            </param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/>):
            <list type="table">
            <item><term>BASS_ENCODE_QUEUE</term><description>Queue data to feed the encoder asynchronously. This prevents the data source (DSP system or BASS_Encode_Write call) getting blocked by the encoder, but if data is queud more quickly than the encoder can process it, that could result in lost data.</description></item>
            <item><term>BASS_ENCODE_LIMIT</term><description>Limit the data rate to real-time speed, by introducing a delay when the rate is too high. With BASS 2.4.6 or above, this flag is ignored when the encoder is fed in a playback buffer update cycle (including <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> calls), to avoid possibly causing playback buffer underruns. Except for in those instances, this flag is applied automatically when the encoder is feeding a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_CAST_NOLIMIT</term><description>Don't limit the data rate (to real-time speed) when sending to a Shoutcast or Icecast server.</description></item>
            <item><term>BASS_ENCODE_PAUSE</term><description>Start the encoder paused.</description></item>
            <item><term>BASS_ENCODE_AUTOFREE</term><description>Automatically free the encoder when the source channel is freed.</description></item>
            <item><term>BASS_UNICODE</term><description>options and filename are in UTF-16 form. Otherwise options should be UTF-8 on all platforms, and filename should be ANSI on Windows and UTF-8 on other platforms. (not needed here, since the overloads already take care of it).</description></item>
            </list>
            </param>
            <param name="filename">Output filename... <see langword="null"/>=no output file.</param>
            <returns>The encoder handle is returned if the encoder is successfully started, else 0 is returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para><see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StartUser(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODERPROC,System.IntPtr)"/> is used internally to apply the encoder to the source channel, so the remarks in its documentation also apply to this function.</para>
            <para>Tags/comments should be in UTF-8 form. This function will take care of that when the BASS_UNICODE flag is used, but otherwise you will need to make sure that any tags included in options are UTF-8 (not ISO-8859-1/etc).</para>
            <para>On Windows and Linux, an SSE supporting CPU is required for sample rates other than 48000/24000/16000/12000/8000 Hz.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's sample format is not supported by the encoder.</description></item>
            <item><term>BASS_ERROR_CREATE</term><description>The file could not be created.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.EncOpus.BassEnc_Opus.BASSENCOPUSVERSION">
            <summary>
            Current BASSenc_OPUS version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Flac.BassFlac">
            <summary>
            BASS.NET API wrapper for BASSFLAC.DLL
            <para>Requires: bassflac.dll - Free Lossless Audio Codec (FLAC) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSFLAC is an extension to the BASS audio library, enabling the playing of FLAC (Free Lossless Audio Codec) encoded files.</para>
            <para>The FLAC format is used in very much the same way as any of the built-in BASS stream formats - simply call the FLAC stream creation function instead of the BASS built-in functions. The BASS plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) is also supported.</para>
            <para>More information can be found on <a href="http://flac.sourceforge.net">flac.sourceforge.net</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a FLAC file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a FLAC memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a FLAC file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Flac.BassFlac.BASS_FLAC_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a FLAC file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Flac.BassFlac.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bassflac.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Flac.BassFlac.SupportedStreamName">
            <summary>
            Supported file format name of the bassflac.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BassFx">
            <summary>
            BASS.NET API wrapper for BASS_FX.DLL
            <para>Requires: bass_fx.dll - DSP and Effect support Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_FX is an extension to the BASS audio library, providing a complete set of DSP functions to start programming your own DJ software. 
            Programmed to enable the simple and even the advanced programmers/users to have in their programs some sound effects without knowing any DSP at all.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_GetVersion">
            <summary>
            Retrieves the version number of the BASS_FX.DLL that is loaded.
            </summary>
            <returns>The BASS_FX version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASS_FX supports all the BASS_FX functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Fx.BassFx.BASSFXVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassFx.BASS_FX_GetVersion()) != BassFx.BASSFXVERSION )
            {
              MessageBox.Show(this, "Wrong BassFx Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassFx.BASS_FX_GetVersion()) &lt;&gt; BassFx.BASSFXVERSION Then
              MessageBox.Show(Me, "Wrong BassFx Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassFx.BASS_FX_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassFx Version!");
            }
            </code>
            <code lang="vbnet">
            If BassFx.BASS_FX_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassFx Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASS_FX.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASS_FX version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASS_FX supports all the BASS_FX functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassFx.BASS_FX_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassFx Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassFx.BASS_FX_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassFx Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a resampling stream from a decoding channel.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel (use BASS_STREAM_DECODE when creating the channel).</param>
            <param name="flags">A combination of the following flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed by DirectSound (ie. you can't loop just part of a sample).</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D samples must be mono (use BASS_SAMPLE_MONO).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well when the tempo channel is freed.</description></item>
            <item><term>BASS_FX_TEMPO_ALGO_LINEAR</term><description>Uses a linear interpolation mode (simple).</description></item>
            <item><term>BASS_FX_TEMPO_ALGO_CUBIC</term><description>Uses a cubic interpolation mode (recommended, default).</description></item>
            <item><term>BASS_FX_TEMPO_ALGO_SHANNON</term><description>Uses a 8-tap band-limited Shannon interpolation (complex, but not much better than cubic).</description></item>
            </list>
            </param>
            <returns>If successful, the tempo stream handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Multi-channels are supported.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>/<see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/> to get or set the attributes of a tempo stream:
            <list type="table">
            <item><term>BASS_ATTRIB_TEMPO</term><description>The tempo of a channel in percent [-95%...0...+5000%].</description></item>
            <item><term>BASS_ATTRIB_TEMPO_PITCH</term><description>The pitch of a channel in semitones [-60...0...+60].</description></item>
            <item><term>BASS_ATTRIB_TEMPO_FREQ</term><description>The sample rate of a channel in Hz (but calculates by the same % as BASS_ATTRIB_TEMPO).</description></item>
            </list>
            These attributes can either be applied to the tempo channel or the underlying decoding source channel.
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The <paramref name="channel"/>'s format is not supported. Make sure the channel is either Stereo or Mono.</description></item>
            </list>
            </para>
            <para>Tuning the option attributes parameters (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>):</para>
            <para>The time-stretch algorithm has few parameters that can be tuned to optimize sound quality for certain application. The current default parameters have been chosen by iterative if-then analysis (read: "trial and error") to obtain best subjective sound quality in pop/rock music processing, but in applications processing different kind of sound the default parameter set may result into a sub-optimal result.</para>
            <list type="bullet">
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER</see> (default = <see langword="true"/>):
            <para>Use FIR low-pass (anti-alias) filter (gain speed, lose quality)? : <see langword="true"/>=1 / <see langword="false"/>=0.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH</see> (default = 32):
            <para>The FIR low-pass (anti-alias) filter length in taps: between 8 and 128 (should be around %4).</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</see> (default = <see langword="false"/>):
            <para>Use quicker tempo change algorithm (gain speed, lose quality)? <see langword="true"/>=1 / <see langword="false"/>=0.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS</see> (default = 82):
            <para>This is the default length of a single processing sequence in milliseconds which determines the how the original sound is chopped in the time-stretch algorithm. Larger values mean fewer sequences are used in processing. In principle a larger value sounds better when slowing down the tempo, but worse when increasing the tempo and vice versa.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS</see> (default = 14):
            <para>The seeking window default length in milliseconds is for the algorithm that seeks the best possible overlapping location. This determines from how wide a sample "window" the algorithm can use to find an optimal mixing location when the sound sequences are to be linked back together.
            The bigger this window setting is, the higher the possibility to find a better mixing position becomes, but at the same time large values may cause a "drifting" sound artifact because neighboring sequences can be chosen at more uneven intervals. If there's a disturbing artifact that sounds as if a constant frequency was drifting around, try reducing this setting.</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS</see> (default = 12):
            <para>Overlap length in milliseconds. When the sound sequences are mixed back together to form again a continuous sound stream, this parameter defines how much the ends of the consecutive sequences will overlap with each other.
            This shouldn't be that critical parameter. If you reduce the BASS_FX_TEMPO_OPTION_SEQUENCE_MS setting by a large amount, you might wish to try a smaller value on this</para>
            </description>
            </item>
            <item>
            <description><see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_PREVENT_CLICK</see> (bool, default = FALSE):
            <para>Prevents clicks when changing the tempo from or over the zero position.</para>
            <para>Note: This involves a slight sound quality compromise by disallowing swapping processing stage order and affecting situations that pitch is decreased from the nominal.</para>
            </description>
            </item>
            </list>
            <para>The table below summarizes how the parameters can be adjusted for different applications:</para>
            <list type="table">
            <listheader><term>Parameter:</term><description>Effect:</description></listheader>
            <item><term>SEQUENCE_MS</term>
            <description>
            <para>Default value magnitude: Default value is relatively large, chosen for slowing down music tempo.</para>
            <para>Larger value affects: Larger value is usually better for slowing down tempo. Growing the value decelerates the "echoing" artifact when slowing down the tempo.</para>
            <para>Smaller value affects: Smaller value might be better for speeding up tempo. Reducing the value accelerates the "echoing" artifact when slowing down the tempo.</para>
            <para>Music: Default value usually good.</para>
            <para>Speech: A smaller value than default might be better.</para>
            <para>Effect in CPU burden: Increasing the parameter value reduces computation burden.</para>
            </description>
            </item>
            <item><term>SEEKWINDOW_MS</term>
            <description>
            <para>Default value magnitude: Default value is relatively large, chosen for slowing down music tempo.</para>
            <para>Larger value affects: Larger value eases finding a good mixing position, but may cause a "drifting" artifact.</para>
            <para>Smaller value affects: Smaller reduce possibility to find a good mixing position, but reduce the "drifting" artifact.</para>
            <para>Music: Default value usually good, unless a "drifting" artifact is disturbing.</para>
            <para>Speech: Default value usually good.</para>
            <para>Effect in CPU burden: Increasing the parameter value increases computation burden.</para>
            </description>
            </item>
            <item><term>OVERLAP_MS</term>
            <description>
            <para>Default value magnitude: Default value is relatively large, chosen to suit with above parameters.</para>
            <para>Larger value affects: --</para>
            <para>Smaller value affects: If you reduce the "sequence ms" setting, you might wish to try a smaller value.</para>
            <para>Music: --</para>
            <para>Speech: --</para>
            <para>Effect in CPU burden: Increasing the parameter value increases computation burden.</para>
            </description>
            </item>
            </list>
            <para>Performance Optimizations:</para>
            <list type="bullet">
            <item>
            <description>The time-stretch routine has a 'quick' mode that substantially speeds up the algorithm but may degrade the sound quality by a small amount. This mode is activated by <see cref="T:Un4seen.Bass.BASSAttribute">BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</see> and value <see langword="true"/>=1.</description>
            </item>
            <item>
            <description>Intel SSE optimized routines are used with compatible CPUs when floating point sample type is used. SSE optimizations are currently implemented for Win32 platform only. Processors compatible with SSE extension are Intel processors starting from Pentium-III, and AMD processors starting from Athlon XP.</description>
            </item>
            <item>
            <description>AMD 3DNow! optimized routines are used with compatible CPUs when floating point sample type is used, but SSE extension isn't supported . 3DNow! optimizations are currently implemented for Win32 platform only. These optimizations are used in AMD K6-2 and Athlon (classic) CPU's; better performing SSE routines are used with AMD processor starting from Athlon XP.</description>
            </item>
            </list>
            </remarks>
            <example>
            Create a playing tempo stream out of a decoding stream and loop it:
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            // the tempo channel
            int streamFX = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // change the sampling rate by 20%, the streamFX will be played faster
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO_FREQ, 0.2f);
            
            // change the tempo by -15%, the streamFX will be slower
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, -0.15f);
            
            // change the pitch (key) by one octave (12 semitones)
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, 12f);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' change the sampling rate by 20%, the streamFX will be played faster
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO_FREQ, 0.2F)
            
            ' change the tempo by -15%, the streamFX will be slower
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, -0.15F)
            
            ' change the pitch (key) by one octave (12 semitones)
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_TEMPO, 12F)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoGetSource(System.Int32)">
            <summary>
            Get the source channel handle.
            </summary>
            <param name="channel">Tempo stream handle.</param>
            <returns>If successful, the source channel handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            // the tempo channel
            int streamFX = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // this will return 'stream'
            int chan = BassFx.BASS_FX_TempoGetSource(streamFX);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_TempoCreate(stream, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' this will return 'stream'
            Dim chan As Integer = BassFx.BASS_FX_TempoGetSource(streamFX);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoGetRateRatio(System.Int32)">
            <summary>
            Get the ratio of the resulting rate and source rate (the resampling ratio).
            </summary>
            <param name="chan">Tempo stream (or source channel) handle.</param>
            <returns>If successful, the resampling ratio is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="chan"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Will return eg. 1.2 if the samplerate was increased by 20%:
            <code>
            float ratio = BassFx.BASS_FX_TempoGetRateRatio(streamFX);
            </code>
            <code lang="vbnet">
            Dim ratio As Single = BassFx.BASS_FX_TempoGetRateRatio(streamFX)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseCreate(System.Int32,System.Single,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a reversed stream from a decoding channel.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="dec_block">Length of decoding blocks in seconds. Larger blocks means less seeking overhead but larger spikes.</param>
            <param name="flags">A combination of the following flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed by DirectSound (ie. you can't loop just part of a sample).</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D samples must be mono (use BASS_SAMPLE_MONO).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well when the reverse channel is freed.</description></item>
            </list>
            </param>
            <returns>If successful, the handle of the reversed stream is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>MODs are supported, if BASS_MUSIC_PRESCAN flag was applied to a source handle. Enable reverse supported flags in <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseCreate(System.Int32,System.Single,Un4seen.Bass.BASSFlag)"/> and the others to source handle. 
            <para>For better MP3/2/1 reverse playback create the source stream using the BASS_STREAM_PRESCAN flag.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>/<see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/> to get or set the attributes of a reverse stream:
            <list type="table">
            <item><term>BASS_ATTRIB_REVERSE_DIR</term><description>The playback direction of a reverse channel (-1(less than 0)=reverse, 1(greater or equal 0)=forward, or use one of the <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXReverse"/> flags).</description></item>
            </list>
            These attributes can either be applied to the reverse channel or the underlying decoding source channel.
            Note, that when playing the channel reverse, the end of a reverse stream is reached at the logial beginning of the stream (this also applies to BASS_SYNC_END).
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a reverse stream with 2 seconds decoding blocks:
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE | 
                                                                        BASSFlag.BASS_STREAM_PRESCAN);
            // the reverse channel
            int streamFX = BassFx.BASS_FX_ReverseCreate(stream, 2f, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // play the channel reverse
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, -1f);
            // or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_REVERSE);
            
            // play the channel forward
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, 1f);
            // or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, (float)BASSFXReverse.BASS_FX_RVS_FORWARD);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE Or
                                                                                   BASSFlag.BASS_STREAM_PRESCAN)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_ReverseCreate(stream, 2F, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' play the channel reverse
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, -1F)
            ' or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, CSng(BASSFXReverse.BASS_FX_RVS_REVERSE))
            
            ' play the channel forward
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, 1F)
            ' or
            Bass.BASS_ChannelSetAttribute(streamFX, BASSAttribute.BASS_ATTRIB_REVERSE_DIR, CSng(BASSFXReverse.BASS_FX_RVS_FORWARD))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseGetSource(System.Int32)">
            <summary>
            Get the source channel handle of the reversed stream.
            </summary>
            <param name="channel">The handle of the reversed stream.</param>
            <returns>If successful, the handle of the source of the reversed stream is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // the source channel
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE | 
                                                                        BASSFlag.BASS_STREAM_PRESCAN);
            // the reverse channel
            int streamFX = BassFx.BASS_FX_ReverseCreate(stream, 2f, BASSFlag.BASS_FX_FREESOURCE);
            ...
            // this will return 'stream'
            int chan = BassFx.BASS_FX_ReverseGetSource(streamFX);
            </code>
            <code lang="vbnet">
            ' the source channel
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE Or
                                                                                   BASSFlag.BASS_STREAM_PRESCAN)
            ' the tempo channel
            Dim streamFX As Integer = BassFx.BASS_FX_ReverseCreate(stream, 2F, BASSFlag.BASS_FX_FREESOURCE)
            ...
            ' this will return 'stream'
            Dim chan As Integer = BassFx.BASS_FX_ReverseGetSource(streamFX);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)">
            <summary>
            Get the original BPM of a decoding channel.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="startSec">Start detecting position in seconds (if &lt;0 it uses the current position).</param>
            <param name="endSec">End detecting position in seconds (&gt; 0).</param>
            <param name="minMaxBPM">Set min &amp; max bpm, e.g: <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(LowWord, HighWord), LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="flags">Use one of the following (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_BKGRND</term><description>If in use, then you can do other stuff while detection's in process.</description></item>
            <item><term>BASS_FX_BPM_MULT2</term><description>If in use, then the detected BPM will be automatically multiplied by 2 if (BPM &lt; minBPM*2) - recommended setting.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well?</description></item>
            </list>
            </param>
            <param name="proc">User defined function to receive the process in percents (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC"/>), use <see langword="null"/> if not in use.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the original BPM value is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The BPM detection algorithm works by detecting repeating low-frequency (&lt;250Hz) sound patterns and thus works mostly with most rock/pop music with bass or drum beat. 
            The BPM detection doesn't work on pieces such as classical music without distinct, repeating bass frequency patterns. Also pieces with varying tempo, varying bass patterns or very complex bass patterns (jazz, hiphop) may produce odd BPM readings.</para>
            <para>In cases when the bass pattern drifts a bit around a nominal beat rate (e.g. drummer is again drunken ;-), the BPM algorithm may report incorrect harmonic one-halft to one-thirdth of the correct BPM value.
            In such case the system could for example report BPM value of 50 or 100 instead of correct BPM value of 150.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The <paramref name="channel"/>'s format is not supported. Make sure the channel is either Stereo or Mono.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>BPM detection, for this <paramref name="channel"/> is already in use.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the BPM value for the first 120 seconds of a track:
            <code>
            private BPMPROGRESSPROC _bpmProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            _bpmProc = new BPMPROGRESSPROC(MyBPMProc);
            float bpm = BassFx.BASS_FX_BPM_DecodeGet(stream, 0.0, 120.0, 0, BASSFXBpm.BASS_FX_BPM_BKGRND | 
                                                                            BASSFXBpm.BASS_FX_FREESOURCE | 
                                                                            BASSFXBpm.BASS_FX_BPM_MULT2, _bpmProc);
            BassFx.BASS_FX_BPM_Free(stream);
            ...
            private void MyBPMProc(int channel, float percent)
            {
              Console.Write("{0}%\r", percent);
            }
            </code>
            <code lang="vbnet">
            Private _bpmProc As BPMPROGRESSPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            _bpmProc = New BPMPROGRESSPROC(AddressOf MyBPMProc)
            Dim bpm As Single = BassFx.BASS_FX_BPM_DecodeGet(stream, 0.0, 120.0, 0, BASSFXBpm.BASS_FX_BPM_BKGRND Or 
                                                                                    BASSFXBpm.BASS_FX_FREESOURCE Or 
                                                                                    BASSFXBpm.BASS_FX_BPM_MULT2, _bpmProc)
            BassFx.BASS_FX_BPM_Free(stream)
            ...
            Private Sub MyBPMProc(channel As Integer, percent As Single)
              Console.Write("{0}%\r", percent)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds of the decoded channel using a callback function.
            </summary>
            <param name="channel">Stream/music/wma/cd/any other supported add-on format using a decoding channel.</param>
            <param name="startSec">Start detecting position in seconds.</param>
            <param name="endSec">End detecting position in seconds (&gt; 0).</param>
            <param name="flags">Use one of the following (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_BKGRND</term><description>If in use, then you can do other stuff while detection's in process.</description></item>
            <item><term>BASS_FX_FREESOURCE</term><description>Free the source handle as well?</description></item>
            </list>
            </param>
            <param name="proc">User defined function to receive the beat position values (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMBEATPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method works pretty much the same as <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> respectivly <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)"/> - it is almost a mix of the two of them.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The <paramref name="channel"/> is not a decoding channel. Make sure the channel was created using the BASS_STREAM_DECODE or BASS_MUSIC_DECODE flag.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>Beat detection, for this <paramref name="channel"/> is already in use.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get all the beat positions of the first minute of a track:
            <code>
            private BPMBEATPROC _beatProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            _beatProc = new BPMBEATPROC(MyBeatProc);
            BassFx.BASS_FX_BPM_BeatDecodeGet(stream, 0.0, 60.0, BASSFXBpm.BASS_FX_BPM_BKGRND, _beatProc, IntPtr.Zero);
            BassFx.BASS_FX_BPM_BeatFree(stream);
            ...
            private void MyBeatProc(int channel, double beatpos, IntPtr user)
            {
              Console.WriteLine("Beat at: {0}", beatpos);
            }
            </code>
            <code lang="vbnet">
            Private _beatProc As BPMBEATPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            _beatProc = New BPMBEATPROC(AddressOf MyBeatProc)
            BassFx.BASS_FX_BPM_BeatDecodeGet(stream, 0.0, 60.0, BASSFXBpm.BASS_FX_BPM_BKGRND, _beatProc, IntPtr.Zero)
            BassFx.BASS_FX_BPM_BeatFree(stream)
            ...
            Private Sub MyBeatProc(channel As Integer, beatpos As Double, user As IntPtr)
              Console.WriteLine("Beat at: {0}", beatpos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_Translate(System.Int32,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans)">
            <summary>
            Translate the given BPM to FREQ/PERCENT and vice versa or multiply BPM by 2.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="val2tran">Specify a value to translate to a given option (no matter if used X2).</param>
            <param name="trans">Any of the following translation options (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_TRAN_X2</term><description>Multiply the original BPM value by 2. This may be used only once, and will change the original BPM as well.</description></item>
            <item><term>BASS_FX_BPM_TRAN_2FREQ</term><description>BPM value to Frequency.</description></item>
            <item><term>BASS_FX_BPM_TRAN_FREQ2</term><description>Frequency to BPM value.</description></item>
            <item><term>BASS_FX_BPM_TRAN_2PERCENT</term><description>Percents to BPM value.</description></item>
            <item><term>BASS_FX_BPM_TRAN_PERCENT2</term><description>BPM value to Percents.</description></item>
            </list>
            </param>
            <returns>If successful, the newly calculated value is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function will not detect the BPM, it will just translate the detected original BPM value of a given handle.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>BASS_FX_BPM_TRAN_X2 already used on this handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following method does a simple translation assuming you have calculated the original BPM on a source channel:
            <code>
            private float GetNewBPM(int sourceChannel, int tempoChannel)
            {
              return BassFx.BASS_FX_BPM_Translate(sourceChannel, 
                                                  BassFx.BASS_FX_TempoGetRateRatio(tempoChannel) * 100f, 
                                                  BASSFXBpmTrans.BASS_FX_BPM_PERCENT2);
            }
            </code>
            <code lang="vbnet">
            Private Function GetNewBPM(sourceChannel As Integer, tempoChannel As Integer) As Single
              Return BassFx.BASS_FX_BPM_Translate(sourceChannel, 
                                                  BassFx.BASS_FX_TempoGetRateRatio(tempoChannel) * 100F, 
                                                  BASSFXBpmTrans.BASS_FX_BPM_PERCENT2)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_Free(System.Int32)">
            <summary>
            Frees all resources used by a given handle.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Used together with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/>.
            If BASS_FX_FREESOURCE was used, this will also free the underlying decoding channel as well.
            You can't set/get this flag with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>/<see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)">
            <summary>
            Enable getting BPM value by period of time in seconds.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="proc">User defined function to receive the bpm value (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMPROC"/>).</param>
            <param name="period">Detection period in seconds.</param>
            <param name="minMaxBPM">Set min &amp; max bpm, e.g: <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(LowWord, HighWord), LowWord=Min, HighWord=Max. 0 = defaults to 45/230.</param>
            <param name="flags">Use one of the following (see <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm"/>):
            <list type="table">
            <item><term>BASS_FX_BPM_MULT2</term><description>If in use, then the detected BPM will be automatically multiplied by 2 if (BPM &lt; minBPM*2) - recommended setting.</description></item>
            </list>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>BASS_FX_BPM_TRAN_X2 already used on this handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Getting BPM values in periods of 10 seconds:
            <code>
            private BPMPROC _bpmProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE);
            _bpmProc = new BPMPROC(MyBPMProc);
            BassFx.BASS_FX_BPM_CallbackSet(stream, _bpmProc, 10.0, Utils.MakeLong(45,240), 
                                           BASSFXBpm.BASS_FX_BPM_MULT2, IntPtr.Zero);
            ...
            private void MyBPMProc(int handle, float bpm, IntPtr user)
            {
              Console.Write("BPM: {0}\r", bpm);
            }
            </code>
            <code lang="vbnet">
            Private _bpmProc As BPMPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_STREAM_DECODE)
            _bpmProc = New BPMPROC(MyBPMProc)
            BassFx.BASS_FX_BPM_CallbackSet(stream, _bpmProc, 10.0, Utils.MakeLong(45, 240), 
                                           BASSFXBpm.BASS_FX_BPM_MULT2, IntPtr.Zero)
            ...
            Private Sub MyBPMProc(handle As Integer, bpm As Single, user As IntPtr)
              Console.Write("BPM: {0}" + ControlChars.Cr, bpm)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackReset(System.Int32)">
            <summary>
            Reset the BPM buffers.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the BPM callback. The BPM callback is automatically reset by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)">
            <summary>
            Enable getting Beat position in seconds in real-time.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="proc">User defined function to receive the beat position values (see <see cref="T:Un4seen.Bass.AddOn.Fx.BPMBEATPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method works on real-time (buffered) as well as on decoding channels and might also be used together with Tempo channels.
            <para><see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatFree(System.Int32)"/> must be called at the end to free the real-time beat position callback and resources.</para>
            <para>Note: You should call <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackReset(System.Int32)"/> after you have changed the position of the stream when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get all the beat positions of the first minute of a track:
            <code>
            private BPMBEATPROC _beatProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT);
            _beatProc = new BPMBEATPROC(MyBeatProc);
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MyBeatProc(int channel, double beatpos, IntPtr user)
            {
              Console.WriteLine("Beat at: {0}", beatpos);
            }
            </code>
            <code lang="vbnet">
            Private _beatProc As BPMBEATPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT)
            _beatProc = New BPMBEATPROC(AddressOf MyBeatProc)
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MyBeatProc(channel As Integer, beatpos As Double, user As IntPtr)
              Console.WriteLine("Beat at: {0}", beatpos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackReset(System.Int32)">
            <summary>
            Resets the internal buffers.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function flushes the internal buffers of the Beat callback. The Beat callback is automatically reset by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatSetParameters(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Set new values for beat detection parameters.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="bandwidth">Bandwidth in Hz between 0 and samplerate/2 (-1.0f = leave current, default is 10Hz).</param>
            <param name="centerfreq">The center-frequency in Hz of the band pass filter between 0 and samplerate/2 (-1.0f = leave current, default is 90Hz).</param>
            <param name="beat_rtime">Beat release time in ms. (-1.0f = leave current, default is 20ms).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter. A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="bandwidth"/> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="centerfreq"/> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="beat_rtime"/> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set. So the <paramref name="beat_rtime"/> should avoid, that a second (quickly repeated beat) beat is detected.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get all the beat positions of the first minute of a track:
            <code>
            private BPMBEATPROC _beatProc;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT);
            _beatProc = new BPMBEATPROC(MyBeatProc);
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero);
            BassFx.BASS_FX_BPM_BeatSetParameters(stream, 20f, 110f, 24f);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MyBeatProc(int channel, double beatpos, IntPtr user)
            {
              Console.WriteLine("Beat at: {0}", beatpos);
            }
            </code>
            <code lang="vbnet">
            Private _beatProc As BPMBEATPROC
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT)
            _beatProc = New BPMBEATPROC(AddressOf MyBeatProc)
            BassFx.BASS_FX_BPM_BeatCallbackSet(stream, _beatProc, IntPtr.Zero)
            BassFx.BASS_FX_BPM_BeatSetParameters(stream, 20F, 240F, 24F)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MyBeatProc(channel As Integer, beatpos As Double, user As IntPtr)
              Console.WriteLine("Beat at: {0}", beatpos)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatGetParameters(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>
            Gets the current beat detection parameter values.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="bandwidth">Current bandwidth in Hz.</param>
            <param name="centerfreq">Current center-frequency in Hz of the band pass filter.</param>
            <param name="beat_rtime">Current beat release time in ms.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter. A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="bandwidth"/> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="centerfreq"/> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="beat_rtime"/> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set. So the <paramref name="beat_rtime"/> should avoid, that a second (quickly repeated beat) beat is detected.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current beat parameters:
            <code>
            float bandwidth = 0f;
            float centerfreq = 0f;
            float beat_rtime = 0f;
            if (BassFx.BASS_FX_BPM_BeatGetParameters(stream, ref bandwidth, ref centerfreq, ref beat_rtime))
            {
              Console.WriteLine("Bandwidth={0}, Center-Freq={1}, Release-Time={2}", bandwidth, centerfreq, beat_rtime);
            }
            </code>
            <code lang="vbnet">
            Dim bandwidth As Single = 0F
            Dim centerfreq As Single = 0F
            Dim beat_rtime As Single = 0F
            If BassFx.BASS_FX_BPM_BeatGetParameters(stream, bandwidth, centerfreq, beat_rtime) Then
              Console.WriteLine("Bandwidth={0}, Center-Freq={1}, Release-Time={2}", bandwidth, centerfreq, beat_rtime)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatGetParameters(System.Int32,System.Object,System.Object,System.Object)">
            <summary>
            Gets the current beat parameter values.
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <param name="bandwidth">Current bandwidth in Hz (<see langword="null"/>=don't retrieve it).</param>
            <param name="centerfreq">Current center-frequency of the band pass filter in Hz (<see langword="null"/>=don't retrieve it).</param>
            <param name="beat_rtime">Current beat release time in ms. (<see langword="null"/>=don't retrieve it).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Beat detection is using a Band Pass Filter. A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range.
            So the <paramref name="bandwidth"/> parameter defines the range around a center-frequency to include in the beat detection algo.
            The <paramref name="centerfreq"/> parameter actually defines the center-frequency of the band pass filter.
            Once a beat is detected, the <paramref name="beat_rtime"/> parameter defines the time in ms. in which no other beat will be detected after that just detected beat. 
            The background is, that often you have kind-of 'double beats' in a drum set. So the <paramref name="beat_rtime"/> should avoid, that a second (quickly repeated beat) beat is detected.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current beat release time only:
            <code>
            object beat_rtime = 0f;
            if (BassFx.BASS_FX_BPM_BeatGetParameters(stream, null, null, beat_rtime))
            {
              // beat_rtime must be casted back to a float
              Console.WriteLine("Release-Time={0}", (float)beat_rtime);
            }
            </code>
            <code lang="vbnet">
            Dim beat_rtime As Object = 0F
            If BassFx.BASS_FX_BPM_BeatGetParameters(stream, Nothing, Nothing, beat_rtime) Then
              ' beat_rtime must be casted back to a float
              Console.WriteLine("Release-Time={0}", CSng(beat_rtime))
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatFree(System.Int32)">
            <summary>
            Free all resources used by a given handle (decode or callback beat).
            </summary>
            <param name="handle">Stream/music/wma/cd/any other supported add-on format.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Used together with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/>.
            <para>Note: If the BASS_FX_FREESOURCE flag is used, this will free the source decoding channel as well. You can't set/get this flag with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BassFx.BASSFXVERSION">
            <summary>
            Current BASS_FX version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXBpm">
            <summary>
            BASS_FX BPM/Beat options, to be used with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> resp. <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_BPM_DEFAULT">
            <summary>
            Decode: No option.
            <para>Caution: when used with the Translate methods this flag would be identical to BASS_FX_BPM_X2.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_BPM_BKGRND">
            <summary>
            Decode: Do the processing in a background thread.
            <para>If in use, then you can do other stuff while detection's in process.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_BPM_MULT2">
            <summary>
            Decode: If in use, then will auto multiply bpm by 2 (if BPM &lt; MinBPM*2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpm.BASS_FX_FREESOURCE">
            <summary>
            Decode: Free the source handle as well?
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans">
            <summary>
            BASS_FX BPM Translation options, to be used with <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_Translate(System.Int32,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_X2">
            <summary>
            BPM Translate: Multiply the original BPM value by 2 (may be called only once &amp; will change the original BPM as well!).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_2FREQ">
            <summary>
            BPM Translate: BPM value to Frequency.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_FREQ2">
            <summary>
            BPM Translate: Frequency to BPM value.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_2PERCENT">
            <summary>
            BPM Translate: Percents to BPM value.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXBpmTrans.BASS_FX_BPM_TRAN_PERCENT2">
            <summary>
            BPM Translate: BPM value to Percents.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXReverse">
            <summary>
            BASS_FX Reverse Playback directions, to be used with the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)">BASS_ATTRIB_REVERSE_DIR</see> attribute.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXReverse.BASS_FX_RVS_REVERSE">
            <summary>
            Playing in reverse direction.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXReverse.BASS_FX_RVS_FORWARD">
            <summary>
            Playing in forward direction.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSFXChan">
            <summary>
            DSP channels flags.
            </summary>
            <remarks>
            <para>Multi-channel order of each channel is as follows:</para>
            <list type="table">
            <item><term>3 channels</term><description>left-front, right-front, center.</description></item>
            <item><term>4 channels</term><description>left-front, right-front, left-rear/side, right-rear/side.</description></item>
            <item><term>6 channels (5.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side.</description></item>
            <item><term>8 channels (7.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHANALL">
            <summary>
            All channels at once (as by default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHANNONE">
            <summary>
            Disable an effect for all channels (resp. set the global volume of the <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/> effect).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN1">
            <summary>
            left-front channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN2">
            <summary>
            right-front channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN3">
            <summary>
            Channel 3: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN4">
            <summary>
            Channel 4: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN5">
            <summary>
            Channel 5: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN6">
            <summary>
            Channel 6: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN7">
            <summary>
            Channel 7: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN8">
            <summary>
            Channel 8: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN9">
            <summary>
            Channel 9: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN10">
            <summary>
            Channel 10: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN11">
            <summary>
            Channel 11: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN12">
            <summary>
            Channel 12: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN13">
            <summary>
            Channel 13: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN14">
            <summary>
            Channel 14: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN15">
            <summary>
            Channel 15: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN16">
            <summary>
            Channel 16: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN17">
            <summary>
            Channel 17: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN18">
            <summary>
            Channel 18: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN19">
            <summary>
            Channel 19: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN20">
            <summary>
            Channel 20: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN21">
            <summary>
            Channel 21: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN22">
            <summary>
            Channel 22: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN23">
            <summary>
            Channel 23: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN24">
            <summary>
            Channel 24: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN25">
            <summary>
            Channel 25: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN26">
            <summary>
            Channel 26: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN27">
            <summary>
            Channel 27: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN28">
            <summary>
            Channel 28: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN29">
            <summary>
            Channel 29: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSFXChan.BASS_BFX_CHAN30">
            <summary>
            Channel 30: depends on the multi-channel source (see above info).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASSBFXBQF">
            <summary>
            BASS_BFX BiQuad filters. Defines within the <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF"/> structure which BiQuad filter should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_LOWPASS">
            <summary>
            BiQuad Lowpass filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_HIGHPASS">
            <summary>
            BiQuad Highpass filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_BANDPASS">
            <summary>
            BiQuad Bandpass filter (constant 0 dB peak gain).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_BANDPASS_Q">
            <summary>
            BiQuad Bandpass Q filter (constant skirt gain, peak gain = Q).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_NOTCH">
            <summary>
            BiQuad Notch filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_ALLPASS">
            <summary>
            BiQuad All-Pass filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_PEAKINGEQ">
            <summary>
            BiQuad Peaking EQ filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_LOWSHELF">
            <summary>
            BiQuad Low-Shelf filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASSBFXBQF.BASS_BFX_BQF_HIGHSHELF">
            <summary>
            BiQuad High-Shelf filter.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Swap/Remap/Downmix.
            </summary>
            <remarks>
            This effect mixes those channels together which are specified in the 'lChannel' array.
            Where each array element represent the target channel (0=CHAN1, 1=CHAN2 etc.) it's value represents the source channels which should be mixed together.
            If you set a BASS_BFX_CHANNONE flag on a channel, then it will be muted.
            This allows you to either downmix, remap or swap any channels with/to any channel.
            <para>Example 1: Downmix Channel 1 with Channel 5 and put it in Channel 1
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN1 | BASSFXChan.BASS_BFX_CHAN5
            </code>
            </para>
            <para>Example 2: Swap channel 1 and channel 2
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN2
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN1
            </code>
            </para>
            <para>Example 3: Duplicate channel 1 to channel 2
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN1
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN1
            </code>
            </para>
            <para>Example 4: Remap channel 1 so it will be in channel 2 and 3
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN1
            lChannel[2] = BASSFXChan.BASS_BFX_CHAN1
            </code>
            </para>
            <para>Example 5: Downmix 5.1 to Stereo
            <code lang="none">
            lChannel[0] = BASSFXChan.BASS_BFX_CHAN1 | BASSFXChan.BASS_BFX_CHAN3 | BASSFXChan.BASS_BFX_CHAN5
            lChannel[1] = BASSFXChan.BASS_BFX_CHAN2 | BASSFXChan.BASS_BFX_CHAN4 | BASSFXChan.BASS_BFX_CHAN6
            lChannel[2] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[3] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[4] = BASSFXChan.BASS_BFX_CHANNONE
            lChannel[5] = BASSFXChan.BASS_BFX_CHANNONE
            </code>
            </para>
            <para>Multi-channel index is as follows:
            <list type="table">
            <item><term>Mono</term><description>0=left.</description></item>
            <item><term>Stereo</term><description>0=left, 1=right.</description></item>
            <item><term>3 channels</term><description>0=left-front, 1=right-front, 2=center.</description></item>
            <item><term>4 channels</term><description>0=left-front, 1=right-front, 2=left-rear/side, 3=right-rear/side.</description></item>
            <item><term>6 channels (5.1)</term><description>0=left-front, 1=right-front, 2=center, 3=LFE, 4=left-rear/side, 5=right-rear/side.</description></item>
            <item><term>8 channels (7.1)</term><description>0=left-front, 1=right-front, 2=center, 3=LFE, 4=left-rear/side, 5=right-rear/side, 6=left-rear center, 7=right-rear center.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.lChannel">
            <summary>
            Array of channels to mix together using <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag's (lChannel[0]=1st=left, lChannel[0]=2nd=right channel etc.).
            </summary>
            <remarks>Each value of an element represents a <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag specifying the source channels to be mixed/used.
            Whereas the element index determines the target channel to put the mixed channels to.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.#ctor(System.Int32)">
            <summary>
            Constructor assigning a linear 1:1 remap (0=CHAN1, 1=CHAN2 etc.).
            </summary>
            <param name="numChans">The number of channels to use.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.#ctor(Un4seen.Bass.AddOn.Fx.BASSFXChan[])">
            <summary>
            Constructor already setting the channel order.
            </summary>
            <param name="channels">The variable list of the zero-based channel indexes (1st=0, 2nd=1,...). Each parameter will be applied in exactly this order.</param>
            <example>
            Swap channels 1 and 2:
            <code>
            BASS_BFX_MIX swap = new BASS_BFX_MIX(BASSFXChan.BASS_BFX_CHAN2, BASSFXChan.BASS_BFX_CHAN1);
            int channel = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            int fxMix = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_MIX, 0);
            Bass.BASS_FXSetParameters(fxMix, swap);
            </code>
            <code lang="vbnet">
            Dim swap As New BASS_BFX_MIX(BASSFXChan.BASS_BFX_CHAN2, BASSFXChan.BASS_BFX_CHAN1)
            Dim channel As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim fxMix As Integer = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_MIX, 0)
            Bass.BASS_FXSetParameters(fxMix, swap)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.Finalize">
            <summary>
            Default Finilizer.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Rotate.
            </summary>
            <remarks>
            <para>This is a volume rotate effect between even channels, just like 2 channels playing ping-pong between each other.</para>
            <para>The fRate defines the speed in Hz.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE.fRate">
            <summary>
            Rotation rate/speed in Hz (A negative rate can be used for reverse direction).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE.#ctor(System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Rate">Rotation rate/speed in Hz (A negative rate can be used for reverse direction).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo.
            </summary>
            <remarks>No multi-channel option, only max. 2 channels (stereo).
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall.</para>
            <para>The fLevel is the volume of a signal. The lDelay is the delay time in ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.fLevel">
            <summary>
            Echo level (0...1..n, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.lDelay">
            <summary>
            Delay in ms (1200...30000). Default = 1200ms.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO.#ctor(System.Single,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Level">Echo level (0...1...n).</param>
            <param name="Delay">Delay in ms (1200...30000).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Flanger.
            </summary>
            <remarks>
            Flangers mix a varying delayed signal (usually about 5ms [0.005] to 15ms [0.015]) with the original to produce a series of notches in the frequency response. 
            The important difference between flanging and phasing is that a flanger produces a large number of notches that are harmonically (musically) related, while a phaser produces a small number of notches that are evenly spread across the frequency spectrum. 
            With high resonance, you get the "jet plane" effect.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.fWetDry">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal (0...1...n, linear, default=1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.fSpeed">
            <summary>
            Flanger speed in seconds (0...0.09, [0ms - 90ms]). Default 0.01.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.#ctor(System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="WetDry">Ratio of wet (processed) signal to dry (unprocessed) signal (0...1...n).</param>
            <param name="Speed">Flanger speed in seconds (0...0.09).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.#ctor(System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="WetDry">Ratio of wet (processed) signal to dry (unprocessed) signal (0...1...n).</param>
            <param name="Speed">Flanger speed in seconds (0...0.09).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER.Preset_Default">
            <summary>
            Sets the instance members to a preset (WetDry=1, Speed=0.012).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Volume. (L/R for STEREO, L for MONO for both channels).
            </summary>
            <remarks>Global volume is set to 1.0 [0dB]. Channels volume can't be greater than global volume.
            To set a new global volume, set lChannel = 0.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect. 0 (BASS_FX_DSP_CHANNONE) for global volume control.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.fVolume">
            <summary>
            Volume of the channel (0..1..n). Default = 1 (no amplification).
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.#ctor(System.Single)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Volume">Volume of all channel (0..1..n).</param>
            <remarks>The volume is a float value between 0.0 (silence) and 1.0 (full volume, no amplification). A value above 1.0 indicates an amplification, which might cause distortion, if the original sound gets too lound and might needs to be clipped later.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME.#ctor(System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Volume">Volume of all channel (0..1..n).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
            <remarks>The volume is a float value between 0.0 (silence) and 1.0 (full volume, no amplification). A value above 1.0 indicates an amplification, which might cause distortion, if the original sound gets too lound and might needs to be clipped later.</remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Peaking equalizer.
            </summary>
            <example>
            Setting up a multi-band EQ:
            <code>
            private int _fxEQ;
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_SAMPLE_FLOAT);
            SetBFX_EQ(stream);
            ...
            // increase the treble by +6bB
            UpdateFX(2, 6f);
            ...
            
            private void SetBFX_EQ(int channel)
            {
              // set peaking equalizer effect with no bands
              _fxEQ = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_PEAKEQ, 0);
            
              // setup the EQ bands
              BASS_BFX_PEAKEQ eq = new BASS_BFX_PEAKEQ();
              eq.fQ = 0f;
              eq.fBandwidth = 2.5f;
              eq.lChannel = BASSFXChan.BASS_BFX_CHANALL;
            
              // create 1st band for bass
              eq.lBand = 0;
              eq.fCenter = 125f;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
              UpdateFX(0, 0f);
            
              // create 2nd band for mid
              eq.lBand = 1;
              eq.fCenter = 1000f;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
              UpdateFX(1, 0f);
            
              // create 3rd band for treble
              eq.lBand = 2;
              eq.fCenter = 8000f;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
              UpdateFX(2, 0f);
            }
            
            private void UpdateFX(int band, float gain)
            {
              BASS_BFX_PEAKEQ eq = new BASS_BFX_PEAKEQ();
              // get values of the selected band
              eq.lBand = band;
              Bass.BASS_FXGetParameters(_fxEQ, eq);
              eq.fGain = gain;
              Bass.BASS_FXSetParameters(_fxEQ, eq);
            }
            </code>
            <code lang="vbnet">
            Private _fxEQ As Integer
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L.ToUInt32(), 0L.ToUInt32(), BASSFlag.BASS_SAMPLE_FLOAT)
            SetBFX_EQ(stream)
            ...
            ' increase the treble by +6bB
            UpdateFX(2, 6F)
            ...
            
            Private Sub SetBFX_EQ(channel As Integer)
              ' set peaking equalizer effect with no bands
              _fxEQ = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_BFX_PEAKEQ, 0)
            
              ' setup the EQ bands
              Dim eq As New BASS_BFX_PEAKEQ()
              eq.fQ = 0F
              eq.fBandwidth = 2.5F
              eq.lChannel = BASSFXChan.BASS_BFX_CHANALL
            
              ' create 1st band for bass
              eq.lBand = 0
              eq.fCenter = 125F
              Bass.BASS_FXSetParameters(_fxEQ, eq)
              UpdateFX(0, 0F)
            
              ' create 2nd band for mid
              eq.lBand = 1
              eq.fCenter = 1000F
              Bass.BASS_FXSetParameters(_fxEQ, eq)
              UpdateFX(1, 0F)
            
              ' create 3rd band for treble
              eq.lBand = 2
              eq.fCenter = 8000F
              Bass.BASS_FXSetParameters(_fxEQ, eq)
              UpdateFX(2, 0F)
            End Sub
            
            Private Sub UpdateFX(band As Integer, gain As Single)
              Dim eq As New BASS_BFX_PEAKEQ()
              ' get values of the selected band
              eq.lBand = band
              Bass.BASS_FXGetParameters(_fxEQ, eq)
              eq.fGain = gain
              Bass.BASS_FXSetParameters(_fxEQ, eq)
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.lBand">
            <summary>
            Number of bands (0...n), more bands means more memory and cpu usage. Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), Q is not in use (fBandwidth has priority over fQ). Default = 1 (0=not in use).
            <para>In most cases users should use the minimum of 0.5 octave.</para>
            <para>The bandwidth in octaves (between -3 dB frequencies for BPF and notch or between midpoint (dBgain/2) gain frequencies for peaking EQ).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fQ">
            <summary>
            EE kinda definition of Q (0.1...1...n), if bandwidth is not in use. Default = 0.0 (0=not in use).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fCenter">
            <summary>
            Center frequency in Hz (1Hz...nHz). Default = 1000 (max. is 1/2 of the samplerate).
            </summary>
            <remarks>Use 'oldcenter*freq/oldfreq' to update the fCenter after changing the samplerate.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.#ctor(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Band">Number of bands (0...n), more bands means more memory and cpu usage.</param>
            <param name="Bandwidth">Bandwidth in octaves (0.1...4), Q is not in use.</param>
            <param name="Q">EE kinda definition of Q (0...1...n), bandwidth is not in use.</param>
            <param name="Center">Center frequency in Hz (1...n).</param>
            <param name="Gain">Gain in dB (-15...0...+15).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ.#ctor(System.Int32,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Band">Number of bands (0...n), more bands means more memory and cpu usage.</param>
            <param name="Bandwidth">Bandwidth in octaves (0.1...4), Q is not in use.</param>
            <param name="Q">EE kinda definition of Q )0...1...n), bandwidth is not in use.</param>
            <param name="Center">Center frequency in Hz (1...n).</param>
            <param name="Gain">Gain in dB (-15...0...+15).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Reverb.
            </summary>
            <remarks>No multi-channel option, only max. 2 channels (stereo).
            <para>Reverb is the sound you hear in a room with hard surfaces (such as your bathroom) where sound bounces around the room for a while after the initial sound stops. This effect takes a lot of computing power to reproduce well.</para>
            <para>Reverb is actually made up of a very large number of repeats, with varying levels and tones over time. Reverbs usually offer you a choice of different algorithm to simulate different environments such as different sized rooms and halls, studio effects such as plate, chamber and reverse * reverbs, and sometimes emulations of guitar spring reverbs.</para>
            <para>The fLevel is the volume of a signal. The lDelay is the delay time in ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.fLevel">
            <summary>
            Reverb level (0...1...n, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.lDelay">
            <summary>
            Delay in ms (1200...10000). Default = 1200ms.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB.#ctor(System.Single,System.Int32)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Level">Reverb level (0...1...n).</param>
            <param name="Delay">Delay in ms (1200...10000).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Low pass filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.fResonance">
            <summary>
            Resonance (0.01...10). Default = 2.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.fCutOffFreq">
            <summary>
            Cut-off frequency in Hz (1...info.freq/2). Default = 200Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.#ctor(System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Resonance">Resonance (0.01...10).</param>
            <param name="CutOffFreq">Cut-off frequency in Hz (1...info.freq/2).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF.#ctor(System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Resonance">Resonance (0.01...10).</param>
            <param name="CutOffFreq">Cut-off frequency in Hz (1...info.freq/2).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Dynamic amplification.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fTarget">
            <summary>
            Target volume level (0&lt;...1, linear). Default = 1.0 (0dB).
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fQuiet">
            <summary>
            Quiet volume level (0...1, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fRate">
            <summary>
            Amplification adjustment rate (0...1, linear), e.g. 0.02. Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fGain">
            <summary>
            Amplification level (0...1...n, linear). Default = 0.
            </summary>
            <remarks>Examples: 0.0 = -unlimited dB, 0.5 = -6dB, 1.0 = 0dB, 2.0 = +6dB
            <para>To convert a dB value to a 0-1 linear value, you can do this:
            <code>double linear = Math.Pow(10d, dB / 20.0);</code>
            </para>
            <para>To convert a linear value to a dB value, you can do this:
            <code>double dB = 20.0 * Math.Log10(level / 1.0);</code>
            </para>
            Or use the <see cref="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)"/> methods.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.fDelay">
            <summary>
            Delay in seconds before increasing level (0...n, linear). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Target">Target volume level (0&lt;...1)</param>
            <param name="Quiet">Quiet volume level (0...1)</param>
            <param name="Rate">Amplification adjustment rate (0...1)</param>
            <param name="Gain">Amplification level (0...1...n)</param>
            <param name="Delay">Delay in seconds before increasing level (0...n)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Target">Target volume level (0&lt;...1)</param>
            <param name="Quiet">Quiet volume level (0...1)</param>
            <param name="Rate">Amplification adjustment rate (0...1)</param>
            <param name="Gain">Amplification level (0...1...n)</param>
            <param name="Delay">Delay in seconds before increasing level (0...n)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Auto wah.
            </summary>
            <remarks>
            <para>The effect implements the auto-wah by using 4-stage phaser effect which moves a peak in the frequency response up and down the frequency spectrum by amplitude of input signal.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fFeedback sets feedback of auto wah (phaser). The fRate and fRange control how fast and far the frequency notches move. The fRate is the rate of sweep in cycles per second, fRange is the width of sweep in octaves. And the the fFreq is the base frequency of sweep.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fRange">
            <summary>
            Sweep range in octaves (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range in octaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range in octaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_SlowAutoWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_FastAutoWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH.Preset_HiFastAutoWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo 2.
            </summary>
            <remarks>
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fDelay is the delay time in sec. The fFeedback sets how much delay is feed back to the input (for repeating delays).</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.fDelay">
            <summary>
            Delay in seconds (0&lt;...6). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Feedback">Feedback (-1..+1)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.#ctor(System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Feedback">Feedback (-1..+1)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.Preset_SmallEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.Preset_ManyEchoes">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2.Preset_ReverseEchoes">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Phaser.
            </summary>
            <remarks>
            <para>Phasers use an internal low frequency oscillator to automatically move notches in the frequency response up and down the frequency spectrum. 
            An important difference between phasing and flanging is that phasers space these notches evenly across the frequency spectrum, while the notches in flanging and chorus are harmonically (musically) related. 
            You don't hear the notches as such (because they are the frequencies that are removed). 
            What you hear is the resulting frequency peaks between these notches. Phasing works by mixing the original signal with one that is phase shifted over the frequency spectrum. 
            For example, a four stage phaser signal (such as this) could be from 0 degrees at 100Hz, shifted to 720 degrees at 5Khz (these extremes are not quite possible practically, but are near enough to explain the effect). 
            This is how the term phase shifter comes about. A 4 stage phaser has 2 notches with bass response, a central peak, and treble response. 
            By using resonance to enhance the central peak, you can get a sound similar to an automatic wah. 
            Using a phaser with lots of stages and setting the resonance high can give a sound similar to flanging, although they are really quite different.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. 
            The fFeedback sets feedback of phaser. 
            The fRate and fRange control how fast and far the frequency notches move. 
            The fRate is the rate of sweep in cycles per second, fRange is the width of sweep in octaves. 
            And the the fFreq is the base frequency of sweep.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fRate">
            <summary>
            Rate of sweep in cycles per second (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fRange">
            <summary>
            Sweep range inoctaves (0&lt;...&lt;10). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.fFreq">
            <summary>
            Base frequency of sweep range (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range inoctaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Rate">Rate of sweep in cycles per second (0&lt;...&lt;10)</param>
            <param name="Range">Sweep range inoctaves (0&lt;...&lt;10)</param>
            <param name="Freq">Base frequency of sweep range (0&lt;...1000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_PhaseShift">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_SlowInvertPhaseShiftWithFeedback">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_BasicPhase">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_PhaseWithFeedback">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_MediumPhase">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_FastPhase">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_InvertWithInvertFeedback">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER.Preset_TremoloWah">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo 3.
            </summary>
            <remarks>
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fDelay is the delay time in sec.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.fDelay">
            <summary>
            Delay in seconds (0&lt;...6). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.#ctor(System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.Preset_SmallEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.Preset_DoubleKick">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3.Preset_LongEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Chorus.
            </summary>
            <remarks>
            <para>True vintage chorus works the same way as flanging. 
            It mixes a varying delayed signal with the original to produce a large number of harmonically related notches in the frequency response. 
            Chorus uses a longer delay than flanging, so there is a perception of "spaciousness", although the delay is too short to hear as a distinct slap-back echo. 
            There is also little or no feedback, so the effect is more subtle.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. 
            The fFeedback sets feedback of chorus. 
            The fRate, fMinSweep and fMaxSweep control how fast and far the frequency notches move. 
            The fRate is the rate of delay change in millisecs per sec, fMaxSweep-fMinSweep is the range or width of sweep in ms.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fMinSweep">
            <summary>
            Minimum delay in ms (0&lt;...6000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fMaxSweep">
            <summary>
            Maximum delay in ms (0&lt;...6000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.fRate">
            <summary>
            Rate in ms/s (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="MinSweep">Minimum delay in ms (0&lt;...6000)</param>
            <param name="MaxSweep">Maximum delay in ms (0&lt;...6000)</param>
            <param name="Rate">Rate in ms/s (0&lt;...1000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2...+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2...+2)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="MinSweep">Minimum delay in ms (0&lt;...6000)</param>
            <param name="MaxSweep">Maximum delay in ms (0&lt;...6000)</param>
            <param name="Rate">Rate in ms/s (0&lt;...1000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Flanger">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_ExaggeratedChorusLTMPitchSshiftedVoices">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Motocycle">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Devil">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_WhoSayTTNManyVoices">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_BackChipmunk">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_Water">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS.Preset_ThisIsTheAirplane">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect All pass filter.
            </summary>
            <remarks>
            <para>The allpass filter has the unique property that it passes all frequencies equally. This property makes it useful in reverberator design because it increases echo density while reducing signal coloration (an allpass filter is NOT transparent to transient signals, as it does have a phase response). The structure of an allpass filter is similar to the comb filter, but it contains an additional feedforward path. In reverb applications, the delay used in an allpass filter is generally measured in milliseconds. This keeps the 'reflections' spaced apart in a similar fashion to a room's impulse response.</para>
            <para>The fDelay sets delay for all pass filter. The fGain controls the gain of all pass filter.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.fGain">
            <summary>
            Gain of the all pass filter (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.fDelay">
            <summary>
            Delay in seconds (0...6). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.#ctor(System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Gain">Gain (-1..+1)</param>
            <param name="Delay">Delay in seconds (0..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.#ctor(System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Gain">Gain (-1..+1)</param>
            <param name="Delay">Delay in seconds (0..6)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_SmallRever">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_RobotVoice">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF.Preset_LongReverberation">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Dynamic Range Compressor.
            </summary>
            <remarks>
            <para>Compressors are commonly used in recording to control the level, by making loud passages quieter, and quiet passages louder. 
            This is useful in allowing a vocalist to sing quiet and loud for different emphasis, and always be heard clearly in the mix. 
            Compression is generally applied to guitar to give clean sustain, where the start of a note is "squashed" with the gain automatically increased as the not fades away. 
            Compressors take a short time to react to a picked note, and it can be difficult to find settings that react quickly enough to the volume change without killing the natural attack sound of your guitar.</para>
            <para>The fThreshold sets the level above which volume is cut, and below which volume is boosted. 
            This is usually achieved simply by increasing the internal gain, so it really controls the amount of perceived sustain. 
            The fAttacktime controls how fast the unit responds to volume increases. 
            The fReleasetime controls how slowly the unit responds to decreasing volume.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.fThreshold">
            <summary>
            Compressor threshold (0...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.fAttacktime">
            <summary>
            Attack time in ms (0&lt;...1000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.fReleasetime">
            <summary>
            Release time in ms (0&lt;...5000). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_FX_DSP_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Threshold">Compressor threshold (0...+1)</param>
            <param name="Attacktime">Attack time in ms (0&lt;...1000)</param>
            <param name="Releasetime">Release time in ms (0&lt;...5000)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.#ctor(System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Threshold">Compressor threshold (0...+1)</param>
            <param name="Attacktime">Attack time in ms (0&lt;...1000)</param>
            <param name="Releasetime">Release time in ms (0&lt;...5000)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_50Attack15msRelease1sec">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -6 dB</para>
            <para>Attack: 15ms</para>
            <para>Release: 1sec</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_80Attack1msRelease05sec">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -2 dB</para>
            <para>Attack: 1ms</para>
            <para>Release: 500ms</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -1 dB</para>
            <para>Attack: 20ms</para>
            <para>Release: 350ms</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_SoftHigh">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <remarks>
            <para>Threshold: -3 dB</para>
            <para>Attack: 10ms</para>
            <para>Release: 200ms</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <para>Threshold: -6 dB</para>
            <para>Attack: 5ms</para>
            <para>Release: 250ms</para>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
            <para>Threshold: -12 dB</para>
            <para>Attack: 2.2ms</para>
            <para>Release: 400ms</para>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Distortion.
            </summary>
            <remarks>
            <para>Similar to Pre/Post Gain and Drive controls on amps. 
            They were first introduced as a trick to added color to a guitar's tone. 
            Usually produced back then by turning the amp all the way up, or slightly pulling out a tube from its socket. 
            These tones are now today referred to as Overdrives. 
            Today, there are an almost infinite variety of these effects, and they range in 3 classes: Distortions, Fuzz, and Overdrive. 
            One common feature to mostly all of these types of pedals is a volume and drive (also noted as distortion, fuzz, gain, ...etc.). 
            Overdrives are usually a sustain and volume boosting pedal. Used by more traditional rock and country bands. 
            Next are the Distortions, which range from punk style to death metal screams. They are similar to Overdrives, but have more buzzing quality to them. 
            Finally, there are the Fuzzes which are more distorted than distortions, but are more mellow and compressed sounding. 
            Many pedals can be confused within these names, and some may be named other than what they are. 
            Towards the end of this era, the back-to-back diode pair became popular as a technique to provide soft clipping (with germanium diodes) and hard clipping (with silicon diodes). 
            Today, overdrive effects usually means soft clipping, where gain is reduced beyond the clipping point, while distortion usually means hard clipping, where the level is fixed beyond the clipping point. 
            Distortion is a little harder sound, good for rock, while overdrive gives a more natural sound.</para>
            <para>The fDrive controls the amount of overdrive. 
            The fVolume to balance the effect volume with the bypassed level. 
            It can also be used to boost the signal for solos. 
            The fDryMix is the volume of input signal and the fWetMix is the volume of distorted signal. 
            The fFeedback sets feedback of distortion.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fDrive">
            <summary>
            Distortion drive (0...5). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-5...+5). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fWetMix">
            <summary>
            Wet (affected) signal mix (-5...+5). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fFeedback">
            <summary>
            Feedback (-1...+1). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.fVolume">
            <summary>
            Distortion volume (0...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Drive">Distortion drive (0...5)</param>
            <param name="DryMix">Dry (unaffected) signal mix (-5...+5)</param>
            <param name="WetMix">Wet (affected) signal mix (-5...+5)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Volume">Distortion volume (0...+2)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="Drive">Distortion drive (0...5)</param>
            <param name="DryMix">Dry (unaffected) signal mix (-5...+5)</param>
            <param name="WetMix">Wet (affected) signal mix (-5...+5)</param>
            <param name="Feedback">Feedback (-1...+1)</param>
            <param name="Volume">Distortion volume (0...+2)</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.Preset_HardDistortion">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.Preset_VeryHardDistortion">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION.Preset_MediumDistortion">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Dynamic Range Compressor.
            </summary>
            <remarks>
            Dynamic range compression also called DRC, or simply compression, is a process that reduces the dynamic range of an audio signal. 
            Compression is used during sound recording, live sound reinforcement, and broadcasting to control the level of audio. A compressor is the device used to apply compression.
            <para>Compressors are commonly used in recording to control the level, by making loud passages quieter, and quiet passages louder. 
            This is useful in allowing a vocalist to sing quiet and loud for different emphasis, and always be heard clearly in the mix. 
            Compression is generally applied to guitar to give clean sustain, where the start of a note is "squashed" with the gain automatically increased as the not fades away. 
            Compressors take a short time to react to a picked note, and it can be difficult to find settings that react quickly enough to the volume change without killing the natural attack sound of your guitar.</para>
            <para>The fThreshold sets the level above which volume is reduced in level while quiet sound are untreated (downward compression). 
            The fAttack controls how fast the unit responds to volume increases. 
            The fRelease controls how slowly the unit responds to decreasing volume.</para>
            <para>The compressor reduces the gain (level) of an audio signal if its amplitude exceeds a threshold (using RMS sensing with a hard knee). 
            The amount of gain reduction is determined by a ratio. For example, with a ratio of 4:1, when the (time averaged) input level is 4 dB over the threshold, the output signal level will be 1 dB over the threshold. 
            The gain (level) has been reduced by 3 dB. When the input level is 8 dB above the threshold, the output level will be 2 dB; a 6 dB gain reduction.
            A more specific example for a 4:1 ratio:
            Threshold = 10 dB;
            Input = 6 dB (4 dB above the threshold);
            Output = 9 dB (1 dB above the threshold)
            </para>
            <para>With any threshold/ratio combination, you could calculate the gain for a 0dB peak like this:
            fGain=fThreshold*(1/fRatio-1)</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.fGain">
            <summary>
            Output gain in dB of signal after compression, in the range from -60 to 60. The default value is 5 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.fThreshold">
            <summary>
            Point in dB at which compression begins, in decibels, in the range from -60 to 0. The default value is -15 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.fRatio">
            <summary>
            Compression ratio, in the range from 1 to 100. The default value is 3, which means 3:1 compression.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.fAttack">
            <summary>
            Time in ms before compression reaches its full value, in the range from 0.01 to 500. The default value is 20 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.fRelease">
            <summary>
            Time (speed) in ms at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000. The default value is 200 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Gain">Output gain in dB of signal after compression, in the range from -60 to 60.</param>
            <param name="Threshold">Point in dB at which compression begins, in decibels, in the range from -60 to 0.</param>
            <param name="Ratio">Compression ratio, in the range from 1 to 100.</param>
            <param name="Attack">Time in ms before compression reaches its full value, in the range from 0.01 to 500.</param>
            <param name="Release">Speed in ms at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000.</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Calculate0dBGain">
            <summary>
            Calculates for the current threshold/ratio combination a gain value to roughly achieve a 0 dB peak line.
            </summary>
            <remarks>Sets fGain=(fThreshold/2)*(1/fRatio-1).</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_Soft2">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_Hard2">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2.Preset_HardCommercial">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Volume Envelope.
            </summary>
            <remarks>
            <para>Make sure that the first node is at position 0.0.</para>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final volume is a product of the channel attribute and the envelope.</para>
            </remarks>
            <example>
            Setting a volume envelope on a source channel:
            <code>
            int fx = Bass.BASS_ChannelSetFX(source, BASSFXType.BASS_FX_BFX_VOLUME_ENV, 0);
            BASS_BFX_VOLUME_ENV ve = new BASS_BFX_VOLUME_ENV(
                                            new BASS_BFX_ENV_NODE(0.0, 1f), 
                                            new BASS_BFX_ENV_NODE(5.0, 1f), 
                                            new BASS_BFX_ENV_NODE(7.0, 0.5f), 
                                            new BASS_BFX_ENV_NODE(12.0, 0.5f), 
                                            new BASS_BFX_ENV_NODE(14.0, 1f));
            // which is the same as:
            BASS_BFX_ENV_NODE[] en = new BASS_BFX_ENV_NODE[5];
            en[0].pos = 0.0;
            en[0].val = 1f;
            en[1].pos = 5.0;
            en[2].val = 1f;
            en[3].pos = 7.0;
            en[3].val = 0.5f;
            en[4].pos = 12.0;
            en[4].val = 0.5f;
            en[5].pos = 14.0;
            en[5].val = 1f;
            ve = new BASS_BFX_VOLUME_ENV(en);
            
            Bass.BASS_FXSetParameters(fx, ve);
            </code>
            <code lang="vbnet">
            Dim fx As Integer = Bass.BASS_ChannelSetFX(source, BASSFXType.BASS_FX_BFX_VOLUME_ENV, 0) 
            Dim ve As New BASS_BFX_VOLUME_ENV(
                              New BASS_BFX_ENV_NODE(0.0, 1F), 
                              New BASS_BFX_ENV_NODE(5.0, 1F), 
                              New BASS_BFX_ENV_NODE(7.0, 0.5F), 
                              New BASS_BFX_ENV_NODE(12.0, 0.5F), 
                              New BASS_BFX_ENV_NODE(14.0, 1F)) 
            ' which is the same as: 
            Dim en As BASS_BFX_ENV_NODE() = New BASS_BFX_ENV_NODE(4) {} 
            en(0).pos = 0.0 
            en(0).val = 1F 
            en(1).pos = 5.0 
            en(2).val = 1F 
            en(3).pos = 7.0 
            en(3).val = 0.5F 
            en(4).pos = 12.0 
            en(4).val = 0.5F 
            en(5).pos = 14.0 
            en(5).val = 1F 
            ve = New BASS_BFX_VOLUME_ENV(en) 
            
            Bass.BASS_FXSetParameters(fx, ve) 
            </code>
            Getting a volume envelope from a source channel:
            <code>
            BASS_BFX_VOLUME_ENV ve = new BASS_BFX_VOLUME_ENV();
            if (Bass.BASS_FXGetParameters(fx, ve))
            {
                foreach (BASS_BFX_ENV_NODE node in ve.pNodes)
                    Console.WriteLine(node);
            }
            </code>
            <code lang="vbnet">
            Dim ve As New BASS_BFX_VOLUME_ENV() 
            If Bass.BASS_FXGetParameters(fx, ve) Then 
                For Each node As BASS_BFX_ENV_NODE In ve.pNodes 
                        Console.WriteLine(node) 
                Next 
            End If 
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.lNodeCount">
            <summary>
            The number of nodes contained in the pNodes array.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.bFollow">
            <summary>
            Follow the source position (default is <see langword="true"/>)?
            </summary>
            <remarks>If set to <see langword="true"/>, position changes also change the position of the volume envelope.
            When it's <see langword="false"/>, the envelope position is never reset.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.pNodes">
            <summary>
            The array of envelope nodes (the first node must be at position 0.0).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.#ctor(System.Int32)">
            <summary>
            Constructor assigning the number of volume envelope nodes to use.
            </summary>
            <param name="nodeCount">The number of volume envelope nodes to use.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.#ctor(Un4seen.Bass.AddOn.Fx.BASS_BFX_ENV_NODE[])">
            <summary>
            Constructor assigning the volume envelope nodes to use.
            </summary>
            <param name="nodes">The array of volume nodes to use with this instance (the first node must be at position 0.0).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.Finalize">
            <summary>
            Default Finilizer.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV.Dispose">
            <summary>
            Implements the IDisposable interface.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ENV_NODE">
            <summary>
            Used within <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV"/> to define one volume envelope node.
            </summary>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final volume is a product of the channel attribute and the envelope.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ENV_NODE.pos">
            <summary>
            The postion of the node in seconds.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ENV_NODE.val">
            <summary>
            The volume envelope value at the position (0.0=silence, 1.0=max.).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ENV_NODE.#ctor(System.Double,System.Single)">
            <summary>
            Constructor to initialize the members.
            </summary>
            <param name="Pos">The postion of the node in seconds.</param>
            <param name="Val">The volume envelope value at the position (0.0=silence, 1.0=max.).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ENV_NODE.ToString">
            <summary>
            A description of the volume envelope node (position, value).
            </summary>
            <returns>A description of the volume envelope node (position, value).</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect BiQuad filter.
            </summary>
            <remarks>
            BiQuad filters are second-order recursive linear filters. 
            <para><b>BASS_BFX_BQF_LOWPASS:</b><br/>
            A low-pass filter is a filter that passes low-frequency signals but attenuates (reduces the amplitude of) signals with frequencies higher than the fCenter frequency. The actual amount of attenuation for each frequency varies from filter to filter. It is sometimes called a high-cut filter, or treble cut filter when used in audio applications. A low-pass filter is the opposite of a high-pass filter, and a band-pass filter is a combination of a low-pass and a high-pass.
            </para>
            <para><b>BASS_BFX_BQF_HIGHPASS:</b><br/>
            A high-pass filter is an LTI filter that passes high frequencies well but attenuates (i.e., reduces the amplitude of) frequencies lower than the fCenter frequency. The actual amount of attenuation for each frequency is a design parameter of the filter. It is sometimes called a low-cut filter; the terms bass-cut filter or rumble filter are also used in audio applications.
            </para>
            <para><b>BASS_BFX_BQF_BANDPASS:</b><br/>
            A band-pass filter is a device that passes frequencies within a certain range and rejects (attenuates) frequencies outside that range. An example of an analogue electronic band-pass filter is an RLC circuit (a resistorinductorcapacitor circuit). These filters can also be created by combining a low-pass filter with a high-pass filter.
            </para>
            <para><b>BASS_BFX_BQF_NOTCH:</b><br/>
            In signal processing, a band-stop filter or band-rejection filter is a filter that passes most frequencies unaltered, but attenuates those in a specific range to very low levels. It is the opposite of a band-pass filter. A notch filter is a band-stop filter with a narrow stopband (high Q factor). Notch filters are used in live sound reproduction (Public Address systems, also known as PA systems) and in instrument amplifier (especially amplifiers or preamplifiers for acoustic instruments such as acoustic guitar, mandolin, bass instrument amplifier, etc.) to reduce or prevent feedback, while having little noticeable effect on the rest of the frequency spectrum. Other names include 'band limit filter', 'T-notch filter', 'band-elimination filter', and 'band-reject filter'.
            </para>
            <para><b>BASS_BFX_BQF_ALLPASS:</b><br/>
            An all-pass filter is a signal processing filter that passes all frequencies equally, but changes the phase relationship between various frequencies. It does this by varying its propagation delay with frequency. Generally, the filter is described by the frequency at which the phase shift crosses 90 (i.e., when the input and output signals go into quadrature  when there is a quarter wavelength of delay between them).
            </para>
            <para><b>BASS_BFX_BQF_PEAKINGEQ:</b><br/>
            A peaking equalizer raises or lowers a range of frequencies around a central point in a bell shape. A peaking equalizer with controls to adjust the level (fGain), fBandwidth (fQ) and center frequency (Hz) is called a parametric equalizer.
            Peaking Equalizer in BASS_FX can be achieved directly and efficiently by <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/>.
            </para>
            <para><b>BASS_BFX_BQF_ALLPASS:</b><br/>
            An all-pass filter is a signal processing filter that passes all frequencies equally, but changes the phase relationship between various frequencies. It does this by varying its propagation delay with frequency. Generally, the filter is described by the frequency at which the phase shift crosses 90 (i.e., when the input and output signals go into quadrature  when there is a quarter wavelength of delay between them).
            </para>
            <para><b>BASS_BFX_BQF_LOWSHELF:</b><br/>
            A low-shelf filter passes all frequencies, but increasing or reducing frequencies below the fCenter frequency by specified amount.
            </para>
            <para><b>BASS_BFX_BQF_HIGHSHELF:</b><br/>
            A high-shelf filter passes all frequencies, but increasing or reducing frequencies above the fCenter frequency by specified amount.
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.lFilter">
            <summary>
            Defines which BiQuad filter should be used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.fCenter">
            <summary>
            Cut-off frequency (Center in PEAKINGEQ and Shelving filters) in Hz (1...info.freq/2). Default = 200Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.fGain">
            <summary>
            Gain in dB (-15...0...+15). Default 0dB (used only for PEAKINGEQ and Shelving filters).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.fBandwidth">
            <summary>
            Bandwidth in octaves (0.1...4...n), Q is not in use (fBandwidth has priority over fQ). Default = 1 (0=not in use).
            <para>The bandwidth in octaves (between -3 dB frequencies for for BANDPASS and NOTCH or between midpoint (dBgain/2) gain frequencies for PEAKINGEQ).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.fQ">
            <summary>
            The EE kinda definition (linear), if fBandwidth is not in use (0.1...1). Default = 0.0 (0=not in use).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.fS">
            <summary>
            A shelf slope parameter (linear, used only with Shelving filters) (0.1...1). Default = 0.0.
            <para>When fS=1, the shelf slope is as steep as you can get it and remain monotonically increasing or decreasing gain with frequency.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF.#ctor(Un4seen.Bass.AddOn.Fx.BASSBFXBQF,System.Single,System.Single,System.Single,System.Single,System.Single,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="filter">The filter to use (one of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSBFXBQF"/>).</param>
            <param name="center">Cut-off frequency (Center in PEAKINGEQ and Shelving filters) in Hz (1...info.freq/2).</param>
            <param name="gain">Gain in dB (-15...0...+15). Default 0dB (used only for PEAKINGEQ and Shelving filters).</param>
            <param name="bandwidth">Bandwidth in octaves (0.1...4...n), Q is not in use (fBandwidth has priority over fQ) (0=not in use).</param>
            <param name="q">EE kinda definition of Q (0.1...1...n), if bandwidth is not in use (0=not in use).</param>
            <param name="s">A shelf slope parameter (linear, used only with Shelving filters) (0...1...n).</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Echo 4.
            </summary>
            <remarks>
            <para>This is an echo effect that replays what you have played one or more times after a period of time. It's something like the echoes you might hear shouting against a canyon wall. For reverb effect enable feedback.</para>
            <para>The fDryMix is the volume of input signal and the fWetMix is the volume of delayed signal. The fDelay is the delay time in sec. The fFeedback sets how much delay is feed back to the input (for repeating delays). If bStereo is enabled and a stream has an even number of channels then, each even channels will be echoed to each other.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.fDryMix">
            <summary>
            Dry (unaffected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.fWetMix">
            <summary>
            Wet (affected) signal mix (-2...+2). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.fFeedback">
            <summary>
            Output signal to feed back into input (-1...+1). Default = 0 (disabled).
            </summary>
            <remarks>Used for reverb effects.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.fDelay">
            <summary>
            Delay in seconds (0&lt;...n). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.bStereo">
            <summary>
            Echo adjoining channels to each other? Default is disabled.
            </summary>
            <remarks>Only allowed with even number of channels!
            <para>If enabled and a stream has an even number of channels then, each even channels will be echoed to each other.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="Feedback">Output signal to feed back into input (-1...+1).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.#ctor(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="Feedback">Output signal to feed back into input (-1...+1).</param>
            <param name="Stereo">Even channels are echoed to each other if enabled.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.#ctor(System.Single,System.Single,System.Single,System.Single,System.Boolean,Un4seen.Bass.AddOn.Fx.BASSFXChan)">
            <summary>
            Constructor already setting the members
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (-2..+2)</param>
            <param name="WetMix">Wet (affected) signal mix (-2..+2)</param>
            <param name="Delay">Delay in seconds (0&lt;..6)</param>
            <param name="Feedback">Output signal to feed back into input (-1...+1).</param>
            <param name="Stereo">Even channels are echoed to each other if enabled.</param>
            <param name="chans">The channel control flag defining on which channels the effect should be applied to (a combinbation of <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.Preset_SmallEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.Preset_DoubleKick">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4.Preset_LongEcho">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Pitch Shift using FFT.
            </summary>
            <remarks>
            <para>This effect uses FFT for its pitch shifting while maintaining duration.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.fPitchShift">
            <summary>
            A factor value which is between 0.5 (one octave down) and 2 (one octave up) (1 won't change the pitch, default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.fSemitones">
            <summary>
            Semitones (0 won't change the pitch). Default = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.lFFTsize">
            <summary>
            Defines the FFT frame size used for the processing. Typical values are 1024, 2048 (default) and 4096, max is 8192.
            </summary>
            <remarks>It may be any value up to 8192 but it MUST be a power of 2.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.lOsamp">
            <summary>
            Is the STFT oversampling factor which also determines the overlap between adjacent STFT frames. Default = 8.
            </summary>
            <remarks>It should at least be 4 for moderate scaling ratios. A value of 32 is recommended for best quality (better quality = higher CPU usage).</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT.#ctor(System.Single,System.Single,System.Int64,System.Int64)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="PitchShift">A factor value which is between 0.5 (one octave down) and 2 (one octave up).</param>
            <param name="Semitones">Semitones (0 won't change the pitch).</param>
            <param name="FFTsize">Defines the FFT frame size used for the processing (1024, 2048, 4096 or 8192).</param>
            <param name="Osamp">Is the STFT oversampling factor which also determines the overlap between adjacent STFT frames (4...64).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of the DSP effect Reverb.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.fDryMix">
            <summary>
            Dry (unaffected) signal mix (0.0...1.0, def. 0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.fWetMix">
            <summary>
            Wet (affected) signal mix (0.0...3.0, def. 1.0).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.fRoomSize">
            <summary>
            Room size (0.0...1.0, def. 0.5).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.fDamp">
            <summary>
            Damping factor (0.0...1.0, def. 0.5).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.fWidth">
            <summary>
            Stereo width (0.0...1.0, def. 1.0).
            </summary>
            <remarks>It should at least be 4 for moderate scaling ratios. A value of 32 is recommended for best quality (better quality = higher CPU usage).</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.lMode">
            <summary>
            Mode: 0=no freeze or 1=freeze, def. 0 (no freeze).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.lChannel">
            <summary>
            A <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXChan"/> flag to define on which channels to apply the effect.
            <para>Default: -1 (BASS_BFX_CHANALL) - all channels.</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="DryMix">Dry (unaffected) signal mix (0.0...1.0, def. 0).</param>
            <param name="WetMix">Wet (affected) signal mix (0.0...3.0, def. 1.0).</param>
            <param name="RoomSize">Room size (0.0...1.0, def. 0.5).</param>
            <param name="Damp">Damping factor (0.0...1.0, def. 0.5).</param>
            <param name="Width">Stereo width (0.0...1.0, def. 1.0).</param>
            <param name="Mode">Mode: 0=no freeze or 1=freeze, def. 0 (no freeze).</param>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC">
            <summary>
            User defined callback function, to get the bpm detection process in percents.
            </summary>
            <param name="channel">Channel that the <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)"/> applies to.</param>
            <param name="percent">The progress of the process in percent (0%..100%).</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BPMPROC">
            <summary>
            User defined callback function, to auto get the BPM after each period of time in seconds.
            </summary>
            <param name="handle">Handle that the <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> applies to.</param>
            <param name="bpm">The new original bpm value.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Fx.BPMBEATPROC">
            <summary>
            User defined callback function, to get the Beat position in seconds.
            </summary>
            <param name="handle">Handle that the <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> has applied to.</param>
            <param name="beatpos">The exact beat position in seconds.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatCallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_BeatDecodeGet(System.Int32,System.Double,System.Double,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMBEATPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Hls.BassHls">
            <summary>
            BASS.NET API wrapper for BASSHLS.DLL
            <para>Requires: basshls.dll - HTTP Live Streaming Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSHLS is an extension to the BASS audio library, enabling the playing of HLS (HTTP Live Streaming) streams.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a local HLS playlist.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.
            <para>This is a local file version of the <see cref="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateURL(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> function. 
            Although the HLS playlist can be a local file, the media segments in the playlist must be URLs.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a local HLS playlist.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.
            <para>This is a local file version of the <see cref="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateURL(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> function. 
            Although the HLS playlist can be a local file, the media segments in the playlist must be URLs.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateURLAscii(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateURLUnicode(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Hls.BassHls.BASS_HLS_StreamCreateURL(System.String,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from an HLS playlist on the internet, optionally receiving the downloaded data in a callback. 
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.
            </param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.
            <para>HLS streams consist of a media playlist and segments. The media segments usually contain AAC audio data, but MP3 or AC3 are also possible. 
            AAC support is available as standard with BASS via OS codecs on some platforms, but the BASS_AAC add-on can otherwise be used to provide that support; 
            BASSHLS can make use of any add-on that has been loaded via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>. The data will usually be in an MPEG-TS container, but it can also be plain audio data, possibly with ID3v2 tags.</para>
            <para>As well as possibly ID3v2 tags, the current segment's EXTINF tag in the media playlist is available from BASS_ChannelGetTags with the BASS_TAG_HLS_EXTINF tag type. 
            If present, the ID3v2 tags can/will change with each segment. A sync can be set to be informed of when a new segment starts downloading, which could be used to refresh the tags. 
            The current segment's sequence number is available from <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> with BASS_FILEPOS_HLS_SEGMENT.</para>
            <para>A DOWNLOADPROC callback function can be used to receive the downloaded data from all of the segments. When the data is in an MPEG-TS container, the audio data will be extracted from the container before being passed to the callback function.</para>
            <para>Master playlists are supported, but BASSHLS will simply play the first entry from them. If you would like to play a different entry (eg. perhaps for a different bitrate), you could download the master playlist separately and then extract the wanted entry's URL from it and pass that to BASSHLS.</para>
            <para>The BASS_STREAM_BLOCK flag is applied automatically to HLS streams, which means only a small amount of the downloaded data will be kept in memory. Be careful not to stop/pause the stream for too long, otherwise the connection may timeout due to there being no activity.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BassMidi">
            <summary>
            BASS .NET API wrapper for BASSMIDI.
            <para>Requires: bassmidi.dll - BASSMIDI Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSMIDI is an extension to the BASS audio library, enabling the playing of MIDI files (Musical Instrument Digital Interface), using SF2 soundfonts to provide the sounds.</para>
            <para>The MIDI format is used in very much the same way as any of the built-in BASS	stream formats - simply call the MIDI stream creation function instead of the BASS built-in functions. 
            The BASS plugin system (see BASS_PluginLoad) is also supported.</para>
            <para>SF2 soundfonts are used to provide the sounds. There are several soundfonts available on the internet. 
            One example (Chorium) is available from the BASS webpage. On Win32, the Creative 4MB/2MB soundfont (CT4MGM.SF2/CT2MGM.SF2) will be used by default when it's present (in the Windows system directory).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream to render real-time MIDI events.
            </summary>
            <param name="channels">The number of MIDI channels: 1 (min) - 128 (max).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function creates a stream solely for real-time MIDI events. As it's not based on any file, the stream has no predetermined length and is never-ending. Seeking isn't possible, but it is possible to reset everything, including playback buffer, 
            by calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (restart = <see langword="true"/>) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (pos = 0).</para>
            <para>MIDI events are applied using the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> function. If the stream is being played (it's not a decoding channel), then there will be some delay in the effect of the events being heard. 
            This latency can be reduced by making use of the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> and <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/> options.</para>
            <para>If a stream has 16 MIDI channels, then channel 10 defaults to percussion/drums and the rest melodic, otherwise they are all melodic. That can be changed using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> and the MIDI_EVENT_DRUMS event.</para>
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para>To play a MIDI file, use <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)"/>.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="channels"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI sound file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOCROP</term><description>Do not remove empty space (containing no events) from the end of the file.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSMIDI supports format 0/1/2 MIDI files. In the case of format 2, the tracks are rendered/played one after another. RIFF MIDI (RMID) files are also supported. The General MIDI standard events are supported, as are several Roland GS and Yamaha XG NRPN and SysEx events. A full list of supported MIDI events can be found in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> documentation.
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>. 
            By default, with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_AUTOFONT</see> config option enabled, BASSMIDI will also look for a soundfont of the same name as the MIDI file. For example, if the MIDI is "afile.mid", then it will look for a "afile.sf2" (or "afile.mid.sf2"). Note that a MIDI stream can have multiple soundfonts stacked, each providing different presets, for example.</para>
            <para>As well as the standard byte/time-based positioning, MIDI tick-based positioning is also supported. The BASS_POS_MIDI_TICK "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to deal in ticks.</para>
            <para>Marker, cue and lyric events can be retrieved via the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> function. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">Syncs</see> (BASS_SYNC_MIDI_MARKER, BASS_SYNC_MIDI_CUE, BASS_SYNC_MIDI_LYRIC, BASS_SYNC_MIDI_EVENT, BASS_SYNC_MIDI_TICK) 
            can also be used to be notified of their occurrence.</para>
            <para>The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/> + track tag, where track=0 is the first track. A pointer to a series of null-terminated strings is given, the final string ending with a double null. 
            The first text in the first track is generally the title of the MIDI file. RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.
            In addition you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/> method to retrieve the track text.</para>
            <para>Unlike with most stream formats, the entire MIDI file is loaded to memory. This means the file can be deleted or moved after calling this function.</para>
            <para>As well as providing dedicated stream creation functions, BASSMIDI supports the BASS plugin system, adding MIDI file support to the standard BASS stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This is enabled using the BASS_PluginLoad function.</para>
            <para>MIDI streams created via the plugin system use the sample rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="file"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI memory IntPtr.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOCROP</term><description>Do not remove empty space (containing no events) from the end of the file.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSMIDI supports format 0/1/2 MIDI files. In the case of format 2, the tracks are rendered/played one after another. RIFF MIDI (RMID) files are also supported. The General MIDI standard events are supported, as are several Roland GS and Yamaha XG NRPN and SysEx events. A full list of supported MIDI events can be found in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> documentation.
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>. 
            By default, with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_AUTOFONT</see> config option enabled, BASSMIDI will also look for a soundfont of the same name as the MIDI file. For example, if the MIDI is "afile.mid", then it will look for a "afile.sf2" (or "afile.mid.sf2"). Note that a MIDI stream can have multiple soundfonts stacked, each providing different presets, for example.</para>
            <para>As well as the standard byte/time-based positioning, MIDI tick-based positioning is also supported. The BASS_POS_MIDI_TICK "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to deal in ticks.</para>
            <para>Marker, cue and lyric events can be retrieved via the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> function. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">Syncs</see> (BASS_SYNC_MIDI_MARKER, BASS_SYNC_MIDI_CUE, BASS_SYNC_MIDI_LYRIC, BASS_SYNC_MIDI_EVENT, BASS_SYNC_MIDI_TICK) 
            can also be used to be notified of their occurrence.</para>
            <para>The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/> + track tag, where track=0 is the first track. A pointer to a series of null-terminated strings is given, the final string ending with a double null. 
            The first text in the first track is generally the title of the MIDI file. RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.
            In addition you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/> method to retrieve the track text.</para>
            <para>Unlike with most stream formats, the entire MIDI file is loaded to memory. This means the file can be deleted or moved after calling this function.</para>
            <para>As well as providing dedicated stream creation functions, BASSMIDI supports the BASS plugin system, adding MIDI file support to the standard BASS stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This is enabled using the BASS_PluginLoad function.</para>
            <para>MIDI streams created via the plugin system use the sample rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="memory"/> is not a valid pointer to a memory location.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileMemory(System.Boolean,System.Byte[],System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.Byte[],System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI memory byte[].
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="memory">A managed memory location as a byte[].</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOCROP</term><description>Do not remove empty space (containing no events) from the end of the file.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>BASSMIDI supports format 0/1/2 MIDI files. In the case of format 2, the tracks are rendered/played one after another. RIFF MIDI (RMID) files are also supported. The General MIDI standard events are supported, as are several Roland GS and Yamaha XG NRPN and SysEx events. A full list of supported MIDI events can be found in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> documentation.
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overriden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>. 
            By default, with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_AUTOFONT</see> config option enabled, BASSMIDI will also look for a soundfont of the same name as the MIDI file. For example, if the MIDI is "afile.mid", then it will look for a "afile.sf2" (or "afile.mid.sf2"). Note that a MIDI stream can have multiple soundfonts stacked, each providing different presets, for example.</para>
            <para>As well as the standard byte/time-based positioning, MIDI tick-based positioning is also supported. The BASS_POS_MIDI_TICK "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to deal in ticks.</para>
            <para>Marker, cue and lyric events can be retrieved via the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> function. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">Syncs</see> (BASS_SYNC_MIDI_MARKER, BASS_SYNC_MIDI_CUE, BASS_SYNC_MIDI_LYRIC, BASS_SYNC_MIDI_EVENT, BASS_SYNC_MIDI_TICK) 
            can also be used to be notified of their occurrence.</para>
            <para>The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/> + track tag, where track=0 is the first track. A pointer to a series of null-terminated strings is given, the final string ending with a double null. 
            The first text in the first track is generally the title of the MIDI file. RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.
            In addition you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/> method to retrieve the track text.</para>
            <para>Unlike with most stream formats, the entire MIDI file is loaded to memory. This means the file can be deleted or moved after calling this function.</para>
            <para>As well as providing dedicated stream creation functions, BASSMIDI supports the BASS plugin system, adding MIDI file support to the standard BASS stream creation functions - <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. 
            This is enabled using the BASS_PluginLoad function.</para>
            <para>MIDI streams created via the plugin system use the sample rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="memory"/> is not a valid memory location.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,System.Int32)">
            <summary>
            Creates a sample stream from a MIDI file via a user callback function.
            </summary>
            <param name="system">File system to use, which must be <see cref="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_NOBUFFER"/>, as the entire MIDI file is preloaded.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOCROP</term><description>Do not remove empty space (containing no events) from the end of the file.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.
            <para>As there is no file associated with a user file stream, it's not possible for BASSMIDI to look for a soundfont with the same name as the MIDI file. If there is a matching soundfont, it can be applied using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="system"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <param name="freq"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr,System.Int32)">
            <summary>
            Creates a sample stream from an MIDI file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_STATUS</term><description>Pass status info (HTTP/ICY tags) from the server to the <see cref="T:Un4seen.Bass.DOWNLOADPROC"/> callback during connection. This can be useful to determine the reason for a failure.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOCROP</term><description>Do not remove empty space (containing no events) from the end of the file.</description></item>
            <item><term>BASS_MIDI_DECAYEND</term><description>Let the ending decay naturally (including reverb), instead of stopping abruptly at the end of the file. This doesn't apply when looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="freq">Sample rate (in Hz) to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.
            <para>The entire MIDI file is preloaded, so the standard BASS_STREAM_BLOCK and BASS_STREAM_RESTRATE flags have no effect here.</para>
            <para>Regardless of the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_AUTOFONT"/> setting, a matching soundfont is not looked for when opening a MIDI file from a URL.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_NONET</term><description>No internet connection could be opened. Can be caused by a bad <see cref="T:Un4seen.Bass.BASSConfig">proxy setting</see>.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_NET_TIMEOUT</see> config option.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateEvents(Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Creates a sample stream from a sequence of MIDI events.
            </summary>
            <param name="events">The array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/>s containing the event sequence to play (the array should be terminated with a MIDI_EVENT_END event).</param>
            <param name="ppqn">The number of pulses per quarter note (or ticks per beat) value of the MIDI stream to create.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_MIDI_NOFX</term><description>Disable reverb and chorus processing, saving some CPU time. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOSYSRESET</term><description>Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_NOTEOFF1</term><description>Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_MIDI_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MIDI at (0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call; 1 = the device's current output rate (or the BASS_Init rate if that is not available).</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function creates a 16 channel MIDI stream to play a predefined sequence of MIDI events. Any of the standard MIDI events listed in the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> section can be used, but the MIDI_EVENT_MIXLEVEL, MIDI_EVENT_TRANSPOSE, and MIDI_EVENT_SYSTEMEX events are not available and will be ignored. The sequence should end with a MIDI_EVENT_END event. Multiple tracks are possible via the MIDI_EVENT_END_TRACK event, which signals the end of a track; the next event will be in a new track. Any MIDI_EVENT_TEMPO events should be in the first track.</para>
            <para>The event sequence is copied, so the events array does not need to persist beyond the function call.</para>
            <para>Soundfonts provide the sounds that are used to render a MIDI stream. A default soundfont configuration is applied initially to the new MIDI stream, which can subsequently be overridden using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored. On Android and iOS, sinc interpolation requires a NEON-supporting CPU; the BASS_MIDI_SINCINTER flag will otherwise be ignored. Sinc interpolation is not available on Windows CE.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_NONET</term><description>No internet connection could be opened. Can be caused by a bad <see cref="T:Un4seen.Bass.BASSConfig">proxy setting</see>.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="events"/> are not valid.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_NET_TIMEOUT</see> config option.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMarkInternal(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.MIDI_MARK_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="type"></param>
            <param name="index"></param>
            <param name="mark"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the marker from.</param>
            <param name="type">The type of marker to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker"/>):
            <list type="table">
            <item><term>BASS_MIDI_MARK_COPY</term><description>Copyright notice events (MIDI meta event 2).</description></item>
            <item><term>BASS_MIDI_MARK_CUE</term><description>Cue events (MIDI meta event 07).</description></item>
            <item><term>BASS_MIDI_MARK_INST</term><description>Instrument name events (MIDI meta event 4).</description></item>
            <item><term>BASS_MIDI_MARK_KEYSIG</term><description>Key signature events (MIDI meta event 89). The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).</description></item>
            <item><term>BASS_MIDI_MARK_LYRIC</term><description>Lyric events (MIDI meta event 05).</description></item>
            <item><term>BASS_MIDI_MARK_MARKER</term><description>Marker events (MIDI meta event 06).</description></item>
            <item><term>BASS_MIDI_MARK_TEXT</term><description>Text events (MIDI meta event 01).</description></item>
            <item><term>BASS_MIDI_MARK_TIMESIG</term><description>Time signature events (MIDI meta event 88). The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note.</description></item>
            <item><term>BASS_MIDI_MARK_TRACK</term><description>Track name events (MIDI meta event 3).</description></item>
            <item><term>BASS_MIDI_MARK_TICK</term><description>FLAG: get position in ticks instead of bytes.</description></item>
            </list>
            </param>
            <param name="index">The marker to retrieve... 0 = the first.</param>
            <param name="mark">Instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK"/> class to receive the marker details.</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The markers are ordered chronologically.
            <para><see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx Syncs</see> can be used to be informed of when markers are encountered during playback.</para>
            <para>If a lyric marker text begins with a '/' (slash) character, that means a new line should be started. If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="index"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List a MIDI stream's markers:
            <code>
            BASS_MIDI_MARK mark = new BASS_MIDI_MARK();
            int idx = 0;
            while (BassMidi.BASS_MIDI_StreamGetMark(handle, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx, mark))
            {
              idx++;
              Console.WriteLine("{0}.Marker: {1}", idx, mark);
            }
            </code>
            <code lang="vbnet">
            Dim mark As New BASS_MIDI_MARK()
            Dim idx As Integer = 0
            While BassMidi.BASS_MIDI_StreamGetMark(handle, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx, mark)
              idx += 1
              Console.WriteLine("{0}.Marker: {1}", idx, mark)
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32)">
            <summary>
            Retrieves a marker from a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the marker from.</param>
            <param name="type">The type of marker to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker"/>):
            <list type="table">
            <item><term>BASS_MIDI_MARK_COPY</term><description>Copyright notice events (MIDI meta event 2).</description></item>
            <item><term>BASS_MIDI_MARK_CUE</term><description>Cue events (MIDI meta event 07).</description></item>
            <item><term>BASS_MIDI_MARK_INST</term><description>Instrument name events (MIDI meta event 4).</description></item>
            <item><term>BASS_MIDI_MARK_KEYSIG</term><description>Key signature events (MIDI meta event 89). The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).</description></item>
            <item><term>BASS_MIDI_MARK_LYRIC</term><description>Lyric events (MIDI meta event 05).</description></item>
            <item><term>BASS_MIDI_MARK_MARKER</term><description>Marker events (MIDI meta event 06).</description></item>
            <item><term>BASS_MIDI_MARK_TEXT</term><description>Text events (MIDI meta event 01).</description></item>
            <item><term>BASS_MIDI_MARK_TIMESIG</term><description>Time signature events (MIDI meta event 88). The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note.</description></item>
            <item><term>BASS_MIDI_MARK_TRACK</term><description>Track name events (MIDI meta event 3).</description></item>
            <item><term>BASS_MIDI_MARK_TICK</term><description>FLAG: get position in ticks instead of bytes.</description></item>
            </list>
            </param>
            <param name="index">The marker to retrieve... 0 = the first.</param>
            <returns>On success, an instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The markers are ordered chronologically.
            <para><see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx Syncs</see> can be used to be informed of when markers are encountered during playback.</para>
            <para>If a lyric marker text begins with a '/' (slash) character, that means a new line should be started. If the text begins with a '\' (backslash) character, the display should be cleared. 
            Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> in not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="index"/> in not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List a MIDI stream's markers:
            <code>
            int idx = 0;
            BASS_MIDI_MARK mark;
            while ((mark = BassMidi.BASS_MIDI_StreamGetMark(handle, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx)) != null)
            {
              idx++;
              Console.WriteLine("{0}.Marker: {1}", idx, mark);
            }
            </code>
            <code lang="vbnet">
            Dim idx As Integer = 0
            Dim mark As BASS_MIDI_MARK
            While True
              mark = BassMidi.BASS_MIDI_StreamGetMark(stream, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, idx)
              If mark Is Nothing Then
                Exit While
              End If
              idx += 1
              Console.WriteLine("{0}.Marker: {1}", idx, mark)
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMarksInternal(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,Un4seen.Bass.AddOn.Midi.MIDI_MARK_INTERNAL[])">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="track"></param>
            <param name="type"></param>
            <param name="marks"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMarks(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker)">
            <summary>
            Retrieves the markers in a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the markers from.</param>
            <param name="track">The track to get the markers from... 0 = 1st track, -1 = all tracks.</param>
            <param name="type">The type of marker to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker"/>):
            <list type="table">
            <item><term>BASS_MIDI_MARK_COPY</term><description>Copyright notice events (MIDI meta event 2).</description></item>
            <item><term>BASS_MIDI_MARK_CUE</term><description>Cue events (MIDI meta event 07).</description></item>
            <item><term>BASS_MIDI_MARK_INST</term><description>Instrument name events (MIDI meta event 4).</description></item>
            <item><term>BASS_MIDI_MARK_KEYSIG</term><description>Key signature events (MIDI meta event 89). The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).</description></item>
            <item><term>BASS_MIDI_MARK_LYRIC</term><description>Lyric events (MIDI meta event 05).</description></item>
            <item><term>BASS_MIDI_MARK_MARKER</term><description>Marker events (MIDI meta event 06).</description></item>
            <item><term>BASS_MIDI_MARK_TEXT</term><description>Text events (MIDI meta event 01).</description></item>
            <item><term>BASS_MIDI_MARK_TIMESIG</term><description>Time signature events (MIDI meta event 88). The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note.</description></item>
            <item><term>BASS_MIDI_MARK_TRACK</term><description>Track name events (MIDI meta event 3).</description></item>
            <item><term>BASS_MIDI_MARK_TICK</term><description>FLAG: get position in ticks instead of bytes.</description></item>
            </list>
            </param>
            <returns>On success, an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK"/> instances is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The markers are ordered chronologically, and by track number (lowest first) if multiple markers have the same position.</para>
            <para>SYNCs can be used to be informed of when markers are encountered during playback.</para>
            <para>If a lyric marker text begins with a / (slash) character, that means a new line should be started. If the text begins with a \ (backslash) character, the display should be cleared. Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="track"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMarksCount(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker)">
            <summary>
            Retrieves the number of markers in a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the markers from.</param>
            <param name="track">The track to get the markers from... 0 = 1st track, -1 = all tracks.</param>
            <param name="type">The type of marker to retrieve, one of the following (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker"/>):
            <list type="table">
            <item><term>BASS_MIDI_MARK_COPY</term><description>Copyright notice events (MIDI meta event 2).</description></item>
            <item><term>BASS_MIDI_MARK_CUE</term><description>Cue events (MIDI meta event 07).</description></item>
            <item><term>BASS_MIDI_MARK_INST</term><description>Instrument name events (MIDI meta event 4).</description></item>
            <item><term>BASS_MIDI_MARK_KEYSIG</term><description>Key signature events (MIDI meta event 89). The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).</description></item>
            <item><term>BASS_MIDI_MARK_LYRIC</term><description>Lyric events (MIDI meta event 05).</description></item>
            <item><term>BASS_MIDI_MARK_MARKER</term><description>Marker events (MIDI meta event 06).</description></item>
            <item><term>BASS_MIDI_MARK_TEXT</term><description>Text events (MIDI meta event 01).</description></item>
            <item><term>BASS_MIDI_MARK_TIMESIG</term><description>Time signature events (MIDI meta event 88). The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note.</description></item>
            <item><term>BASS_MIDI_MARK_TRACK</term><description>Track name events (MIDI meta event 3).</description></item>
            <item><term>BASS_MIDI_MARK_TICK</term><description>FLAG: get position in ticks instead of bytes.</description></item>
            </list>
            </param>
            <returns>On success, the number of markers is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="track"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to apply the event to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="chan">The MIDI channel to apply the event to... 0 = channel 1.</param>
            <param name="eventtype">The event to apply (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="param">The event parameter (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>Except for the "non-MIDI" events, events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. That can be avoided by using additional channels, allocated via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute.</para>
            <para>Event syncs (BASS_SYNC_MIDI_xxx, see <see cref="T:Un4seen.Bass.BASSSync"/>) are not triggered by this function. If sync triggering is wanted, <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/> can be used instead.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>If multiple events need to be applied at the same time, <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/> can be used instead of this function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One of the other parameters is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play the middle C note (key 60) with a velocity of 100, on channel 1 for 2 seconds:
            <code>
            // press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100);
            // wait 2 seconds
            Thread.Sleep(2000);
            // release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60);
            </code>
            <code lang="vbnet">
            ' press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100)
            ' wait 2 seconds
            Thread.Sleep(2000)
            ' release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Byte,System.Byte)">
            <summary>
            Applies an event to a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to apply the event to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="chan">The MIDI channel to apply the event to... 0 = channel 1.</param>
            <param name="eventtype">The event to apply (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="loParam">The event parameter (LOBYTE), (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <param name="hiParam">The event parameter (HIBYTE), (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Apart from the "global" events, all events apply only to the specified MIDI channel.</para>
            <para>Except for the "non-MIDI" events, events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. That can be avoided by using additional channels, allocated via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute.</para>
            <para>Event syncs (BASS_SYNC_MIDI_xxx, see <see cref="T:Un4seen.Bass.BASSSync"/>) are not triggered by this function. If sync triggering is wanted, <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/> can be used instead.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>If multiple events need to be applied at the same time, <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/> can be used instead of this function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One of the other parameters is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play the middle C note (key 60) with a velocity of 100, on channel 1 for 2 seconds:
            <code>
            // press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100);
            // wait 2 seconds
            Thread.Sleep(2000);
            // release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60);
            </code>
            <code lang="vbnet">
            ' press the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60, 100)
            ' wait 2 seconds
            Thread.Sleep(2000)
            ' release the key
            BassMidi.BASS_MIDI_StreamEvent(handle, 0, BASSMIDIEvent.MIDI_EVENT_NOTE, 60)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[])">
            <summary>
            Applies any number of events to a MIDI stream (BASS_MIDI_EVENTS_STRUCT).
            </summary>
            <param name="handle">The MIDI stream to apply the events to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="flags">BASS_MIDI_EVENTS_STRUCT, with optional flags (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode"/>):
            <list type="table">
            <item><term>BASS_MIDI_EVENTS_RAW</term><description>Raw MIDI event data, as would be sent to a MIDI device. Running status is supported. To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where +1 = the 1st channel.</description></item>
            <item><term>BASS_MIDI_EVENTS_STRUCT</term><description>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures.</description></item>
            <item><term>BASS_MIDI_EVENTS_NORSTATUS</term><description>Flag: Disable running status, meaning each event must include a status byte. Only applicable with BASS_MIDI_EVENTS_RAW.</description></item>
            <item><term>BASS_MIDI_EVENTS_SYNC</term><description>Flag: Trigger <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx</see> syncs for the processed events (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>).</description></item>
            </list>
            </param>
            <param name="events">The event data (an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures).</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. That can be avoided by using additional channels, allocated via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="flags"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,System.Int32,System.Byte[])">
            <summary>
            Applies any number of events to a MIDI stream (BASS_MIDI_EVENTS_RAW).
            </summary>
            <param name="handle">The MIDI stream to apply the events to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="flags">BASS_MIDI_EVENTS_RAW, with optional flags (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode"/>):
            <list type="table">
            <item><term>BASS_MIDI_EVENTS_RAW</term><description>Raw MIDI event data, as would be sent to a MIDI device. Running status is supported. To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where +1 = the 1st channel.</description></item>
            <item><term>BASS_MIDI_EVENTS_STRUCT</term><description>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures.</description></item>
            <item><term>BASS_MIDI_EVENTS_NORSTATUS</term><description>Flag: Disable running status, meaning each event must include a status byte. Only applicable with BASS_MIDI_EVENTS_RAW.</description></item>
            <item><term>BASS_MIDI_EVENTS_SYNC</term><description>Flag: Trigger <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx</see> syncs for the processed events (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>).</description></item>
            </list>
            </param>
            <param name="chan">To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where 1 = the 1st channel - else leave to 0.</param>
            <param name="events">The event data (raw MIDI event data, as would be sent to a MIDI device).</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. That can be avoided by using additional channels, allocated via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="flags"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Applies any number of events to a MIDI stream (BASS_MIDI_EVENTS_RAW).
            </summary>
            <param name="handle">The MIDI stream to apply the events to (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="flags">BASS_MIDI_EVENTS_RAW, with optional flags (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode"/>):
            <list type="table">
            <item><term>BASS_MIDI_EVENTS_RAW</term><description>Raw MIDI event data, as would be sent to a MIDI device. Running status is supported. To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where +1 = the 1st channel.</description></item>
            <item><term>BASS_MIDI_EVENTS_STRUCT</term><description>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures.</description></item>
            <item><term>BASS_MIDI_EVENTS_NORSTATUS</term><description>Flag: Disable running status, meaning each event must include a status byte. Only applicable with BASS_MIDI_EVENTS_RAW.</description></item>
            <item><term>BASS_MIDI_EVENTS_SYNC</term><description>Flag: Trigger <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx</see> syncs for the processed events (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>).</description></item>
            </list>
            </param>
            <param name="chan">To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where 1 = the 1st channel - else leave to 0.</param>
            <param name="events">The pointer to the event data (e.g. as received in a <see cref="T:Un4seen.Bass.AddOn.Midi.MIDIINPROC"/>).</param>
            <param name="length">The number of bytes contained in the <paramref name="events"/>.</param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Events applied to a MIDI file stream can subsequently be overridden by events in the file itself, and will also be overridden when seeking or looping. That can be avoided by using additional channels, allocated via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute.</para>
            <para>If the MIDI stream is being played (it's not a decoding channel), then there will be some delay in the effect of the event being heard. 
            This latency can be reduced by making use of the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_UPDATEPERIOD</see> config options when creating the stream.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="flags"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)">
            <summary>
            Retrieves the current value of an event in a MIDI stream channel.
            </summary>
            <param name="handle">The MIDI stream to retrieve the event from (as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <param name="chan">The MIDI channel to get the event value from... 0 = channel 1.</param>
            <param name="eventtype">The event value to retrieve (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details on the available event types and their values).
            With the MIDI_EVENT_NOTE, MIDI_EVENT_KEYPRES, MIDI_EVENT_SCALETUNING and drum key (MIDI_EVENT_DRUM_CUTOFF/etc) events, the HIWORD - use MAKELONG(event,key) - can be used to specify which key/note to get the value from. Special MIDI_EVENT_NOTES and MIDI_EVENT_VOICES events are also available to check how many keys are pressed and how many voices are active, respectively.</param>
            <returns>The event parameter (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for details) if successful - else -1 (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            The MIDI_EVENT_NOTE event value will be 1 if the specified key is pressed and 0 if not. 
            The MIDI_EVENT_NOTES event can be used to check how many keys in total are pressed in the specified channel. 
            If a key is simultaneously pressed multiple times, it will still only be counted once. 
            <para>SYNCs can be used to be informed of when event values change.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One of the other parameters is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvents(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[])">
            <summary>
            Retrieves the events in a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream to get the events from.</param>
            <param name="track">The track to get the events from... 0 = 1st track.</param>
            <param name="filter">The type of event to retrieve (use MIDI_EVENT_NONE to retrieve all events). See <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for a list of possible event types.</param>
            <param name="events">The pointer to an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> to retrieve the events (<see langword="null"/> = get the number of events without getting the events themselves).</param>
            <returns>If successful, the number of events is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function should first be called with <paramref name="events"/> = <see langword="null"/> to get the number of events, before allocating an array of the required size and retrieving the events.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is for real-time events only, so does not have an event sequence.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="track"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Retrieve all events in the 1st track:
            <code>
            int eventCount = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 0, BASSMIDIEvent.MIDI_EVENT_NONE);
            BASS_MIDI_EVENT[] events = new BASS_MIDI_EVENT[eventCount];
            int count = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 0, BASSMIDIEvent.MIDI_EVENT_NONE, events);
            </code>
            <code lang="vbnet">
            Dim eventCount = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 0, BASSMIDIEvent.MIDI_EVENT_NONE)
            Dim events(eventCount) As BASS_MIDI_EVENT
            Dim count As Integer = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 0, BASSMIDIEvent.MIDI_EVENT_NONE, events)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvents(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,System.Int32)">
            <summary>
            Retrieves a portion of the events in a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to get the events from.</param>
            <param name="track">The track to get the events from... 0 = 1st track.</param>
            <param name="filter">The type of event to retrieve (use MIDI_EVENT_NONE to retrieve all events). See <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for a list of possible event types.</param>
            <param name="events">The pointer to an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> to retrieve the events (<see langword="null"/> = get the number of events without getting the events themselves).</param>
            <param name="start">The first event to retrieve.</param>
            <param name="count">The maximum number of events to retrieve.</param>
            <returns>If successful, the number of events is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function should first be called with <paramref name="events"/> = <see langword="null"/> to get the number of events, before allocating an array of the required size and retrieving the events.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is for real-time events only, so does not have an event sequence.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="track"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Retrieve the first 10 events in the 1st track:
            <code>
            BASS_MIDI_EVENT[] events = new BASS_MIDI_EVENT[10];
            int count = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 0, BASSMIDIEvent.MIDI_EVENT_NONE, events, 0, 10);
            </code>
            <code lang="vbnet">
            Dim events(10) As BASS_MIDI_EVENT
            Dim count As Integer = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 0, BASSMIDIEvent.MIDI_EVENT_NONE, events, 0, 10)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvents(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)">
            <summary>
            Retrieves the events in a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream to get the events from.</param>
            <param name="track">The track to get the events from... 0 = 1st track.</param>
            <param name="filter">The type of event to retrieve (use MIDI_EVENT_NONE to retrieve all events). See <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for a list of possible event types.</param>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> configuration entries if successfull - or <see langword="null"/> on error.</returns>
            <remarks>This overload will always return all present event objects.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is for real-time events only, so does not have an event sequence.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="track"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Retrieve all note events in the 2nd track:
            <code>
            BASS_MIDI_EVENT[] events = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 1, BASSMIDIEvent.MIDI_EVENT_NOTE);
            </code>
            <code lang="vbnet">
            Dim events As BASS_MIDI_EVENT() = BassMidi.BASS_MIDI_StreamGetEvents(_stream, 1, BASSMIDIEvent.MIDI_EVENT_NOTE)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEventsCount(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)">
            <summary>
            Retrieves the number of events in a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream to get the events from.</param>
            <param name="track">The track to get the events from... 0 = 1st track.</param>
            <param name="filter">The type of event to retrieve (use MIDI_EVENT_NONE to retrieve all events). See <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/> for a list of possible event types.</param>
            <returns>If successful, the number of events is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is for real-time events only, so does not have an event sequence.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="track"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="fonts">The pointer to an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> soundfonts to apply.</param>
            <param name="count">The number of elements in the fonts array.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Multiple soundfonts can be stacked, each providing different presets, for example.
            When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority. When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            When a preset is not available on a non-0 bank in any soundfont, BASSMIDI will try to fall back to bank 0; first the LSB and then the MSB if still unsuccessful.
            <para>Changing the default configuration only affects subsequently created MIDI streams. Existing streams that are using the previous default configuration will continue to use that previous configuration.</para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>Something in the <paramref name="fonts"/> array is invalid, check the soundfont handles.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // first initialize the fonts
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            int font2 = BassMidi.BASS_MIDI_FontInit("bfont.sf2");
            BASS_MIDI_FONT[] newfonts = { new BASS_MIDI_FONT(font1, -1, 0), new BASS_MIDI_FONT(font2, -1, 0) };
            // now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, newfonts.Length);
            </code>
            <code lang="vbnet">
            ' first initialize the fonts
            Dim font1 As Integer =  BassMidi.BASS_MIDI_FontInit("afont.sf2") 
            Dim font2 As Integer =  BassMidi.BASS_MIDI_FontInit("bfont.sf2") 
            Dim newFonts() As BASS_MIDI_FONT = {New BASS_MIDI_FONT(font1, -1, 0), New BASS_MIDI_FONT(font2, -1, 0)}
            ' now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newFonts, newFonts.Length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFontsEx(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX[],System.Int32)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="fonts"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX[],System.Int32)">
            <summary>
            Applies a soundfont configuration to a MIDI stream, or sets the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to apply the soundfonts to... 0 = set default soundfont configuration.</param>
            <param name="fonts">The pointer to an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX"/> soundfonts to apply.</param>
            <param name="count">The number of elements in the fonts array.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Multiple soundfonts can be stacked, each providing different presets, for example.
            When a preset is present in multiple soundfonts, the earlier soundfont in the array has priority. When a soundfont matching the MIDI file is loaded, that remains loaded when calling this function, and has priority over all other soundfonts.
            When a preset is not available on a non-0 bank in any soundfont, BASSMIDI will try to fall back to bank 0; first the LSB and then the MSB if still unsuccessful.
            <para>Changing the default configuration only affects subsequently created MIDI streams. Existing streams that are using the previous default configuration will continue to use that previous configuration.</para>
            <para>On Windows, the default default configuration will be to use the Creative 4MB (CT4MGM.SF2) or 2MB (CT2MGM.SF2) soundfont when present in the Windows system directory.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>Something in the <paramref name="fonts"/> array is invalid, check the soundfont handles.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set a MIDI stream to use preset 20 from one soundfont for program 10 on bank 0, and all available presets from another soundfont:
            <code>
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            int font2 = BassMidi.BASS_MIDI_FontInit("bfont.sf2");
            BASS_MIDI_FONTEX[] fonts = new BASS_MIDI_FONTEX[2];
            fonts[0].font = font1;
            fonts[0].spreset = 10; // soundfont preset 20
            fonts[0].sbank = 0; // soundfont bank 0
            fonts[0].dpreset = 10; // destination preset 10
            fonts[0].dbank = 0; // destination bank 0
            fonts[0].dbanklsb = 0; // destination bank LSB 0
            fonts[1].font = font2;
            fonts[1].spreset = -1; // all presets
            fonts[1].sbank = -1; // all banks
            fonts[1].dpreset = -1; // all presets
            fonts[1].dbank = 0; // default banks
            fonts[1].dbanklsb = 0; // destination bank LSB 0
            BASS_MIDI_StreamSetFonts(handle, fonts, 2); // apply it to the stream
            </code>
            <code lang="vbnet">
            ' first initialize the fonts
            Dim font1 As Integer =  BassMidi.BASS_MIDI_FontInit("afont.sf2") 
            Dim font2 As Integer =  BassMidi.BASS_MIDI_FontInit("bfont.sf2") 
            Dim fonts As BASS_MIDI_FONTEX() = New BASS_MIDI_FONTEX(1) {}
            fonts(0).font = font1
            fonts(0).spreset = 10 ' soundfont preset 20
            fonts(0).sbank = 0 ' soundfont bank 0
            fonts(0).dpreset = 10 ' destination preset 10
            fonts(0).dbank = 0 ' destination bank 0
            fonts(0).dbanklsb = 0 ' destination bank LSB 0
            fonts(1).font = font2
            fonts(1).spreset = -1 ' all presets
            fonts(1).sbank = -1 ' all banks
            fonts(1).dpreset = -1 ' all presets
            fonts(1).dbank = 0 ' default banks
            fonts(1).dbanklsb = 0 ' destination bank LSB 0
            BASS_MIDI_StreamSetFonts(handle, fonts, 2) ' apply it to the stream
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="fonts">An array to retrieve the soundfont configuration.</param>
            <param name="count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int fontCount = BassMidi.BASS_MIDI_StreamGetFontsCount(_stream);
            BASS_MIDI_FONT[] fonts = new BASS_MIDI_FONT[fontCount];
            int count = BassMidi.BASS_MIDI_StreamGetFonts(_stream, fonts, fontCount);
            </code>
            <code lang="vbnet">
            Dim fontCount As Integer = BassMidi.BASS_MIDI_StreamGetFontsCount(_stream)
            Dim fonts(fontCount) As BASS_MIDI_FONT
            Dim count As Integer = BassMidi.BASS_MIDI_StreamGetFonts(_stream, fonts, fontCount)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> configuration entries if successfull - or <see langword="null"/> on error.</returns>
            <remarks>This overload will always return all used soundfont configuration objects.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_MIDI_FONT[] fonts = BassMidi.BASS_MIDI_StreamGetFonts(_stream);
            </code>
            <code lang="vbnet">
            Dim fonts As BASS_MIDI_FONT() = BassMidi.BASS_MIDI_StreamGetFonts(_stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFontsEx(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX[],System.Int32)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="fonts"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX[],System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="fonts">An array to retrieve the soundfont configuration.</param>
            <param name="count">The maximum number of elements to retrieve in the fonts array. This and fonts can be 0, to get the number of elements in the soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration (which can be higher than count) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When a soundfont matching the MIDI file is loaded, it will be the first element in the returned configuration.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int fontCount = BassMidi.BASS_MIDI_StreamGetFontsCount(_stream);
            BASS_MIDI_FONTEX[] fonts = new BASS_MIDI_FONTEX[fontCount];
            int count = BassMidi.BASS_MIDI_StreamGetFonts(_stream, fonts, fontCount);
            </code>
            <code lang="vbnet">
            Dim fontCount As Integer = BassMidi.BASS_MIDI_StreamGetFontsCount(_stream)
            Dim fonts(fontCount) As BASS_MIDI_FONTEX
            Dim count As Integer = BassMidi.BASS_MIDI_StreamGetFonts(_stream, fonts, fontCount)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFontsEx(System.Int32)">
            <summary>
            Retrieves the soundfont configuration of a MIDI stream, or the default soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX"/> configuration entries if successfull - or <see langword="null"/> on error.</returns>
            <remarks>This overload will always return all used soundfont configuration objects.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_MIDI_FONTEX[] fonts = BassMidi.BASS_MIDI_StreamGetFontsEx(_stream);
            </code>
            <code lang="vbnet">
            Dim fonts As BASS_MIDI_FONTEX() = BassMidi.BASS_MIDI_StreamGetFontsEx(_stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFontsCount(System.Int32)">
            <summary>
            Retrieves the number of elements in the soundfont configuration.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <returns>If successful, the number of soundfonts in the configuration is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetTrackCount(System.Int32)">
            <summary>
            Returns the total number of tracks contained in the MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the track count from.</param>
            <returns>The number of tracks contained in the MIDI stream.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamLoadSamples(System.Int32)">
            <summary>
            Preloads the samples required by a MIDI file stream.
            </summary>
            <param name="handle">The MIDI stream handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts. That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.</para>
            <para>Preloaded samples can be compacted/unloaded just like any other samples, so it is probably wise to disable the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIDI_COMPACT</see> option when preloading samples, to avoid any chance of the samples subsequently being automatically unloaded.</para>
            <para>This function should not be used while the MIDI stream is being rendered, as that could interrupt the rendering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is for real-time events only, so it's not possible to know what presets are going to be used. Use <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontLoad(System.Int32,System.Int32,System.Int32)"/> instead.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetChannel(System.Int32,System.Int32)">
            <summary>
            Gets a HSTREAM handle for a MIDI channel (e.g. to set DSP/FX on individual MIDI channels).
            </summary>
            <param name="handle">The midi stream to get a channel from.</param>
            <param name="channel">The MIDI channel... 0 = channel 1. Or one of the following special channels:
            <para>BASS_MIDI_CHAN_CHORUS = -1 : Chorus mix channel. The default chorus processing is replaced by the stream's processing.</para>
            <para>BASS_MIDI_CHAN_REVERB = -2 : Reverb mix channel. The default reverb processing is replaced by the stream's processing.</para>
            <para>BASS_MIDI_CHAN_USERFX = -3 : User effect mix channel.</para>
            </param>
            <returns>If successful, the channel handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>By default, MIDI channels do not have streams assigned to them; a MIDI channel only gets a stream when this function is called, which it then keeps until the MIDI stream is freed. 
            MIDI channel streams can also be freed before then via <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>. Each MIDI channel stream increases the CPU usage slightly, even if there are no DSP/FX set on them, so for optimal performance they should not be activated when unnecessary</para>
            <para>The MIDI channel streams have a different path to the final mix than the BASSMIDI reverb/chorus processing, which means that the reverb/chorus will not be present in the data received by any DSP/FX set on the streams and nor will the reverb/chorus be applied to the DSP/FX output; 
            the reverb/chorus processing will use the channel's original data.</para>
            <para>The MIDI channel streams can only be used to set DSP/FX on the channels. 
            They cannot be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> to visualise the channels, for example, 
            but that could be achieved via a DSP function instead.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description><paramref name="channel"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Apply some DX8 distortion to channel 1 of a MIDI stream:
            <code>
            // get a stream for MIDI channel 1
            int chan1 = BassMidi.BASS_MIDI_StreamGetChannel(midi, 0);
            // set the DX8 distortion effect on it
            int fx = Bass.BASS_ChannelSetFX(chan1, BASSFXType.BASS_FX_DX8_DISTORTION, 0);
            </code>
            <code lang="vbnet">
            ' get a stream for MIDI channel 1
            Dim chan1 As Integer = BassMidi.BASS_MIDI_StreamGetChannel(midi, 0)
            ' set the DX8 distortion effect on it
            Dim chan1 As Integer = Bass.BASS_ChannelSetFX(chan1, BASSFXType.BASS_FX_DX8_DISTORTION, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFilter(System.Int32,System.Boolean,Un4seen.Bass.AddOn.Midi.MIDIFILTERPROC,System.IntPtr)">
            <summary>
            Sets an event filtering function on a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream handle.</param>
            <param name="seeking">Also filter events when seeking?</param>
            <param name="proc">The callback function... <see langword="null"/> = no filtering.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function allows a MIDI stream to have its events modified during playback via a callback function. 
            The callback function will be called before an event is processed, and it can choose to keep the event as is, or it can modify or drop the event. The filtering can also be applied to events while seeking, so that playback begins in a filtered state after seeking.
            <para>Filtering only applies to a MIDI stream's defined event sequence, not any events that are applied via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> or <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream does not have an event sequence.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetPreset(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT)">
            <summary>
            Retrieves the preset currently in use on a channel of a MIDI stream.
            </summary>
            <param name="handle">The MIDI stream to retrieve the soundfont configuration of... 0 = get default soundfont configuration.</param>
            <param name="chan">The MIDI channel... 0 = channel 1.</param>
            <param name="font">Pointer to a structure to receive the preset information.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function tells what preset from what soundfont is currently being used on a particular MIDI channel.
            That information can be used to get the preset's name from <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPreset(System.Int32,System.Int32,System.Int32)"/>.
            <para>No preset information will be available for a MIDI channel until a note is played in that channel. 
            The present and bank numbers will not necessarily match the channel's current MIDI_EVENT_PROGRAM and MIDI_EVENT_BANK event values, but rather what the MIDI stream's soundfont configuration maps those event values to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="chan"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>No preset is currently in use on the specified MIDI channel.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInitUnicode(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            Initializes a soundfont from a file (unicode).
            </summary>
            <param name="file">The file name of the sound font (e.g. an .sf2 file).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIDI_FONT_MMAP</term><description>Map the file into memory. This flag is ignored if the soundfont is packed as the sample data cannot be played directly from a mapping; it needs to be decoded. This flag is also ignored if the file is too large to be mapped into memory.</description></item>
            <item><term>BASS_MIDI_FONT_XGDRUMS</term><description>Use bank 127 in the soundfont for XG drum kits. When an XG drum kit is needed, bank 127 in soundfonts that have this flag set will be checked first, before falling back to bank 128 (the standard SF2 drum kit bank) if it is not available there.</description></item>
            <item><term>BASS_MIDI_FONT_NOFX</term><description>Ignore the soundfont's reverb and chorus settings.<para>If you would like to ignore the soundfont's reverb/chorus on only some presets/banks, then you can load 2 instances of it (one with BASS_MIDI_FONT_NOFX flag and one without), and then assign them as wanted in a BASS_MIDI_StreamSetFonts call. The 2 instances will share resources, so they won't really use any more memory than 1 instance.</para></description></item>
            </list>
            </param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The BASS_UNICODE flag is applied automatically here.
            <para>BASSMIDI uses SF2 and/or SFZ soundfonts to provide the sounds to use in the rendering of MIDI files. Several soundfonts can be found on the internet, including a couple on the BASS website.</para>
            <para>A soundfont needs to be initialized before it can be used to render MIDI streams. Once initialized, a soundfont can be assigned to MIDI streams using the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> function. A single soundfont can be shared by multiple MIDI streams.</para>
            <para>Information on the initialized soundfont can be retrieved using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/>.</para>
            <para>If a soundfont is initialized multiple times, each instance will have its own handle but share the same sample/etc data.</para>
            <para>Soundfonts use PCM sample data as standard, but BASSMIDI can accept any format that is supported by BASS or its add-ons. The <see cref="!:BASS_MIDI_FontPack"/> function can be used to compress the sample data in SF2 files. SFZ samples are in separate files and can be compressed using standard encoding tools.</para>
            <para>Using soundfonts that are located somewhere other than the file system is possible via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInitUser(Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,Un4seen.Bass.BASSFlag)"/>.</para>
            <para><b>SF2 support</b></para>
            <para>The SF2 synthesis model is fully supported, as are all SF2 generators. Basic support for the note velocity to filter cutoff (initialFilterFc) and note velocity to volume envelope attack (attackVolEnv) modulators is also included. In each case, multiple modulators in the global/instrument/preset zones is supported but only if they are identical (eg. all linear negative mono). If different types are present on a preset, then the last one (with a non-zero amount) will be used. The SF2 spec's slightly strange default note velocity to filter cutoff modulator is not used.</para>
            <para><b>SFZ support</b></para>
            <para>The following SFZ opcodes are supported: ampeg_attack, ampeg_decay, ampeg_delay, ampeg_hold, ampeg_release, ampeg_sustain, ampeg_vel2attack, ampeg_vel2decay, amplfo_delay/fillfo_delay/pitchlfo_delay, amplfo_depth, amplfo_freq/fillfo_freq/pitchlfo_freq, amp_veltrack, cutoff, default_path, effect1, effect2, end, fileg_attack/pitcheg_attack, fileg_decay/pitcheg_decay, fileg_delay/pitcheg_delay, fileg_depth, fileg_hold/pitcheg_hold, fileg_release/pitcheg_release, fileg_sustain/pitcheg_sustain, fileg_vel2depth, fillfo_depth, fil_veltrack, group, hicc1, hicc64, hikey, hirand, hivel, key, locc1, locc64, lokey, loop_end, loop_mode, loop_start, lorand, lovel, offset, off_by, off_mode, pan, pitcheg_depth, pitchlfo_depth, pitch_keycenter, pitch_keytrack, pitch_veltrack, resonance, sample, seq_length, seq_position, transpose, tune, volume. The fil_type opcode is also supported, but only to confirm that a low pass filter is wanted (the filter will be disabled otherwise). The combined EG and LFO entries in the opcode list reflect that there is a shared EG for pitch/filter and a shared LFO for amplitude/pitch/filter, as is the case in SF2. Information on these (and other) SFZ opcodes can be found at www.sfzformat.com.</para>
            <para>Samples can also be loaded from memory by setting the "sample" opcode to "mem:&lt;address&gt;:&lt;length&gt;", where address and length are both in hexadecimal. The memory should remain valid until the font is freed via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontFree(System.Int32)"/>.</para>
            <para>SFZ files don't have a defined preset or bank number, so they are nominally assigned to preset 0 in bank 0 when loaded, but can be assigned to other presets/banks via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para><b>Platform-specific</b></para>
            <para>The BASS_MIDI_FONT_MMAP option is not available on big-endian systems (eg. PowerPC) as a soundfont's little-endian sample data cannot be played directly from a mapping; its byte order needs to be reversed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // first initialize the fonts
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            int font2 = BassMidi.BASS_MIDI_FontInit("bfont.sf2");
            BASS_MIDI_FONT[] newfonts = new BASS_MIDI_FONT[2];
            newfonts[0] = new BASS_MIDI_FONT(font1, 10, 0);
            newfonts[1] = new BASS_MIDI_FONT(font2, -1, 0);
            // now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, 2);
            </code>
            <code lang="vbnet">
            ' first initialize the fonts
            Dim font1 As Integer = BassMidi.BASS_MIDI_FontInit("afont.sf2")
            Dim font2 As Integer = BassMidi.BASS_MIDI_FontInit("bfont.sf2")
            Dim newfonts(2) As BASS_MIDI_FONT
            newfonts(0) = New BASS_MIDI_FONT(font1, 10, 0)
            newfonts(1) = New BASS_MIDI_FONT(font2, -1, 0)
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, 2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String)">
            <summary>
            Initializes a soundfont from a file (unicode).
            </summary>
            <param name="file">The file name of the sound font (e.g. an .sf2 file).</param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The BASS_UNICODE flag is applied automatically here.
            <para>BASSMIDI uses SF2 and/or SFZ soundfonts to provide the sounds to use in the rendering of MIDI files. Several soundfonts can be found on the internet, including a couple on the BASS website.</para>
            <para>A soundfont needs to be initialized before it can be used to render MIDI streams. Once initialized, a soundfont can be assigned to MIDI streams using the <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> function. A single soundfont can be shared by multiple MIDI streams.</para>
            <para>Information on the initialized soundfont can be retrieved using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/>.</para>
            <para>If a soundfont is initialized multiple times, each instance will have its own handle but share the same sample/etc data.</para>
            <para>Soundfonts use PCM sample data as standard, but BASSMIDI can accept any format that is supported by BASS or its add-ons. The <see cref="!:BASS_MIDI_FontPack"/> function can be used to compress the sample data in SF2 files. SFZ samples are in separate files and can be compressed using standard encoding tools.</para>
            <para>Using soundfonts that are located somewhere other than the file system is possible via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInitUser(Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,Un4seen.Bass.BASSFlag)"/>.</para>
            <para><b>SF2 support</b></para>
            <para>The SF2 synthesis model is fully supported, as are all SF2 generators. Basic support for the note velocity to filter cutoff (initialFilterFc) and note velocity to volume envelope attack (attackVolEnv) modulators is also included. In each case, multiple modulators in the global/instrument/preset zones is supported but only if they are identical (eg. all linear negative mono). If different types are present on a preset, then the last one (with a non-zero amount) will be used. The SF2 spec's slightly strange default note velocity to filter cutoff modulator is not used.</para>
            <para><b>SFZ support</b></para>
            <para>The following SFZ opcodes are supported: ampeg_attack, ampeg_decay, ampeg_delay, ampeg_hold, ampeg_release, ampeg_sustain, ampeg_vel2attack, ampeg_vel2decay, amplfo_delay/fillfo_delay/pitchlfo_delay, amplfo_depth, amplfo_freq/fillfo_freq/pitchlfo_freq, amp_veltrack, cutoff, default_path, effect1, effect2, end, fileg_attack/pitcheg_attack, fileg_decay/pitcheg_decay, fileg_delay/pitcheg_delay, fileg_depth, fileg_hold/pitcheg_hold, fileg_release/pitcheg_release, fileg_sustain/pitcheg_sustain, fileg_vel2depth, fillfo_depth, fil_veltrack, group, hicc1, hicc64, hikey, hirand, hivel, key, locc1, locc64, lokey, loop_end, loop_mode, loop_start, lorand, lovel, offset, off_by, off_mode, pan, pitcheg_depth, pitchlfo_depth, pitch_keycenter, pitch_keytrack, pitch_veltrack, resonance, sample, seq_length, seq_position, transpose, tune, volume. The fil_type opcode is also supported, but only to confirm that a low pass filter is wanted (the filter will be disabled otherwise). The combined EG and LFO entries in the opcode list reflect that there is a shared EG for pitch/filter and a shared LFO for amplitude/pitch/filter, as is the case in SF2. Information on these (and other) SFZ opcodes can be found at www.sfzformat.com.</para>
            <para>Samples can also be loaded from memory by setting the "sample" opcode to "mem:&lt;address&gt;:&lt;length&gt;", where address and length are both in hexadecimal. The memory should remain valid until the font is freed via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontFree(System.Int32)"/>.</para>
            <para>SFZ files don't have a defined preset or bank number, so they are nominally assigned to preset 0 in bank 0 when loaded, but can be assigned to other presets/banks via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/>.</para>
            <para><b>Platform-specific</b></para>
            <para>The BASS_MIDI_FONT_MMAP option is not available on big-endian systems (eg. PowerPC) as a soundfont's little-endian sample data cannot be played directly from a mapping; its byte order needs to be reversed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // first initialize the fonts
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            int font2 = BassMidi.BASS_MIDI_FontInit("bfont.sf2");
            BASS_MIDI_FONT[] newfonts = new BASS_MIDI_FONT[2];
            newfonts[0] = new BASS_MIDI_FONT(font1, 10, 0);
            newfonts[1] = new BASS_MIDI_FONT(font2, -1, 0);
            // now set them
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, 2);
            </code>
            <code lang="vbnet">
            ' first initialize the fonts
            Dim font1 As Integer = BassMidi.BASS_MIDI_FontInit("afont.sf2")
            Dim font2 As Integer = BassMidi.BASS_MIDI_FontInit("bfont.sf2")
            Dim newfonts(2) As BASS_MIDI_FONT
            newfonts(0) = New BASS_MIDI_FONT(font1, 10, 0)
            newfonts(1) = New BASS_MIDI_FONT(font2, -1, 0)
            BassMidi.BASS_MIDI_StreamSetFonts(_stream, newfonts, 2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInitUser(Un4seen.Bass.BASS_FILEPROCS,System.IntPtr,Un4seen.Bass.BASSFlag)">
            <summary>
            Initializes a soundfont via user callback functions.
            </summary>
            <param name="procs">The user defined file function (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIDI_FONT_XGDRUMS</term><description>Use bank 127 in the soundfont for XG drum kits. When an XG drum kit is needed, bank 127 in soundfonts that have this flag set will be checked first, before falling back to bank 128 (the standard SF2 drum kit bank) if it is not available there.</description></item>
            </list>
            </param>
            <returns>If successful, the soundfont's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The unbuffered file system (STREAMFILE_NOBUFFER) is always used by this function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO"/> class to store the information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int font1 = BassMidi.BASS_MIDI_FontInit("afont.sf2");
            BASS_MIDI_FONTINFO fontInfo = new BASS_MIDI_FONTINFO();
            BassMidi.BASS_MIDI_FontGetInfo(font1, fontInfo);
            Console.WriteLine( fontInfo.ToString() );
            </code>
            <code lang="vbnet">
            Dim font1 As Integer = BassMidi.BASS_MIDI_FontInit("afont.sf2")
            Dim fontInfo As New BASS_MIDI_FONTINFO()
            BassMidi.BASS_MIDI_FontGetInfo(font1, fontInfo)
            Console.WriteLine(fontInfo.ToString())
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32)">
            <summary>
            Retrieves information on a soundfont.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO"/> class on success - else <see langword="null"/>.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontCompact(System.Int32)">
            <summary>
            Compact a soundfont's memory usage.
            </summary>
            <param name="handle">The soundfont to get info on (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)"/>)... 0 = all soundfonts.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Compacting involves freeing any samples that are currently loaded but unused. The amount of sample data currently loaded can be retrieved using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontFree(System.Int32)">
            <summary>
            Frees a soundfont.
            </summary>
            <param name="handle">The soundfont handle to free (e.g. as returned by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)"/>).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When a soundfont is freed, it is automatically removed from any MIDI streams that are using it.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontLoad(System.Int32,System.Int32,System.Int32)">
            <summary>
            Preloads presets from a soundfont.
            </summary>
            <param name="handle">The soundfont handle.</param>
            <param name="preset">Preset number to load... -1 = all presets.</param>
            <param name="bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Samples are normally loaded as they are needed while rendering a MIDI stream, which can result in CPU spikes, particularly with packed soundfonts. That generally won't cause any problems, but when smooth/constant performance is critical this function can be used to preload the samples before rendering, so avoiding the need to load them while rendering.</para>
            <para>When preloading samples to render a particular MIDI stream, it is more efficient to use <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamLoadSamples(System.Int32)"/> to preload the specific samples that the MIDI stream will use, rather than preloading the entire soundfont.</para>
            <para>Samples that are preloaded by this function are not affected by automatic compacting via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_COMPACT"/> option, but can be compacted/unloaded manually with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontCompact(System.Int32)"/>.</para>
            <para>A soundfont should not be preloaded while it's being used to render any MIDI streams, as that could delay the rendering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The appropriate add-on to decode the samples is not loaded.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The soundfont does not contain the requested preset.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontUnload(System.Int32,System.Int32,System.Int32)">
            <summary>
            Unloads presets from a soundfont.
            </summary>
            <param name="handle">The soundfont handle.</param>
            <param name="preset">Preset number to load... -1 = all presets.</param>
            <param name="bank">Bank number to load... -1 = all banks.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>An unloaded preset will be loaded again when needed by a MIDI stream. Any samples that are currently being used by a MIDI stream will not be unloaded.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The soundfont does not contain the specified preset, or the soundfont is memory mapped.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPresetPtr(System.Int32,System.Int32,System.Int32)">
            <summary>
            Retrieves the name of a preset in a soundfont.
            </summary>
            <param name="handle"></param>
            <param name="preset"></param>
            <param name="bank"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPreset(System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="handle">The soundfont handle to get the preset name from.</param>
            <param name="preset">Preset number to load... -1 = all presets (the first encountered).</param>
            <param name="bank">Bank number to load... -1 = all banks (the first encountered).</param>
            <returns>If successful, the requested preset name is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            SFZ files do not contain preset names, so their filenames (minus the ".sfz" extension) are used instead when available.
            <para>A list of all presets in a soundfont is available from <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPresets(System.Int32,System.Int32[])"/>.</para>
            <para>Drum kits are located in bank 128, and possibly bank 127 in the case of XG drum kits.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The soundfont does not contain the requested preset.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPresets(System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="presets"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPresets(System.Int32)">
            <summary>
            Retrieves the presets in a soundfont.
            </summary>
            <param name="handle">The soundfont handle to get the preset name from.</param>
            <returns>If successful, an array of presets is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The presets are delivered with the preset number in the LOWORD and the bank number in the HIWORD, and in numerically ascending order.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetPresetFonts(System.Int32)">
            <summary>
            Retrieves the presets in a soundfont.
            </summary>
            <param name="handle">The soundfont handle to get the preset name from.</param>
            <returns>If successful, an array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> instances is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontSetVolume(System.Int32,System.Single)">
            <summary>
            Sets a soundfont's volume level.
            </summary>
            <param name="handle">The soundfont to set the volume of.</param>
            <param name="volume">The volume level... 0=silent, 1.0=normal/default.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            By default, some soundfonts may be louder than others, which could be a problem when mixing multiple soundfonts. 
            This function can be used to compensate for any differences, by raising the level of the quieter soundfonts or lowering the louder ones.
            <para>Changes take immediate effect in any MIDI streams that are using the soundfont.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetVolume(System.Int32)">
            <summary>
            Retrieves a soundfont's volume level.
            </summary>
            <param name="handle">The soundfont to get the volume of.</param>
            <returns>If successful, the soundfont's volume level is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfoInternal(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO)">
            <summary>
            Retrieves information on a MIDI input device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function can be used to enumerate the available MIDI input devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>MIDI input is not available on Android.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a MIDI input device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, an instance of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function can be used to enumerate the available MIDI input devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>MIDI input is not available on Android.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetGeviceInfos">
            <summary>
            Returns all available MIDI input devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO"/> elements representing the available MIDI input devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfos">
            <summary>
            Returns the total number of available MIDI input devices.
            </summary>
            <returns>Number of real MIDI input devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InInit(System.Int32,Un4seen.Bass.AddOn.Midi.MIDIINPROC,System.IntPtr)">
            <summary>
            Initializes a MIDI input device.
            </summary>
            <param name="device">The device to use... 0 = first. <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO)"/> can be used to enumerate the available devices.</param>
            <param name="proc">Callback delegate to receive MIDI data from the device.</param>
            <param name="user">User instance data to pass to the callback delegate.</param>
            <returns>If the device was successfully initialized, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before using any MIDI input functions.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. You must call <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InFree(System.Int32)"/> before you can initialize it again.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The device is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>MIDI input is not available on Android.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InFree(System.Int32)">
            <summary>
            Frees a MIDI input device.
            </summary>
            <param name="device">The device to free.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InStart(System.Int32)">
            <summary>
            Starts a MIDI input device.
            </summary>
            <param name="device">The device to start.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InStop(System.Int32)">
            <summary>
            Stops a MIDI input device.
            </summary>
            <param name="device">The device to stop.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_ConvertEvents(System.Byte[],System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="length"></param>
            <param name="events"></param>
            <param name="count"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_ConvertEvents(System.Byte[],Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode)">
            <summary>
            Converts raw MIDI data to <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures.
            </summary>
            <param name="data">The raw MIDI data.</param>
            <param name="events">The array to receive the events... <see langword="null"/> = get the number of events without getting the events themselves.</param>
            <param name="count">The maximum number of events to convert.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode"/>):
            <list type="table">
            <item><term>BASS_MIDI_EVENTS_NORSTATUS</term><description>Disable running status, meaning each event must include a status byte.</description></item>
            <item><term>BASS_MIDI_EVENTS_TIME</term><description>The raw MIDI data includes delta-time info.</description></item>
            </list>
            </param>
            <returns>If successful, the number of events processed is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some mystery problem.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_ConvertEvents(System.Byte[],Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode)">
            <summary>
            Converts raw MIDI data to <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures.
            </summary>
            <param name="data">The raw MIDI data.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode"/>):
            <list type="table">
            <item><term>BASS_MIDI_EVENTS_NORSTATUS</term><description>Disable running status, meaning each event must include a status byte.</description></item>
            <item><term>BASS_MIDI_EVENTS_TIME</term><description>The raw MIDI data includes delta-time info.</description></item>
            </list>
            </param>
            <returns>If successful, the array of events processed is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some mystery problem.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BassMidi.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bassmidi.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BassMidi.SupportedStreamName">
            <summary>
            Supported file format name of the bassmidi.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker">
            <summary>
            The Marker type, to be used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_MARKER">
            <summary>
            Marker events (MIDI meta event 6).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_CUE">
            <summary>
            Cue events (MIDI meta event 7).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_LYRIC">
            <summary>
            Lyric events (MIDI meta event 5).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_TEXT">
            <summary>
            Text events (MIDI meta event 1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_TIMESIG">
            <summary>
            Time signature event (MIDI meta event 88).
            <para>The time signature events are given in the form of "numerator/denominator metronome-pulse 32nd-notes-per-MIDI-quarter-note", eg. "4/4 24 8"</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_KEYSIG">
            <summary>
            Key signature events (MIDI meta event 89).
            <para>That gives the key signature (in BASS_MIDI_MARK.text) in the form of "a b", where "a" is the number of sharps (if positive) or flats (if negative) and "b" signifies major (if 0) or minor (if 1).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_COPY">
            <summary>
            Copyright notice (MIDI meta event 2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_TRACK">
            <summary>
            Track name events (MIDI meta event 3).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_INST">
            <summary>
            Instrument name events (MIDI meta event 4). 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_TRACKSTART">
            <summary>
            Track start (SMF2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIMarker.BASS_MIDI_MARK_TICK">
            <summary>
            FLAG: get position in ticks instead of bytes
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent">
            <summary>
            The MIDI event type, to be used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> resp. <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)"/> or <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateEvents(Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_NONE">
            <summary>
            No event.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_NOTE">
            <summary>
            Press or release a key, or stop without sustain/decay.
            <para>param : LOBYTE = key number (0-127, 60=middle C), HIBYTE = velocity (0=release, 1-127=press, 255=stop).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PROGRAM">
            <summary>
            Select the preset/instrument to use. Standard soundfont presets follow the General MIDI standard, and generally also include Roland GS variations in other banks (accessible via the MIDI_EVENT_BANK event).
            <para>param : preset number (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHANPRES">
            <summary>
            Set the channel pressure.
            <para>param : pressure level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PITCH">
            <summary>
            Set the pitch wheel.
            <para>param : pitch wheel position (0-16383, 8192=normal/middle).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PITCHRANGE">
            <summary>
            Set pitch wheel range (MIDI RPN 0).
            <para>param : range in semitones.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUMS">
            <summary>
            Set the percussion/drums channel switch. The bank and program are reset to 0 when this changes.
            <para>param : use drums? (0=no, 1=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_FINETUNE">
            <summary>
            Set the fine tuning (MIDI RPN 1).
            <para>param : finetune in cents (0-16383, 0=-100, 8192=normal, 16383=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_COARSETUNE">
            <summary>
            Set the coarse tuning (MIDI RPN 2).
            <para>param : finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MASTERVOL">
            <summary>
            Set the master volume.
            <para>param : volume level (0-16383, 0=silent, 16363=normal/full).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_BANK">
            <summary>
            Select the bank to use (MIDI controller 0).
            <para>param : bank number (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MODULATION">
            <summary>
            Set the modulation (MIDI controller 1).
            <para>param : modulation level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_VOLUME">
            <summary>
            Set the volume (MIDI controller 7).
            <para>param : volume level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PAN">
            <summary>
            Set the pan position (MIDI controller 10).
            <para>param : pan position (0-128, 0=left, 64=middle, 127=right, 128=random).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_EXPRESSION">
            <summary>
            Set the expression (MIDI controller 11).
            <para>param : expression level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SUSTAIN">
            <summary>
            Set the sustain switch (MIDI controller 64).
            <para>param : enable sustain? (0-63=no, 64-127=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SOUNDOFF">
            <summary>
            Stop all sounds (MIDI controller 120).
            <para>param : not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_RESET">
            <summary>
            Reset controllers (MIDI controller 121), that is modulation=0, expression=127, sustain=0, pitch wheel=8192, channel pressure=0.
            <para>param : not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_NOTESOFF">
            <summary>
            Release all keys (MIDI controller 123).
            <para>param : not used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PORTAMENTO">
            <summary>
            Set the portamento switch (MIDI controller 65).
            <para>param : enable portamento? (0-63=no, 64-127=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PORTATIME">
            <summary>
            Set the portamento time (MIDI controller 5).
            <para>param : portamento time (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_PORTANOTE">
            <summary>
            Set the portamento start key - the next note starts at this key (MIDI controller 84).
            <para>param : key number (1-127, 60=middle C).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MODE">
            <summary>
            Set poly/mono mode (MIDI controllers 126 &amp; 127).
            <para>param : mode (0=poly, 1=mono).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB">
            <summary>
            Set the reverb send level (MIDI controller 91).
            <para>param : reverb level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS">
            <summary>
            Set the chorus send level (MIDI controller 93).
            <para>param : chorus level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CUTOFF">
            <summary>
            Set the low-pass filter cutoff (MIDI controller 74, NRPN 120h).
            <para>param : cutoff level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_RESONANCE">
            <summary>
            Set the low-pass filter resonance (MIDI controller 71, NRPN 121h).
            <para>param : resonance level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_RELEASE">
            <summary>
            Set the release time (MIDI controller 72, NRPN 166h).
            <para>param : release time (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_ATTACK">
            <summary>
            Set the attack time (MIDI controller 73, NRPN 163h).
            <para>param : attack time (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_MACRO">
            <summary>
            To be defined.
            <para>param : to be defined.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_MACRO">
            <summary>
            To be defined.
            <para>param : to be defined.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_TIME">
            <summary>
            Set the reverb time.
            <para>param : reverb time in milliseconds.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_DELAY">
            <summary>
            Set the reverb delay.
            <para>param : reverb delay in millisecond 10ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_LOCUTOFF">
            <summary>
            Set the reverb low-pass cutoff.
            <para>param :  reverb low-pass cutoff in hertz (0=off).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_HICUTOFF">
            <summary>
            Set the reverb high-pass cutoff.
            <para>param : reverb high-pass cutoff in hertz (0=off).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_REVERB_LEVEL">
            <summary>
            Set the reverb level.
            <para>param : reverb level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_DELAY">
            <summary>
            Set the chorus delay.
            <para>param : chorus delay in millisecond 10ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_DEPTH">
            <summary>
            Set the chorus depth.
            <para>param : chorus depth in millisecond 10ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_RATE">
            <summary>
            Set the chorus rate.
            <para>param : chorus rate in hertz 100ths.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_FEEDBACK">
            <summary>
            Set the chorus feedback level.
            <para>param : chorus feedback level (0=-100%, 100=off, 200=+100%).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_LEVEL">
            <summary>
            Set the chorus level.
            <para>param : chorus level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHORUS_REVERB">
            <summary>
            Set the chorus send to reverb level.
            <para>param : chorus send to reverb level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_USERFX">
            <summary>
            Set the user effect send level (MIDI controller 94). This will have no audible effect unless custom processing is applied to the user effect mix via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetChannel(System.Int32,System.Int32)"/>.
            <para>param : user effect level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_USERFX_LEVEL">
            <summary>
            Set the user effect level.
            <para>param : user effect level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_USERFX_REVERB">
            <summary>
            Set the user effect send to reverb level.
            <para>param : user effect send to reverb level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_USERFX_CHORUS">
            <summary>
            Set the user effect send to chorus level.
            <para>param : user effect send to chorus level (0=off, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_FINETUNE">
            <summary>
            Set the fine tuning of a drum key (MIDI NRPN 19knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = finetune in cents (0-127, 0=-100, 64=normal, 127=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_COARSETUNE">
            <summary>
            Set the coarse tuning of a drum key (MIDI NRPN 18knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = finetune in semitones (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_PAN">
            <summary>
            Set the pan position of a drum key (MIDI NRPN 1Cknh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = pan position (0-127, 0=random, 64=middle).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_REVERB">
            <summary>
            Set the reverb send level of a drum key (MIDI NRPN 1Dknh).
            <para>param :  LOBYTE = key number (0-127), HIBYTE = reverb level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_CHORUS">
            <summary>
            Set the chorus send level of a drum key (MIDI NRPN 1Eknh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = chorus level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_CUTOFF">
            <summary>
            Set the low-pass filter cutoff of a drum key (MIDI NRPN 14knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = cutoff level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_RESONANCE">
            <summary>
            Set the low-pass filter resonance of a drum key (MIDI NRPN 15knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = resonance level (0-127, 0=-64, 64=normal, 127=+63).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_LEVEL">
            <summary>
            Set the drum level NRPN of a drum key (MIDI NRPN 16knh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = level (0-127, 127=full/normal).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_DRUM_USERFX">
            <summary>
            Set the user effect send level of a drum key (MIDI NRPN 1Fknh).
            <para>param : LOBYTE = key number (0-127), HIBYTE = user effect level (0-127, 127=normal/full).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SOFT">
            <summary>
            Set the soft pedal/switch (MIDI controller 67).
            <para>param : soft is on? (0-63=no, 64-127=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SYSTEM">
            <summary>
            Set the system mode, resetting everything to the system's defaults.
            MIDI_SYSTEM_DEFAULT is identical to MIDI_SYSTEM_GS, except that channel 10 is melodic if there are not 16 channels. MIDI_EVENT_SYSTEM does not reset things in any additional channels allocated to a MIDI file stream via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute, while MIDI_EVENT_SYSTEMEX does.
            <para>param : system mode (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDISystem"/>).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_TEMPO">
            <summary>
            Set the tempo (MIDI meta event 81). Changing the tempo affects the stream length, and the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> value will no longer be valid.
            <para>param : tempo in microseconds per quarter note.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SCALETUNING">
            <summary>
            Set the tuning of a note in every octave.
            <para>param : LOWORD = tuning change in cents (0-16383, 0=-100, 8192=normal, 16383=+100), HIWORD = note (0-11, 0=C).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CONTROL">
            <summary>
            Control event.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHANPRES_VIBRATO">
            <summary>
            Change Preset Vibrato.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHANPRES_PITCH">
            <summary>
            Change Preset Pitch.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHANPRES_FILTER">
            <summary>
            Change Preset Filter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_CHANPRES_VOLUME">
            <summary>
            Change Preset Volume.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MOD_VIBRATO">
            <summary>
            Set the maximum effect of modulation (MIDI controller 1) on vibrato depth (MIDI RPN 5).
            <para>param :  vibrato depth effect in cents (0=none, 128=100, 256=200, etc).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MODRANGE">
            <summary>
            Mod Range.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_BANK_LSB">
            <summary>
            Bank LSB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_KEYPRES">
            <summary>
            Set a key's pressure/aftertouch.
            <para>param : LOBYTE = key number (0-127), HIBYTE = pressure level (0-127).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_KEYPRES_VIBRATO">
            <summary>
            Set the maximum effect of key pressure/aftertouch on vibrato depth.
            <para>param : vibrato depth effect in cents (0=none, 128=100, 256=200, etc).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_KEYPRES_PITCH">
            <summary>
            Set the maximum effect of key pressure/aftertouch on pitch.
            <para>param : pitch effect in semitones (0=-24, 24=none, 48=+24).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_KEYPRES_FILTER">
            <summary>
            Set the maximum effect of key pressure/aftertouch on filter cutoff.
            <para>param : filter cutoff effect in cents (0=-9600, 9600=none, 19200=+9600).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_KEYPRES_VOLUME">
            <summary>
            Set the maximum effect of key pressure/aftertouch on volume.
            <para>param : volume effect percentage (0=-100, 100=none, 200=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SOSTENUTO">
            <summary>
            Set the sostenuto pedal/switch (MIDI controller 66).
            <para>param : sostenuto is on? (0-63=no, 64-127=yes).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MOD_PITCH">
            <summary>
            Set the maximum effect of modulation (MIDI controller 1) on pitch.
            <para>param : pitch effect in semitones (0=-24, 24=none, 48=+24).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MOD_FILTER">
            <summary>
            Set the maximum effect of modulation (MIDI controller 1) on filter cutoff.
            <para>param : filter cutoff effect in cents (0=-9600, 9600=none, 19200=+9600).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MOD_VOLUME">
            <summary>
            Set the maximum effect of modulation (MIDI controller 1) on volume.
            <para>param : volume effect percentage (0=-100, 100=none, 200=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_MIXLEVEL">
            <summary>
            Set the level.
            <para>param : the level (0=silent, 100=0dB, 200=+6dB).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_TRANSPOSE">
            <summary>
            Transpose all notes. Changes take effect from the next note played, and affect melodic channels only (not drum channels).
            <para>param : transposition amount in semitones (0=-100, 100=normal, 200=+100).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SYSTEMEX">
            <summary>
            Set the system mode, resetting everything to the system's defaults.
            MIDI_SYSTEM_DEFAULT is identical to MIDI_SYSTEM_GS, except that channel 10 is melodic if there are not 16 channels. MIDI_EVENT_SYSTEM does not reset things in any additional channels allocated to a MIDI file stream via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS"/> attribute, while MIDI_EVENT_SYSTEMEX does.
            <para>param : system mode (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDISystem"/>).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_END_TRACK">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateEvents(Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> to mark the end of a track (the next event will be in a new track).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SPEED">
            <summary>
            Set a tempo modification. Changing the tempo affects the stream length, and the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> byte value will no longer be valid. The modification does not affect seeking.
            <para>param : speed in 100ths of a percent (100=1%/min, 10000=100%/normal, 20000=200%).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_NOTES">
            <summary>
            Flag to check how many keys are pressed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_VOICES">
            <summary>
            Flag to check how many voices are active.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENTS_NORSTATUS">
            <summary>
            Flag: no running status.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_END">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateEvents(Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> to mark the end of the event array.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASSMIDISystem">
            <summary>
            System mode parameter, to be used with <see cref="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SYSTEM"/>, <see cref="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent.MIDI_EVENT_SYSTEMEX"/>.
            </summary>
            <remarks>
            MIDI_SYSTEM_DEFAULT is identical to MIDI_SYSTEM_GS, except that channel 10 is melodic if there are not 16 channels.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDISystem.MIDI_SYSTEM_DEFAULT">
            <summary>
            System default. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDISystem.MIDI_SYSTEM_GM1">
            <summary>
            General MIDI Level 1.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDISystem.MIDI_SYSTEM_GM2">
            <summary>
            General MIDI Level 2.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDISystem.MIDI_SYSTEM_XG">
            <summary>
            XG-Format (Yamaha).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDISystem.MIDI_SYSTEM_GS">
            <summary>
            GS-Format (Roland).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode">
            <summary>
            The type of event data to apply, to be used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode.BASS_MIDI_EVENTS_STRUCT">
            <summary>
            An array of <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structures.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode.BASS_MIDI_EVENTS_RAW">
            <summary>
            Raw MIDI event data, as would be sent to a MIDI device. 
            Running status is supported. To overcome the 16 channel limit, the event data's channel information can optionally be overridden by adding the new channel number to this parameter, where +1 = the 1st channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode.BASS_MIDI_EVENTS_SYNC">
            <summary>
            Flag: Trigger <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIDI_xxx</see> syncs for the processed events (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode.BASS_MIDI_EVENTS_NORSTATUS">
            <summary>
            Flag: Disable running status, meaning each event must include a status byte. Only applicable with BASS_MIDI_EVENTS_RAW.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode.BASS_MIDI_EVENTS_CANCEL">
            <summary>
            Flag: cancel pending events
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode.BASS_MIDI_EVENTS_TIME">
            <summary>
            Flag: delta-time info is present
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontGetInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO)"/> to retrieve information on a soundfont.
            </summary>
            <remarks>
            The name, copyright and comment information might not be included in some SF2 files. 
            Only the presets, samload and samtype members are available with SFZ files, with the samtype value reflecting the most recently loaded encoded sample (it is possible for different samples to use different encoding).
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.name">
            <summary>
            Name of the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.copyright">
            <summary>
            Copyright notice.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.comment">
            <summary>
            Any comments.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.presets">
            <summary>
            The number of presets/instruments in the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.samsize">
            <summary>
            The total size (in bytes) of the sample data in the soundfont.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.samload">
            <summary>
            The amount of sample data currently loaded... -1 = the soundfont is memory mapped.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.samtype">
            <summary>
            The BASS_CTYPE_STREAM_xxx format of the sample data if it's packed... -1 = unknown format (appropriate BASS add-on not loaded), 0 = not packed.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTINFO.ToString">
            <summary>
            A description of the soundfont info object (name, copyright, comment, size etc.)
            </summary>
            <returns>The string description of the soundfont info object.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> to set and retrieve soundfont configurations.
            </summary>
            <remarks>
            When using an individual preset from a soundfont, BASSMIDI will first look for the exact preset and bank match, but if that is not present, the first preset from the soundfont will be used. This is useful for single preset soundfonts. Individual presets can be assigned to program numbers beyond the standard 127 limit, up to 65535, which can then be accessed via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/>.
            <para>When using all presets in a soundfont, the bank member is a base number that is added to the soundfont's banks. For example, if bank=1 then the soundfont's bank 0 becomes bank 1, etc. Negative base numbers are allowed.</para>
            <para>For more flexible mapping of soundfont presets to MIDI programs, see the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX"/> structure.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.font">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.preset">
            <summary>
            Preset number... 0-65535, -1 = use all presets in the soundfont. This determines what MIDI_EVENT_PROGRAM event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.bank">
            <summary>
            Base bank number, or the bank number of the individual preset. This determines what MIDI_EVENT_BANK event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Font">The soundfont handle to use.</param>
            <param name="Preset">The preset number to use (-1=use all presets).</param>
            <param name="Bank">The bank number to use.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT.ToString">
            <summary>
            A description of the soundfont configuration object (font, preset, bank)
            </summary>
            <returns>The description string of the soundfont configuration object.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> to set and retrieve soundfont configurations.
            </summary>
            <remarks>This is an extended version of the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT"/> structure that allows more flexible mapping of soundfont presets to MIDI programs, including access to the bank LSB (eg. MIDI controller 32).
            <para>When using an individual preset from a soundfont, BASSMIDI will first look for the exact spreset and sbank match, but if that is not present, the first preset from the soundfont will be used. This is useful for single preset soundfonts. Individual presets can be assigned to program numbers beyond the standard 127 limit, up to 65535, which can then be accessed via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/>.</para>
            <para>When using all presets from all banks in a soundfont, the <i>dbank</i> member is a base number that is added to the soundfont's banks. For example, if dbank = 1 then the soundfont's bank 0 becomes bank 1, etc. Negative base numbers are allowed, to lower a soundfont's bank numbers.</para>
            <para>The bank LSB raises the maximum number of melodic banks from 128 to 16384 (128 x 128), but the SF2 soundfont format only supports 128 banks, so a soundfont that is set to be used on all banks (<i>dpreset</i> and <i>dbank</i> are -1) will still only apply to the single bank LSB specified by <i>dbanklsb</i>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.font">
            <summary>
            Soundfont handle, previously inititialized with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontInit(System.String,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.spreset">
            <summary>
            Soundfont preset number... 0-127, -1 = use all presets.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.sbank">
            <summary>
            Soundfont bank number... 0-128, -1 = use all banks.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.dpreset">
            <summary>
            Destination preset/program number... 0-65535, -1 = all presets. This determines what MIDI_EVENT_PROGRAM event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.dbank">
            <summary>
            Destination bank number, or a base bank number when using all presets from all banks. This determines what MIDI_EVENT_BANK event value(s) the soundfont is used for.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.dbanklsb">
            <summary>
            Destination bank number LSB. This is the MIDI_EVENT_BANK_LSB event value that the soundfont is used for.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Font">The soundfont handle to use.</param>
            <param name="SPreset">Soundfont preset number... -1 = use all presets.</param>
            <param name="SBank">Soundfont bank number... -1 = use all banks.</param>
            <param name="DPreset">Destination preset/program number... -1 = all presets. This determines what MIDI_EVENT_PROGRAM event value(s) the soundfont is used for.</param>
            <param name="DBank">Destination bank number, or a base bank number when using all presets from all banks. This determines what MIDI_EVENT_BANK event value(s) the soundfont is used for.</param>
            <param name="DBanklsb">Destination bank number LSB. This is the MIDI_EVENT_BANK_LSB event value that the soundfont is used for.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONTEX.ToString">
            <summary>
            A description of the soundfont configuration object (font, preset, bank)
            </summary>
            <returns>The description string of the soundfont configuration object.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>, <see cref="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_LYRIC"/>, <see cref="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_CUE"/> and <see cref="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_MARKER"/> to retrieve markers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.track">
            <summary>
            The MIDI track (number) containing marker (0=first).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.pos">
            <summary>
            The position (in bytes) of the marker.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.text">
            <summary>
            The marker, cue, lyric, keysig, timesig text.
            </summary>
            <remarks>If the lyric text begins with a '/' (slash) character, a new line should be started. 
            If it begins with a '\' (backslash) character, the display should be cleared.
            <para>For a key signature event (MIDI meta event 89). The marker text is in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).</para>
            <para>For a time signature events (MIDI meta event 88). The marker text is in the form of "a/b c d", where a is the numerator, b is the denominator, c is the metronome pulse, and d is the number of 32nd notes per MIDI quarter-note</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="Track">The track (number) containing marker.</param>
            <param name="Pos">The position (in bytes) of the marker.</param>
            <param name="Text">The marker text.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK.ToString">
            <summary>
            A description of the marker object (the text).
            </summary>
            <returns>The marker description text.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/> to apply events 
            and <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvents(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[])"/> to retrieve events, 
            and <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateEvents(Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> to play event sequences.
            </summary>
            <remarks>
            The tick and pos members are ignored by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/>. pos is also ignored by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateEvents(Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.eventtype">
            <summary>
            The event type (see <see cref="T:Un4seen.Bass.AddOn.Midi.BASSMIDIEvent"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.param">
            <summary>
            The event parameter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.chan">
            <summary>
            The MIDI channel of the event... 0 = channel 1.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.tick">
            <summary>
            The position of the event, in ticks.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.pos">
            <summary>
            The position of the event, in bytes.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.#ctor(Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor already setting the members.
            </summary>
            <param name="EventType">The event type.</param>
            <param name="Param">The event parameter.</param>
            <param name="Chan">The MIDI channel of the event... 0 = channel 1.</param>
            <param name="Tick">The position of the event, in ticks.</param>
            <param name="Pos">The position of the event, in bytes.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.ToString">
            <summary>
            A description of the MIDI event object (event, param, chan, tick)
            </summary>
            <returns>The description string of the MIDI event object.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT.FromIntPtr(System.IntPtr)">
            <summary>
            Converts an IntPtr as received in an <see cref="T:Un4seen.Bass.AddOn.Midi.MIDIFILTERPROC"/> to a <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/>.
            </summary>
            <param name="eventPtr">The IntPtr to convert.</param>
            <returns>The underlying <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> struct.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO)"/> to retrieve information on a MIDI input device.
            </summary>
            <remarks>
            <para>On Windows, <i>id</i> consists of a manufacturer identifier in the LOWORD and a product identifier in the HIWORD. This will not uniquely identify a particular device, ie. multiple devices may have the same value.
            A list of identifiers is available from Microsoft, <a href="http://msdn.microsoft.com/en-us/library/dd757146.aspx">here</a>.
            On OSX, <i>id</i> is the device's "kMIDIPropertyUniqueID" property value, which is unique to the device.
            On Linux, id contains the device's ALSA client ID in the LOWORD and port ID in the HIWORD.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.name">
            <summary>
            The name/description of the device.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.id">
            <summary>
            An identification number.
            </summary>
            <remarks>
            On Windows, <i>id</i> consists of a manufacturer identifier in the LOWORD and a product identifier in the HIWORD. This will not uniquely identify a particular device, ie. multiple devices may have the same value.
            A list of identifiers is available from Microsoft, <a href="http://msdn.microsoft.com/en-us/library/dd757146.aspx">here</a>.
            On OSX, <i>id</i> is the device's "kMIDIPropertyUniqueID" property value, which is unique to the device.
            On Linux, id contains the device's ALSA client ID in the LOWORD and port ID in the HIWORD.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.flags">
            <summary>
            The device's current status. A combination of these flags (<see cref="T:Un4seen.Bass.BASSDeviceInfo"/>):
            <list type="table">
            <item><term>BASS_DEVICE_ENABLED</term><description>The device is enabled. It will not be possible to initialize the device if this flag is not present.</description></item>
            <item><term>BASS_DEVICE_INIT</term><description>The device is initialized, ie. <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InInit(System.Int32,Un4seen.Bass.AddOn.Midi.MIDIINPROC,System.IntPtr)"/> has been called.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns>A description of the decive info object (name).</returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.IsEnabled">
            <summary>
            The device is enabled and can be used.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO.IsInitialized">
            <summary>
            The device is already initialized.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.MIDIINPROC">
            <summary>
            User defined callback delegate to receive MIDI data (to be used with <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InInit(System.Int32,Un4seen.Bass.AddOn.Midi.MIDIINPROC,System.IntPtr)"/>).
            </summary>
            <param name="device">The MIDI input device that the data is from.</param>
            <param name="time">Timestamp, in seconds since <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InStart(System.Int32)"/> was called.</param>
            <param name="buffer">Pointer to the MIDI data.</param>
            <param name="length">The amount of data in bytes.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InInit(System.Int32,Un4seen.Bass.AddOn.Midi.MIDIINPROC,System.IntPtr)"/> was called.</param>
            <example>
            <code>
            private MIDIINPROC _midiProc;
            private int _midiStream;
            ...
            // create a MIDI input callback delegate
            _midiProc = new MIDIINPROC(MyMidiInProc);
            BassMidi.BASS_MIDI_InInit(0, _midiProc, IntPtr.Zero);
            ...
            // create a MIDI stream to play the MIDI data
            _midiStream = BassMidi.BASS_MIDI_StreamCreate(16, BASSFlag.BASS_DEFAULT, 44100);
            ...
            private void MyMidiInProc(int device, double time, IntPtr buffer, int length, IntPtr user)
            {
            	// forward the data to the MIDI stream
            	BassMidi.BASS_MIDI_StreamEvents(_midiStream, BASSMIDIEventMode.BASS_MIDI_EVENTS_NONE, 0, buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _midiProc As MIDIINPROC
            Private _midiStream As Integer
            ...
            ' create a MIDI input callback delegate
            _midiProc = New MIDIINPROC(AddressOf MyMidiInProc)
            BassMidi.BASS_MIDI_InInit(0, _midiProc, IntPtr.Zero);
            ...
            ' create a MIDI input callback delegate
            _midiStream = BassMidi.BASS_MIDI_StreamCreate(16, BASSFlag.BASS_DEFAULT, 44100)
            ...
            Private Procedure MyMidiInProc(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr)
            	' forward the data to the MIDI stream
            	BassMidi.BASS_MIDI_StreamEvents(_midiStream, BASSMIDIEventMode.BASS_MIDI_EVENTS_NONE, 0, buffer, length)
            End Procedure
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Midi.MIDIFILTERPROC">
            <summary>
            User defined callback function to filter events.
            </summary>
            <param name="handle">The MIDI stream handle.</param>
            <param name="track">The track that the event is from... 0 = 1st track.</param>
            <param name="eventPtr">Pointer to the <see cref="T:Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT"/> structure.</param>
            <param name="seeking"><see langword="true"/> = the event is being processed while seeking, <see langword="false"/> = the event is being played.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFilter(System.Int32,System.Boolean,Un4seen.Bass.AddOn.Midi.MIDIFILTERPROC,System.IntPtr)"/> was called.</param>
            <returns>Return <see langword="true"/> to process the event, and <see langword="false"/> to drop the event.</returns>
            <remarks>
            The event's type (eventtype), parameter (param), and channel (chan) can be modified, but not its position (tick or pos). 
            It is also possible to apply additional events at the same time via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/>, but not <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvents(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEventMode,Un4seen.Bass.AddOn.Midi.BASS_MIDI_EVENT[],System.Int32)"/>.
            <para>MIDI_EVENT_NOTE, MIDI_EVENT_NOTESOFF, and MIDI_EVENT_SOUNDOFF events are ignored while seeking so they will not be received by a filtering function then. 
            MIDI_EVENT_TEMPO events can be changed while seeking but doing so when seeking in bytes (BASS_POS_BYTE) will result in reaching a different position. 
            Seeking in ticks (BASS_POS_MIDI_TICK) is unaffected by tempo changes. The MIDI_EVENT_SPEED event can be used to modify the tempo without affecting seeking.</para>
            </remarks>
            <example>
            A filtering function that drops all notes with a velocity lower than 10:
            <code>
            private void MidiFilterProc(int handle, int track, IntPtr eventPtr, bool seeking, IntPtr user)
            {
                var midievent = BASS_MIDI_EVENT.FromIntPtr(eventPtr);
            
            	if (midievent.eventtype == BASSMIDIEvent.MIDI_EVENT_NOTE)
            	{
            	    // got a note
            	    int vel = Utils.HighWord32(midievent.param); // extract the velocity
            	    if (vel &lt; 10 &amp;&amp; vel &gt; 0)
            	        return false; // drop the note if velocity is below 10 and not 0 (note off)
            	}
            	return true; // process the event
            }
            </code>
            
            A filtering function that changes bank 2 to bank 1;
            <code>
            private void MidiFilterProc(int handle, int track, IntPtr eventPtr, bool seeking, IntPtr user)
            {
                var midievent = BASS_MIDI_EVENT.FromIntPtr(eventPtr);
            
            	if (midievent.eventtype == BASSMIDIEvent.MIDI_EVENT_BANK &amp;&amp; midievent.param == 2)
            	{
            	    // got a bank 2 request
            	    midievent.param = 1; // change it to bank 1
            	}
            	return true; // process the event
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.BassMix">
            <summary>
            BASS.NET API wrapper for BASSMIX.DLL
            <para>Requires: bassmix.dll - Mixing and resample channels (MIX) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>A fairly common question is how to mix and/or resample channels. To make that task simple, here's the add-on that'll do it.</para>
            </summary>
            <remarks>
            <para>BASSMIX is an extension to the BASS audio library, enabling the mixing and resampling of streams and channels.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_GetVersion">
            <summary>
            Retrieves the version number of the BASSmix.DLL that is loaded.
            </summary>
            <returns>The BASSmix version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSmix supports all the BASSmix functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.AddOn.Mix.BassMix.BASSMIXVERSION"/> to check the major revision.</para>
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassMix.BASS_Mixer_GetVersion()) != BassMix.BASSMIXVERSION )
            {
              MessageBox.Show(this, "Wrong BassMix Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassMix.BASS_Mixer_GetVersion()) &lt;&gt; BassFx.BASSMIXVERSION Then
              MessageBox.Show(Me, "Wrong BassMix Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassMix.BASS_Mixer_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassMix Version!");
            }
            </code>
            <code lang="vbnet">
            If BassMix.BASS_Mixer_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassMix Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSmix.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSmix version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSmix supports all the BASSmix functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>Note: Calling this method will also automatically load the library into memory.</para>
            </remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassMix.BASS_Mixer_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassMix Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassMix.BASS_Mixer_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassMix Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a mixer stream.
            </summary>
            <param name="freq">The sample rate of the mixer output (e.g. 44100).</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers (or the BASS_STREAM_DECODE flag) in Windows, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Produce 8-bit output. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Produce 32-bit floating-point output. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing. Note this only applies to playback of the mixer's output - the mixing of the source channels is always performed by BASSmix.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the DX8 effect implementations section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_MIXER_END</term><description>End the stream when there are no active (including stalled) source channels, else it's never-ending.</description></item>
            <item><term>BASS_MIXER_NONSTOP</term><description>Don't stop producing output when there are no active source channels, else it will be stalled until there are active sources.</description></item>
            <item><term>BASS_MIXER_RESUME</term><description>When stalled, resume the mixer immediately upon a new or unpaused source, else it will be resumed at the next update cycle.</description></item>
            <item><term>BASS_MIXER_POSEX</term><description>Keep a record of the source positions, making it possible to account for output latency when retrieving a source position. How far back the position record goes is determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_POSEX"/> config option. If this flag is not used and neither is the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag, then the mixer will automatically have a position record of equal length to the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> setting.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Source channels are "plugged" into a mixer using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/> functions, and "unplugged" using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemove(System.Int32)"/> function.
             Sources can be added and removed at any time, so a mixer does not have a predetermined length and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> is not applicable. Likewise, seeking is not possible, except to position 0, as described below.</para>
            <para>If the mixer output is being played (it is not a decoding channel), then there will be some delay in the effect of adding/removing source channels or changing their attributes being heard. This latency can be reduced by making use of the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> and <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/> config options.
            The playback buffer can be flushed by calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (pos = 0). That can also be done to restart a mixer that has ended.</para>
            <para>Unless the BASS_MIXER_END flag is specified, a mixer stream will never end. When there are no sources (or the sources have ended/stalled), it'll produce no output until there's an active source. 
            That's unless the BASS_MIXER_NONSTOP flag is used, in which case it will produce silent output while there are no active sources. The BASS_MIXER_END and BASS_MIXER_NONSTOP flags can be toggled at any time, using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>Besides mixing channels, a mixer stream can be used as a resampler. In that case the freq parameter would be set the new sample rate, and the source channel's attributes would be left at their defaults. 
            A mixer stream can also be used to downmix, upmix and generally rearrange channels, using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])">matrix mixing</see> features.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding streams (BASS_STREAM_DECODE) are allowed when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_FREQ</term><description>freq is out of range. See the minrate and maxrate members of the <see cref="T:Un4seen.Bass.BASS_INFO"/> structure.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficent memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Couldn't initialize 3D support for the stream.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create a new mixer stream at 44kHz, stereo using floats - out of two source streams:
            <code>
            // this will be the final mixer output stream being played
            int mixer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT );
            // now we need some channels to plug them in...create two decoding sources
            int streamA = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            int streamB = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            // finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            bool okA = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT);
            bool okB = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT);
            // and play it...
            Bass.BASS_ChannelPlay(mixer, false);
            </code>
            <code lang="vbnet">
            ' this will be the final mixer output stream being played
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT)
            ' now we need some channels to plug them in...create two decoding sources
            Dim streamA As Integer = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim streamB As Integer = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            Dim okA As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT)
            Dim okB As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT)
            ' and play it...
            Bass.BASS_ChannelPlay(mixer, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Plugs a channel into a mixer.
            </summary>
            <param name="handle">The mixer handle (created with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD (e.g. created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIXER_MATRIX</term><description>Creates a channel matrix, allowing the source channels to be sent to any of the mixer output channels, at any levels. The matrix can be retrieved and modified via the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMatrix(System.Int32,System.Single[0:,0:])"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/> functions. The matrix will initially contain a one-to-one mapping, eg. left out = left in, right out = right in, etc... </description></item>
            <item><term>BASS_MIXER_DOWNMIX</term><description>Downmix to stereo, or mono if the mixer output is mono.</description></item>
            <item><term>BASS_MIXER_BUFFER</term><description>Buffer the sample data, for use by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>. This increases memory requirements, so should not be enabled needlessly. The size of the buffer can be controlled via the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option.</description></item>
            <item><term>BASS_MIXER_LIMIT</term><description>Limit the mixer processing to the amount of data available from this source, while the source is active (not ended). If the source stalls, then the mixer will too, rather than continuing to mix other sources, as it would normally do. This flag can only be applied to one source per mixer, so it will automatically be removed from any other source of the same mixer.</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Don't ramp-in the start, including after seeking (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). This is useful for gap-less playback, where a source channel is intended to seamlessly follow another. This does not affect volume and pan changes, which are always ramped.</description></item>
            <item><term>BASS_MIXER_PAUSE</term><description>Don't process the source channel (add it in a paused mode). Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> in order to toggle processing of the source channel.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the source channel when it ends. This allows you to add a channel to a mixer and forget about it, as it will automatically be freed when it has reached the end, or when the source is removed from the mixer or when the mixer is freed.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.
            <para>If matrix mixing is enabled then the matrix will be initialized to place the source on the requested speaker(s), with downmixing also applied if the BASS_MIXER_DOWNMIX flag is specified. The <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> BASS_DEVICE_NOSPEAKER flag has effect here.</para>
            </description></item>
            </list>
            </param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Internally, a mixer will use the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> function to get data from its source channels.
            That means that the source channels must be decoding channels (not using a <see cref="T:Un4seen.Bass.RECORDPROC"/> in the case of a recording channel).
            Plugging a channel into more than one mixer at a time is not possible because the mixers would be taking data away from each other.
            An advantage of this is that there is no need for a mixer's handle to be provided with the channel functions.
            It is actually possible to plug a channel into multiple mixers via the use of <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32[])">splitter streams</see>.</para>
            <para>Channels are 'unplugged' using the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemove(System.Int32)"/> function. Channels are also automatically unplugged when they are freed.</para>
            <para>When mixing a channel, the mixer makes use of the channel's attributes (freq/volume/pan), as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/>. 
            The BASS_CONFIG_CURVE_VOL and BASS_CONFIG_CURVE_PAN config option settings are also used (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            <para>If a multi-channel stream has more channels than the mixer output, the extra channels will be discarded. For example, if a 5.1 stream is plugged into a stereo mixer, only the front-left/right channels will be retained. That is unless matrix mixing is used.</para>
            <para>The mixer processing is performed in floating-point, so it makes sense (for both quality and efficiency reasons) for the source channels to be floating-point too, though they do not have to be.
            It is also more efficient if the source channels have the same sample rate as the mixer output because no sample rate conversion is required then.
            When sample rate conversion is required, windowed sinc interpolation is used and the source's <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SRC"/> attribute determines how many points/samples are used in that, as follows:
            0 (or below) = 4 points, 1 = 8 points, 2 = 16 points, 3 = 32 points, 4 = 64 points, 5 = 128 points, 6 (or above) = 256 points. 8 points are used if the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SRC"/> attribute is unavailable (old BASS version).
            A higher number of points results in better sound quality (less aliasing and smaller transition band in the low-pass filter), but also higher CPU usage.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description><paramref name="channel"/> is not a decoding channel.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description><paramref name="channel"/> is already plugged into a mixer. It must be unplugged first.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            </list>
            </para>
            <para><b>Platform-specific:</b></para>
            <para>The sample rate conversion processing is limited to 128 points on iOS and Android. The mixer processing is also performed in fixed-point rather than floating-point on Android.</para>
            </remarks>
            <example>
            Create a new mixer stream at 44kHz, stereo using floats - out of two source streams:
            <code>
            // this will be the final mixer output stream being played
            int mixer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT );
            // now we need some channels to plug them in...create two decoding sources
            int streamA = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            int streamB = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                               BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            // finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            bool okA = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT);
            bool okB = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT);
            // and play it...
            Bass.BASS_ChannelPlay(mixer, false);
            </code>
            <code lang="vbnet">
            ' this will be the final mixer output stream being played
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(44100, 2, BASSFlag.BASS_SAMPLE_FLOAT)
            ' now we need some channels to plug them in...create two decoding sources
            Dim streamA As Integer = Bass.BASS_StreamCreateFile("testA.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim streamB As Integer = Bass.BASS_StreamCreateFile("testB.mp3", 0, 0, 
                                          BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' finally we plug them into the mixer (no downmix, since we assume the sources to be stereo)
            Dim okA As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_DEFAULT)
            Dim okB As Boolean = BassMix.BASS_Mixer_StreamAddChannel(mixer, streamB, BASSFlag.BASS_DEFAULT)
            ' and play it...
            Bass.BASS_ChannelPlay(mixer, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)">
            <summary>
            Plugs a channel into a mixer, optionally delaying the start and limiting the length.
            </summary>
            <param name="handle">The mixer handle.</param>
            <param name="channel">The handle of the channel to plug into the mixer... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIXER_MATRIX</term><description>Creates a channel matrix, allowing the source channels to be sent to any of the mixer output channels, at any levels. The matrix can be retrieved and modified via the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMatrix(System.Int32,System.Single[0:,0:])"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/> functions. The matrix will initially contain a one-to-one mapping, eg. left out = left in, right out = right in, etc... </description></item>
            <item><term>BASS_MIXER_DOWNMIX</term><description>Downmix to stereo, or mono if the mixer output is mono.</description></item>
            <item><term>BASS_MIXER_BUFFER</term><description>Buffer the sample data, for use by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>. This increases memory requirements, so should not be enabled needlessly. The size of the buffer can be controlled via the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option.</description></item>
            <item><term>BASS_MIXER_LIMIT</term><description>Limit the mixer processing to the amount of data available from this source, while the source is active (not ended). If the source stalls, then the mixer will too, rather than continuing to mix other sources, as it would normally do. This flag can only be applied to one source per mixer, so it will automatically be removed from any other source of the same mixer.</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Don't ramp-in the start, including after seeking (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). This is useful for gap-less playback, where a source channel is intended to seamlessly follow another. This does not affect volume and pan changes, which are always ramped.</description></item>
            <item><term>BASS_MIXER_PAUSE</term><description>Don't process the source channel (add it in a paused mode). Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> in order to toggle processing of the source channel.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the source channel when it ends. This allows you to add a channel to a mixer and forget about it, as it will automatically be freed when it has reached the end, or when the source is removed from the mixer or when the mixer is freed.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.
            <para>If matrix mixing is enabled then the matrix will be initialized to place the source on the requested speaker(s), with downmixing also applied if the BASS_MIXER_DOWNMIX flag is specified. The <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> BASS_DEVICE_NOSPEAKER flag has effect here.</para>
            </description></item>
            </list>
            </param>
            <param name="start">Delay (in bytes) before the channel is mixed in.</param>
            <param name="length">The maximum amount of data (in bytes) to mix... 0 = no limit. Once this end point is reached, the channel will be removed from the mixer.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function is identical to <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, but with the additional ability to specify a delay and duration for the channel.
            <para>The <paramref name="start"/> and <paramref name="length"/> parameters relate to the mixer output. So when calculating these values, use the mixer stream's sample format rather than the source channel's. 
            The start parameter is automatically rounded-down to the nearest sample boundary, while the length parameter is rounded-up to the nearest sample boundary.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description><paramref name="channel"/> is not a decoding channel.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description><paramref name="channel"/> is already plugged into a mixer. It must be unplugged first.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Add a channel to a mixer, delaying the start by 1 second and limiting the duration to 2 seconds:
            <code>
            long start = Bass.BASS_ChannelSeconds2Bytes(mixer, 1.0); // delay
            long length = Bass.BASS_ChannelSeconds2Bytes(mixer, 2.0); // duration
            // add the channel
            BassMix.BASS_Mixer_StreamAddChannelEx(mixer, channel, 0, start, length);
            </code>
            <code lang="vbnet">
            Dim start As Long = Bass.BASS_ChannelSeconds2Bytes(mixer, 1.0) ' delay
            Dim length As Long = Bass.BASS_ChannelSeconds2Bytes(mixer, 2.0) ' duration
            ' add the channel
            BassMix.BASS_Mixer_StreamAddChannelEx(mixer, channel, 0, start, length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamGetChannels(System.Int32,System.Int32[],System.Int32)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="splits"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamGetChannels(System.Int32)">
            <summary>
            Retrieves a mixer's source channels.
            </summary>
            <param name="handle">The mixer handle.</param>
            <returns>The array of mixer's source handles (<see langword="null"/> on error, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            To determine whether a particular channel is plugged in a mixer, it is simpler to use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMixer(System.Int32)"/> instead of this function.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid mixer handle.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamGetChannelCount(System.Int32)">
            <summary>
            Gets the number of a mixer's source channels.
            </summary>
            <param name="handle">The mixer handle.</param>
            <returns>The number of source handles (-1 on error, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid mixer handle.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            This overload uses an IntPtr to reference the buffer data.
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">Location to write the data as an <see cref="T:System.IntPtr"/> (can be <see cref="F:System.IntPtr.Zero"/> when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).
            <para>Use "Marshal.AllocCoTaskMem" to allocate a memory buffer, use "Marshal.Copy" to copy the buffer data from unmanaged BASS to your managed code and use "Marshal.FreeCoTaskMem" to free the memory buffer when not needed anymore.</para>
            <para>Or make use of a "GCHandle" to receive data to a pinned managed object.</para>
            </param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is being played by BASS, the returned data will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, 
            otherwise the channel's most recent data will be returned. The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option determines how far back data will be available from, 
            so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a mixer source channel.
            This overload uses a managed float[] to reference the buffer data as 32-bit!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_FLOAT!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (float[]) to receive the data, use BASS_SAMPLE_FLOAT when creating the channel stream!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is being played by BASS, the returned data will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, 
            otherwise the channel's most recent data will be returned. The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option determines how far back data will be available from, 
            so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a mixer source channel.
            This overload uses a managed short[] to reference the buffer data as 16-bit values - each element will represent one channel in this case!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (short[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is being played by BASS, the returned data will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, 
            otherwise the channel's most recent data will be returned. The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option determines how far back data will be available from, 
            so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a mixer source channel.
            This overload uses a managed int[] to reference the buffer data (Note: an int is 32-bit meaning if we expect to receive 16-bit data stereo a single int value will contain 2 x 16-bit, so a full stereo pair of data)!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (int[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples, an int value contains 2 channels (left and right)!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is being played by BASS, the returned data will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, 
            otherwise the channel's most recent data will be returned. The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option determines how far back data will be available from, 
            so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a mixer source channel.
            This overload uses a managed byte[] to reference the buffer data!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="buffer">The array (byte[]) to receive the data, e.g. when creating the channel with BASS_SAMPLE_8BITS!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the channel's buffer instead of decoding it from the channel, 
            which means that the mixer doesn't miss out on any data. In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is being played by BASS, the returned data will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, 
            otherwise the channel's most recent data will be returned. The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option determines how far back data will be available from, 
            so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="handle">The handle of the mixer source channel (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the level of the left channel is returned in the low word (low 16-bits, use <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/>), and the level of the right channel is returned in the high word (high 16-bits, use <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/>). If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but it gets the level from the channel's buffer instead of decoding data from the channel, which means that the mixer doesn't miss out on any data. 
            In order to do this, the source channel must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>If the mixer is being played by BASS, the returned level will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, 
            otherwise the channel's most recent data will be used to get the level. The <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_MIXER_BUFFER</see> config option determines how far back the level will be available from, 
            so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The mixer is not playing.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the left and right levels of a stereo channel:
            <code>
            BassMix.BASS_Mixer_StreamAddChannel(mixer, channel, BASSFlag.BASS_MIXER_BUFFER);
            int level = BassMix.BASS_Mixer_ChannelGetLevel(channel);
            int left = Utils.LowWord32(level); // the left level
            int right = Utils.HighWord32(level); // the right level
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_StreamAddChannel(mixer, channel, BASSFlag.BASS_MIXER_BUFFER)
            Dim level As Integer = BassMix.BASS_Mixer_ChannelGetLevel(channel)
            Dim left As Integer = Utils.LowWord32(level) ' the left level
            Dim right As Integer = Utils.HighWord32(level) ' the right level
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32,System.Single[],System.Single,Un4seen.Bass.BASSLevel)">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="levels">The array in which the levels are to be returned.</param>
            <param name="length">The amount of data to inspect to calculate the level, in seconds. The maximum is 1 second. 
            Less data than requested may be used if the full amount is not available, eg. if the source's buffer (determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_BUFFER"/> config option) is shorter.</param>
            <param name="flags">What levels to retrieve. One of the following (see <see cref="T:Un4seen.Bass.BASSLevel"/>):
            <list type="table">
            <item><term>BASS_LEVEL_ALL</term><description>Retrieves a separate level for each channel.</description></item>
            <item><term>BASS_LEVEL_MONO</term><description>Retrieve a single mono level.</description></item>
            <item><term>BASS_LEVEL_STEREO</term><description>Get a stereo level. The left level will be from the even channels, and the right level will be from the odd channels. If there are an odd number of channels then the left and right levels will both include all channels.</description></item>
            <item><term>BASS_LEVEL_RMS</term><description>Flag: Get the RMS level. Otherwise the peak level.</description></item>
            <item><term>BASS_LEVEL_VOLPAN</term><description>Apply the current BASS_ATTRIB_VOL and BASS_ATTRIB_PAN values to the level reading.</description></item>
            </list>
            </param>
            <returns>On success <see langword="true"/> is returned - else <see langword="false"/>, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the requested levels are returned in the <paramref name="levels"/> array.</para>
            </returns>
            <remarks>
            This function is like the standard <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>, but it gets the level from the channel's buffer instead of decoding data from the channel, 
            which means that the mixer does not miss out on any data. In order to do this, the source channel must have buffering enabled via the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_BUFFER"/> flag.
            <para>This function measures the level of the channel's sample data, not its level in the mixer output. 
            It includes the effect of any DSP/FX set on the channel, but not the effect of the channel's <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_VOL"/> or <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_PAN"/> attributes or matrix mixing or any envelope set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)"/>.</para>
            <para>If the mixer is being played by BASS, the returned level will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, otherwise the channel's most recent data will be used to get the level. 
            The <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_BUFFER"/> config option determines how far back the level will be available from, so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The mixer is not playing.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32,System.Single,Un4seen.Bass.BASSLevel)">
            <summary>
            Retrieves the level (peak amplitude) of a mixer source channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="length">The amount of data to inspect to calculate the level, in seconds. The maximum is 1 second. 
            Less data than requested may be used if the full amount is not available, eg. if the source's buffer (determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_BUFFER"/> config option) is shorter.</param>
            <param name="flags">What levels to retrieve. One of the following (see <see cref="T:Un4seen.Bass.BASSLevel"/>):
            <list type="table">
            <item><term>BASS_LEVEL_ALL</term><description>Retrieves a separate level for each channel.</description></item>
            <item><term>BASS_LEVEL_MONO</term><description>Retrieve a single mono level.</description></item>
            <item><term>BASS_LEVEL_STEREO</term><description>Get a stereo level. The left level will be from the even channels, and the right level will be from the odd channels. If there are an odd number of channels then the left and right levels will both include all channels.</description></item>
            <item><term>BASS_LEVEL_RMS</term><description>Flag: Get the RMS level. Otherwise the peak level.</description></item>
            <item><term>BASS_LEVEL_VOLPAN</term><description>Apply the current BASS_ATTRIB_VOL and BASS_ATTRIB_PAN values to the level reading.</description></item>
            </list>
            </param>
            <returns>On success the array of levels is returned - else <see langword="null"/>, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            </returns>
            <remarks>
            This function is like the standard <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>, but it gets the level from the channel's buffer instead of decoding data from the channel, 
            which means that the mixer does not miss out on any data. In order to do this, the source channel must have buffering enabled via the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_BUFFER"/> flag.
            <para>This function measures the level of the channel's sample data, not its level in the mixer output. 
            It includes the effect of any DSP/FX set on the channel, but not the effect of the channel's <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_VOL"/> or <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_PAN"/> attributes or matrix mixing or any envelope set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)"/>.</para>
            <para>If the mixer is being played by BASS, the returned level will be in sync with what is currently being heard from the mixer. 
            If another output system is being used, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option can be used to tell the mixer what the latency is so that it can be taken account of, otherwise the channel's most recent data will be used to get the level. 
            The <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_BUFFER"/> config option determines how far back the level will be available from, so it should be set high enough to cover any latency.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel does not have buffering (BASS_MIXER_BUFFER) enabled.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The mixer is not playing.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)">
            <summary>
            Modifies and/or retrieves a channel's mixer flags.
            </summary>
            <param name="handle">The handle of the mixer source channel to modify (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_MIXER_BUFFER</term><description>Buffer the sample data, for use by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>.</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Don't ramp-in the start, including after seeking (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). This is useful for gap-less playback, where a source channel is intended to seamlessly follow another. This does not affect volume and pan changes, which are always ramped.</description></item>
            <item><term>BASS_MIXER_PAUSE</term><description>Don't process the source channel (paused mode).</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the source channel when it ends. This allows you to add a channel to a mixer and forget about it, as it will automatically be freed when it has reached the end, or when the source is removed from the mixer or when the mixer is freed.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description>Speaker assignment flags.</description></item>
            </list>
            </param>
            <param name="mask">The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 (<see cref="F:Un4seen.Bass.BASSFlag.BASS_DEFAULT"/>) in order to just retrieve the current flags. 
            To modify the speaker flags, any of the BASS_SPEAKER_xxx flags can be used in the mask (no need to include all of them).</param>
            <returns>If successful, the channel's updated flags are returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function only deals with the channel's mixer related flags. The channel's standard flags, for example looping (BASS_SAMPLE_LOOP), are unaffected - use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/> to modify them.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // Disable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_MIXER_NORAMPIN, BASSFlag.BASS_MIXER_NORAMPIN);
            
            // Enable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_MIXER_NORAMPIN);
            </code>
            <code lang="vbnet">
            ' Disable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_MIXER_NORAMPIN, BASSFlag.BASS_MIXER_NORAMPIN)
            
            ' Enable ramping-in of a channel:
            BassMix.BASS_Mixer_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_MIXER_NORAMPIN)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPause(System.Int32)">
            <summary>
            Pauses a mixer source channel (don't process the source).
            </summary>
            <param name="handle">The handle of the mixer source channel to pause (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Use this method to pause a mixer source channel currently playing (which stops the mixer from processing that source). 
            Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPlay(System.Int32)"/> to resume a paused mixer source channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPlay(System.Int32)">
            <summary>
            Starts (or resumes) playback of a mixer source channel (process the source).
            </summary>
            <param name="handle">The handle of the mixer source channel to play (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If the mixer source channel is already playing this method has no effect - else it removes the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_PAUSE"/> flag from the mixer source channel.
            Use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelPause(System.Int32)"/> to pause a mixer source channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelIsActive(System.Int32)">
            <summary>
            Checks if a mixer source channel is active (playing) or paused.
            </summary>
            <param name="handle">The handle of the mixer source channel to check (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>The source is not active, or handle is not a valid mixer source channel.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>The source is playing.</description></item>
            <item><term>BASS_ACTIVE_PAUSED</term><description>The source is paused.</description></item>
            </list>
            </returns>
            <remarks>
            <para>BASS_ACTIVE_STOPPED will not automatically be returned once the end of the source mixer channel has been reached (unless you have specified <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_AUTOFREE"/> with the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/> method).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The mixer does not support the requested speaker(s), or the channel has matrix mixing enabled.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemove(System.Int32)">
            <summary>
            Unplugs a channel from a mixer.
            </summary>
            <param name="handle">The handle of the mixer source channel to unplug (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMixer(System.Int32)">
            <summary>
            Retrieves the mixer that a channel is plugged into.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/> beforehand).</param>
            <returns>If successful, the mixer stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)">
            <summary>
            Sets the playback position of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="pos">The position, in bytes. With MOD musics, the <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(order,row) method can be used to set the position in orders and rows instead of bytes.</param>
            <param name="mode">
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>The position is in bytes, which will be rounded down to the nearest sample boundary.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>The position is in orders and rows... use <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>. (HMUSIC only).</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Flag: Stop all notes. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Flag: Stop all notes and reset bpm/etc. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            <item><term>BASS_MIXER_NORAMPIN</term><description>Flag: Don't ramp-in the start after seeking. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_POS_MIXER_RESET</term><description>Flag: Flush the mixer's playback buffer, so that the new position is heard immediately in the mixer output. This generally should not be used when the mixer is playing multiple sources, as it will cause a skip in the sound of the other sources. This flag has no effect if the mixer has the BASS_STREAM_DECODE flag set, as the mixer does not have a playback buffer then.</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function works exactly like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except that it also resets things for the channel in the mixer,
            well as supporting the BASS_MIXER_NORAMPIN and BASS_POS_MIXER_RESET flag. See <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> for details.
            <para>For custom looping purposes (eg. in a mixtime SYNCPROC), the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> function should be used instead of this</para>
            <para>The playback buffer of the mixer can be flushed by using pos = 0.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is illegal.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Sets the position of a source stream to 35seconds:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            Reset the playback buffer of the mixer:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L);
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64)">
            <summary>
            Sets the playback position in bytes of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="pos">The position, in bytes. With MOD musics, the <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>(order,row) method can be used to set the position in orders and rows instead of bytes.
            <para>The playback buffer of the mixer can be flushed by using pos = 0.</para>
            </param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function works exactly like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except that it also resets things for the channel in the mixer,
            well as supporting the BASS_MIXER_NORAMPIN flag. See <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> for details.
            <para>For custom looping purposes (eg. in a mixtime SYNCPROC), the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> function should be used instead of this</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is illegal.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Sets the position of a source stream to 35seconds:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(streamA, Bass.BASS_ChannelSeconds2Bytes(streamA, 35.0));
            </code>
            Reset the playback buffer of the mixer:
            <code>
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L);
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetPosition(mixer, 0L)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)">
            <summary>
            Retrieves the playback position of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="mode">
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>Get the position in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>Get the position in orders and rows... LoWord = order, HiWord = row * scaler (<see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER"/>). (HMUSIC only).</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the position is returned.</returns>
            <remarks>
            This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, but it compensates for the mixer's buffering to return the source channel position that is currently being heard.
            So when used with a decoding channel (eg. a mixer source channel), this method will return the current decoding position.
            But if the mixer output is being played, then there is a playback buffer involved. This function compensates for that, to return the position that is currently being heard. 
            If the mixer is not being played by BASS, it is possible to account for any other output system latency with the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY"/> option or the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPositionEx(System.Int32,Un4seen.Bass.BASSMode,System.Int32)"/> function.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested position is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPositionEx(System.Int32,Un4seen.Bass.BASSMode,System.Int32)">
            <summary>
            Retrieves the playback position of a mixer source channel, optionally accounting for some latency.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="mode">How to retrieve the position. One of the following:
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>Get the position in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>Get the position in orders and rows... LoWord = order, HiWord = row * scaler (<see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER"/>). (HMUSIC only).</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <param name="delay">How far back (in bytes) in the mixer output to get the source channel's position from.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the channel's position is returned.</returns>
            <remarks>
            <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> compensates for the mixer's playback buffering to give the position that is currently being heard, but if the mixer is feeding some other output system, it will not know how to compensate for that.
            This function fills that gap by allowing the latency to be specified in the call. This functionality requires the mixer to keep a record of its sources' position going back some time, and that is enabled via the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_POSEX"/> flag when a mixer is created, with the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_POSEX"/> config option determining how far back the position record goes.
            If the mixer is not a decoding channel (not using the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag), then it will automatically have a position record at least equal to its playback buffer length.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested position mode is not available, or delay goes beyond where the mixer has record of the source channel's position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32)">
            <summary>
            Retrieves the playback position in bytes of a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, the position is returned.</returns>
            <remarks>
            This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, but it compensates for the mixer's buffering to return the source channel position that is currently being heard.
            So when used with a decoding channel (eg. a mixer source channel), this method will return the current decoding position.
            But if the mixer output is being played, then there is a playback buffer involved. This function compensates for that, to return the position that is currently being heard. 
            If the mixer itself is a decoding channel, then this function is identical to using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested position is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Sets a channel's mixing matrix, if it has one.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="matrix">The 2-dimensional array (float[,]) of the mixing matrix.</param>
            <returns>If successful, a <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Normally when mixing channels, the source channels are sent to the output in the same order - the left input is sent to the left output, and so on. Sometimes something a bit more complex than that is required. For example, if the source has more channels than the output, you may want to "downmix" the source so that all channels are present in the output. Equally, if the source has fewer channels than the output, you may want to "upmix" it so that all output channels have sound. Or you may just want to rearrange the channels. Matrix mixing allows all of these.</para>
            <para>A matrix mixer is created on a per-source basis (you can mix'n'match normal and matrix mixing), by using the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_MATRIX"/> and/or <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_DOWNMIX"/> flag when calling <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>. 
            The matrix itself is a 2-dimensional array of floating-point mixing levels, with the source channels on one axis, and the output channels on the other. Some simple examples are shown below.</para>
            <para>The Matrix layout:
            <list type="table">
            <item><term>Horizontal</term><description>The Input channels (e.g. 1,0 = left-on,right-off).</description></item>
            <item><term>Vertical</term><description>The Output channels (e.g. 1,0 = left-on,right-off).</description></item>
            </list>
            <code>
                   ---------> (Input)           ---------> (Input)
                  |    L  R                    |    L  R
                  | L  1  0                    |LF  1  0
                  | R  0  1                    |RF  0  1
                  v                            |LR  1  0
            (Output)                           |RR  0  1
                                               v
                                          (Output)
            </code>
            </para>
            <para>When streaming multi-channel sample data, the channel order of each sample is as follows:
            <list type="table">
            <item><term>3 channels</term><description>left-front, right-front, center.</description></item>
            <item><term>4 channels</term><description>left-front, right-front, left-rear/side, right-rear/side.</description></item>
            <item><term>6 channels(5.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side.</description></item>
            <item><term>8 channels(7.1)</term><description>left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</description></item>
            </list></para>
            <para>When using matrix mixing, the source channel's volume attribute still has effect, but the pan attribute doesn't. Whenever necessary, panning changes can be achieved by modifying the matrix.</para>
            <para>Do NOT use .Net jagged arrays, but only two-dimensional C-style arrays - as shown in the examples below!</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel is not using matrix mixing.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example shows how to use Matrix mixing (stereo to quad matrix):
            <code>
            // the source stream
            int streamA = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_STREAM_DECODE);
            // create a 4-channel mixer stream
            BASS_CHANNELINFO i = Bass.BASS_ChannelGetInfo(streamA);
            int mixer = BassMix.BASS_Mixer_StreamCreate(i.freq, 4, BASSFlag.BASS_DEFAULT );
            // add the source stream to the mixer with the matrix option
            BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_MIXER_MATRIX);
            // define a mixing matrix for the source stream
            float[,] matrix = { // stereo to quad matrix
            			{1, 0}, // left in = left front out
            			{0, 1}, // right in = right front out
            			{1, 0}, // left in = left rear out
            			{0, 1}  // right in = right rear out
            	       };
            // apply the matrix
            BassMix.BASS_Mixer_ChannelSetMatrix(streamA, matrix);
            // and play it
            Bass.BASS_ChannelPlay(mixer, false);
            </code>
            <code lang="vbnet">
            ' the source stream
            Dim streamA As Integer = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_STREAM_DECODE)
            ' create a 4-channel mixer stream
            Dim i As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(streamA)
            Dim mixer As Integer = BassMix.BASS_Mixer_StreamCreate(i.freq, 4, BASSFlag.BASS_DEFAULT)
            ' add the source stream to the mixer with the matrix option
            BassMix.BASS_Mixer_StreamAddChannel(mixer, streamA, BASSFlag.BASS_MIXER_MATRIX)
            ' define a mixing matrix for the source stream
            Dim matrix(,) As Single = { ' stereo to quad matrix
                                {1, 0}, ' left in = left front out
                                {0, 1}, ' right in = right front out
                                {1, 0}, ' left in = left rear out
                                {0, 1}  ' right in = right rear out
                               }
            BassMix.BASS_Mixer_ChannelSetMatrix(streamA, matrix)
            ' and play it
            Bass.BASS_ChannelPlay(mixer, False)
            </code>
            Here are some more matrix examples...
            <code lang="null">
            // In = stereo, Out = stereo
            float[,] matrix = { 
            		{1, 0}, // left out = left in
            		{0, 1}, // right out = right in
            	};
            
            // In = stereo, Out = swapped stereo
            float[,] matrix = { 
            		{0, 1}, // left out = right in
            		{1, 0}, // right out = left in
            	};
            
            // In = stereo, Out = mono
            float[,] matrix = { 
            		{0.5f, 0.5f} // mono out = half left + right in
            	};
            
            // In = stereo, Out = quadraphonic (4 channels)
            float[,] matrix = { // stereo to quad matrix
            			{1, 0}, // left-front out = left in
            			{0, 1}, // right-front out = right in
            			{1, 0}, // left rear out = left in
            			{0, 1}  // right rear out = right in
            	};
            
            // In = mono, Out = quadraphonic (4 channels)
            float[,] matrix = { // mono to quad matrix
              		       {1}, // left-front out = mono in
            			   {1}, // right-front out = mono in
            			   {1}, // left rear out = mono in
            			   {1}  // right rear out = mono in
            	};
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetMatrix(System.Int32,System.Single[0:,0:])">
            <summary>
            Retrieves a channel's mixing matrix, if it has one.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="matrix">The 2-dimentional array (float[,]) where to write the matrix.</param>
            <returns>If successful, a <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>For more details see <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetMatrix(System.Int32,System.Single[0:,0:])"/>. The array must be big enough to get the matrix.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The channel is not using matrix mixing.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the matrix of a stereo channel plugged into a quad mixer:
            <code>
            // you must initialize the array size correctly before getting the matrix!
            float[,] matrixGet = new float[4,2];
            BassMix.BASS_Mixer_ChannelGetMatrix(streamA, matrixGet);
            </code>
            <code lang="vbnet">
            ' you must initialize the array size correctly before getting the matrix!
            Dim matrixGet(4, 2) As Single
            BassMix.BASS_Mixer_ChannelGetMatrix(streamA, matrixGet)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)">
            <summary>
            Retrieves the current position and value of an envelope on a channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            </list>
            </param>
            <param name="value">A reference to a variable to receive the envelope value at the current position.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The envelope's current position is not necessarily what is currently being heard, due to buffering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no envelope of the requested type on the channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            float val = 0f;
            int pos = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                              BASSMIXEnvelope.BASS_MIXER_ENV_VOL, ref val);
            Console.WriteLine("Pos={0}, Val={1}", pos, val);
            </code>
            <code lang="vbnet">
            Dim val As Single = 0F
            Dim pos As Integer = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                                         BASSMIXEnvelope.BASS_MIXER_ENV_VOL, val)
            Console.WriteLine("Pos={0}, Val={1}", pos, val)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Object)">
            <summary>
            Retrieves the current position and value of an envelope on a channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            </list>
            </param>
            <param name="value">A reference to an object to receive the envelope value at the current position (<see langword="null"/> = don't retrieve it).</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The envelope's current position is not necessarily what is currently being heard, due to buffering.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no envelope of the requested type on the channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int pos = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                              BASSMIXEnvelope.BASS_MIXER_ENV_VOL, null);
            Console.WriteLine("Pos={0}", val);
            </code>
            <code lang="vbnet">
            Dim pos As Integer = BassMix.BASS_Mixer_ChannelGetEnvelope(source, 
                                         BASSMIXEnvelope.BASS_MIXER_ENV_VOL, Nothing)
            Console.WriteLine("Pos={0}", pos)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)">
            <summary>
            Sets the current position of an envelope on a channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to set the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            </list>
            </param>
            <param name="pos">The new envelope position, in bytes. If this is beyond the end of the envelope it will be capped or looped, depending on whether the envelope has looping enabled.</param>
            <returns>If successful, the current position of the envelope is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            During playback, the effect of changes are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_BUFFER</see> config option config option to reduce the buffer length.
            <para>Note: Envelopes deal in mixer positions, not sources!
            So when you are changing the source position (e.g. via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> the envelope's positions doesn't change with it.
            You might use this method to align the envelope position accorting to the new source position (see example below).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no envelope of the requested type on the channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Align the envelope position when seeking on the source:
            <code>
            // set a volume envelope on a source mixer channel (do this just once)
            BASS_MIXER_NODE[] nodes = 
              {
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3d), 1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5d), 0f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7d), 0f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9d), 1f)
              };
            BassMix.BASS_Mixer_ChannelSetEnvelope(source, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes);
            ...
            
            // change the source position and align the envelope position to it
            // pause mixer
            Bass.BASS_ChannelLock(mixer, true);
            BassMix.BASS_Mixer_ChannelSetPosition(source, newPos);
            // convert source pos to mixer pos 
            long envPos = Bass.BASS_ChannelSeconds2Bytes(mixer, Bass.BASS_ChannelBytes2Seconds(source, newPos));
            BassMix.BASS_Mixer_ChannelSetEnvelopePos(source, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, envPos);
            // resume mixer 
            Bass.BASS_ChannelLock(mixer, false);
            ...
            </code>
            <code lang="vbnet">
            Dim nodes As BASS_MIXER_NODE() =  
              {
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3.0), 1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5.0), 0F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7.0), 0F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9.0), 1F)
              }
            BassMix.BASS_Mixer_ChannelSetEnvelope(source, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes)
            ...
            
            ' change the source position and align the envelope position to it
            ' pause mixer
            Bass.BASS_ChannelLock(mixer, True)
            BassMix.BASS_Mixer_ChannelSetPosition([source], newPos)
            ' convert source pos to mixer pos 
            Dim envPos As Long = Bass.BASS_ChannelSeconds2Bytes(mixer, Bass.BASS_ChannelBytes2Seconds([source], newPos))
            BassMix.BASS_Mixer_ChannelSetEnvelopePos([source], BASSMIXEnvelope.BASS_MIXER_ENV_VOL, envPos)
            ' resume mixer 
            Bass.BASS_ChannelLock(mixer, False)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)">
            <summary>
            Sets an envelope to modify the sample rate, volume or pan of a channel over a period of time.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            <item><term>BASS_MIXER_ENV_LOOP</term><description>Loop the envelope. This is a flag and can be used in combination with any of the above.</description></item>
            </list>
            </param>
            <param name="nodes">The array of envelope nodes, which should have sequential positions.</param>
            <param name="count">The number of elements in the nodes array... 0 = no envelope.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            In the case of <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_FREQ</see> and <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_VOL</see>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_PAN</see> case, the final panning is a sum of the channel attribute and envelope.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)"/> can be used to get the current envelope position, 
            and a <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIXER_ENVELOPE</see> sync can be set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed of when an envelope ends. 
            The function can be called again from such a sync, in order to set a new envelope to follow the old one.</para>
            <para>Any previous envelope of the same type is replaced by the new envelope. A copy is made of the nodes array, so it does not need to persist beyond this function call.</para>
            <para>Note: Envelopes deal in mixer positions, not sources!
            You might use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)"/> to adjust the envelope to a source channel position.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set an envelope to bounce the pan position between left and right every 4 seconds:
            <code>
            BASS_MIXER_NODE[] nodes = 
              {
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 0d), 0f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 1d), -1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3d), 1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 4d), 0f)
              };
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN | BASSMIXEnvelope.BASS_MIXER_ENV_LOOP, nodes, 4);
            </code>
            <code lang="vbnet">
            Dim nodes As BASS_MIXER_NODE() =  
              {
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 0.0), 0F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 1.0), -1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3.0), 1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 4.0), 0F)
              }
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN | BASSMIXEnvelope.BASS_MIXER_ENV_LOOP, nodes, 4)
            </code>
            Remove any still available envelope nodes:
            <code>
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN, null, 0);
            </code>
            <code lang="vbnet">
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_PAN, Nothing, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[])">
            <summary>
            Sets an envelope to modify the sample rate, volume or pan of a channel over a period of time.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The envelope to get the position/value of. One of the following (see <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/>):
            <list type="table">
            <item><term>BASS_MIXER_ENV_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_MIXER_ENV_VOL</term><description>Volume.</description></item>
            <item><term>BASS_MIXER_ENV_PAN</term><description>Panning/balance.</description></item>
            <item><term>BASS_MIXER_ENV_LOOP</term><description>Loop the envelope. This is a flag and can be used in combination with any of the above.</description></item>
            </list>
            </param>
            <param name="nodes">The array of envelope nodes, which should have sequential positions (<see langword="null"/> = no envelope).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            In the case of <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_FREQ</see> and <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_VOL</see>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_PAN</see> case, the final panning is a sum of the channel attribute and envelope.</para>
            <para><see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)"/> can be used to get the current envelope position, 
            and a <see cref="T:Un4seen.Bass.BASSSync">BASS_SYNC_MIXER_ENVELOPE</see> sync can be set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed of when an envelope ends. 
            The function can be called again from such a sync, in order to set a new envelope to follow the old one.</para>
            <para>Any previous envelope of the same type is replaced by the new envelope. A copy is made of the nodes array, so it does not need to persist beyond this function call.</para>
            <para>Note: Envelopes deal in mixer positions, not sources!
            You might use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)"/> to adjust the envelope to a source channel position.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="type"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Volume curve envelope starting after 3 seconds, ending after 9 seconds:
            <code>
            BASS_MIXER_NODE[] nodes = 
              {
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3d), 1f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5d), 0.3f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7d), 0.5f),
                new BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9d), 1f)
              };
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes);
            </code>
            <code lang="vbnet">
            Dim nodes As BASS_MIXER_NODE() =  
              {
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 3.0), 1F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 5.0), 0.3F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 7.0), 0.5F), 
                New BASS_MIXER_NODE(Bass.BASS_ChannelSeconds2Bytes(_mixer, 9.0), 1F)
              }
            BassMix.BASS_Mixer_ChannelSetEnvelope(_channel, BASSMIXEnvelope.BASS_MIXER_ENV_VOL, nodes)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The type of sync (see <see cref="T:Un4seen.Bass.BASSSync"/> for details). This can be one of the standard sync types, as available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, or one of the mixer specific sync types listed below plus one of the following flags:
            <list type="table">
            <item><term>BASS_SYNC_ONETIME</term><description>Call the sync only once, and then remove it from the channel.</description></item>
            <item><term>BASS_SYNC_MIXTIME</term><description>Call the sync function when the sync occurs during decoding/mixing, instead of delaying the call until the sync is actually heard. This is automatically applied with decoding channels, as they can not be played/heard.</description></item>
            </list>
            </param>
            <param name="param">The sync parameters, depends on the sync type (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> or <see cref="T:Un4seen.Bass.BASSSync"/> for details).</param>
            <param name="proc">The callback function which should be invoked with the sync.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Sync types, with param and <see cref="T:Un4seen.Bass.SYNCPROC"/> data definitions:
            <list type="table">
            <item><term>BASS_SYNC_MIXER_ENVELOPE</term><description>Sync when an envelope ends. This is not triggered by looping envelopes.
            <para>param : envelope type to sync on, 0 = all types.</para>
            <para>data : envelope type.</para>
            </description></item>
            <item><term>BASS_SYNC_MIXER_ENVELOPE_NODE</term><description>Sync when an envelope reaches a new node.
            <para>param : envelope type to sync on, 0 = all types. data : LOWORD = envelope type, HIWORD = node number.</para>
            <para>data : LOWORD = envelope type, HIWORD = node number.</para>
            </description></item>
            <item><term>BASS_SYNC_STALL</term><description>This is like the standard BASS_SYNC_STALL sync, except it can be either mixtime or not.
            <para>param : not used.</para>
            <para>data : 0 = stalled, 1 = resumed.</para>
            </description></item>
            </list>
            <para>When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are automatically "mixtime", 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the BASS_SYNC_MIXTIME flag is used, then there is effectively no real difference between this function and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>.
            One sync type that is slightly different is the BASS_SYNC_STALL sync, which can be either mixtime or not.</para>
            <para>Sync types that would automatically be mixtime when using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are not so when using this function. 
            The BASS_SYNC_MIXTIME flag should be specified in those cases, or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> used instead.</para>
            <para>If the mixer itself is a decoding channel, or the BASS_SYNC_MIXTIME flag is used, then there is effectively no real difference between this function and BASS_ChannelSetSync, except for the mixer specific sync types listed above.</para>
            <para>When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it. Syncs set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are unaffected.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal <paramref name="param"/> was specified.</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.SYNCPROC"/> for an example on how to use synchronizers.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="type"></param>
            <param name="param"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSyncEx(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)">
            <summary>
            Sets up an extended synchronizer on a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>) beforehand).</param>
            <param name="type">The type of sync (see <see cref="T:Un4seen.Bass.BASSSync"/> for details). This can be one of the standard sync types, as available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, or one of the mixer specific sync types listed below plus one of the following flags:
            <list type="table">
            <item><term>BASS_SYNC_ONETIME</term><description>Call the sync only once, and then remove it from the channel.</description></item>
            <item><term>BASS_SYNC_MIXTIME</term><description>Call the sync function when the sync occurs during decoding/mixing, instead of delaying the call until the sync is actually heard. This is automatically applied with decoding channels, as they can not be played/heard.</description></item>
            </list>
            </param>
            <param name="param">The sync parameters, depends on the sync type (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> or <see cref="T:Un4seen.Bass.BASSSync"/> for details).</param>
            <param name="proc">The callback function which should be invoked with the sync.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Sync types, with param and <see cref="T:Un4seen.Bass.SYNCPROC"/> data definitions:
            <list type="table">
            <item><term>BASS_SYNC_MIXER_ENVELOPE</term><description>Sync when an envelope ends. This is not triggered by looping envelopes.
            <para>param : envelope type to sync on, 0 = all types.</para>
            <para>data : envelope type.</para>
            </description></item>
            <item><term>BASS_SYNC_MIXER_ENVELOPE_NODE</term><description>Sync when an envelope reaches a new node.
            <para>param : envelope type to sync on, 0 = all types. data : LOWORD = envelope type, HIWORD = node number.</para>
            <para>data : LOWORD = envelope type, HIWORD = node number.</para>
            </description></item>
            <item><term>BASS_SYNC_STALL</term><description>This is like the standard BASS_SYNC_STALL sync, except it can be either mixtime or not.
            <para>param : not used.</para>
            <para>data : 0 = stalled, 1 = resumed.</para>
            </description></item>
            </list>
            <para>The main difference between this method and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> is, that this method invokes the <see cref="T:Un4seen.Bass.AddOn.Mix.SYNCPROCEX"/> callback.
            This callback contains an extra 'offeset' parameter, which defines the position of the sync occurrence within the current update cycle of the source converted to the mixer stream position.
            This offset might be used to calculate more accurate non-mixtime sync triggers (as with non-mixtime sync's a variable delay is to be expected, as the accuracy depends on the sync thread waking in time, and there is no guarantee when that will happen) - 
            as well as mixtime syncs are only accurate to the current update period, as they are triggered within such.
            So a mixtime sync is being triggered ahead of the actual mixer position being heard. The 'offset' parameter might be used to compensate for that.</para>
            <para>When used on a decoding channel (eg. a mixer source channel), syncs set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are automatically "mixtime", 
            which means that they will be triggered as soon as the sync event is encountered during decoding. 
            But if the mixer output is being played, then there is a playback buffer involved, which will delay the hearing of the sync event. 
            This function compensates for that, delaying the triggering of the sync until the event is actually heard. 
            If the mixer itself is a decoding channel, or the BASS_SYNC_MIXTIME flag is used, then there is effectively no real difference between this function and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>.
            One sync type that is slightly different is the BASS_SYNC_STALL sync, which can be either mixtime or not.</para>
            <para>Sync types that would automatically be mixtime when using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are not so when using this function. 
            The BASS_SYNC_MIXTIME flag should be specified in those cases, or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> used instead.</para>
            <para>If the mixer itself is a decoding channel, or the BASS_SYNC_MIXTIME flag is used, then there is effectively no real difference between this function and BASS_ChannelSetSync, except for the mixer specific sync types listed above.</para>
            <para>When a source is removed from a mixer, any syncs that have been set on it via this function are automatically removed. 
            If the channel is subsequently plugged back into a mixer, the previous syncs will not still be set on it. Syncs set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> are unaffected.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The channel is not plugged into a mixer.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal <paramref name="param"/> was specified.</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.AddOn.Mix.SYNCPROCEX"/> for an example on how to use the extended synchronizer.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a mixer source channel.
            </summary>
            <param name="handle">The mixer source channel handle (as returned by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannel(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamAddChannelEx(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int64,System.Int64)"/>).</param>
            <param name="sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> call).</param>
            <returns>If succesful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function can only remove syncs that were set via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, not those that were set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="sync"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32[])">
            <summary>
            Creates a splitter stream (adds a reader channel to a decoding source channel).
            </summary>
            <param name="channel">The handle of the decoding source channel to split... a HMUSIC, HSTREAM or HRECORD (e.g. created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>).</param>
            <param name="flags">The channel falgs to be used to create the reader channel, any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Split the sample data, without playing it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPLIT_POS</term><description>The splitter's length and position is based on the splitter's (rather than the source's) channel count.</description></item>
            <item><term>BASS_SPLIT_SLAVE</term><description>Only get data from the splitter buffer, not directly from the source.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. These flags have no effect when the stream is more than stereo.</description></item>
            </list>
            </param>
            <param name="mapping">The target (readers) channel mapping definition, which is an array of source channel index values (0=1st channel, 1=2nd channel, 2=3rd channel, 3=4th channel etc.) ending with a final -1 element (use <see langword="null"/> to create a 1:1 reader).</param>
            <returns>If successful, the new reader stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            A "splitter" basically does the opposite of a mixer: it splits a single source into multiple streams rather then mixing multiple sources into a single stream. Like mixer sources, splitter sources must be decoding channels.
            <para>The splitter stream will have the same sample rate and resolution as its source, but it can have a different number of channels, as dictated by the mapping parameter. 
            Even when the number of channels is different (and so the amount of data produced is different), <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> will give the source length, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> will give the source position that is currently being output by the splitter stream, unless the BASS_SPLIT_POS flag is used. The BASS_SPLIT_POS flag can be toggled at any time via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>All splitter streams with the same source share a buffer to access its sample data. 
            The length of the buffer is determined by the <see cref="T:Un4seen.Bass.BASSConfig">BASS_CONFIG_SPLIT_BUFFER</see> config option; the splitter streams should not be allowed to drift apart beyond that, otherwise those left behind will suffer buffer overflows. 
            A splitter stream's buffer state can be reset via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamReset(System.Int32)"/>; that can also be used to reset a splitter stream that has ended, so that it can be played again.</para>
            <para>If the BASS_SPLIT_SLAVE flag is used, the splitter stream will only receive data from the buffer and will not request more data from the source, so it can only receive data that has already been received by another splitter stream with the same source. The BASS_SPLIT_SLAVE flag can be toggled at any time via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>When <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> is used on a splitter stream, its source will be set to the requested position and the splitter stream's buffer state will be reset so that it immediately receives data from the new position. 
            The position change will affect all of the source's splitter streams, but the others will not have their buffer state reset; they will continue to receive any buffered data before reaching the data from the new position. 
            <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamReset(System.Int32)"/> can be used to reset the buffer state.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> with a splitter channel to remove it from the source.
            When a source is freed, all of its splitter streams are automatically freed.</para>
            <para>The <paramref name="mapping"/> array defines the channel number to be created for the reader as well as which source channels should be used for each.
            This enables you to create a reader stream which extract certain source channels (e.g. create a mono reader based on a stereo source), remaps the channel order (e.g. swap left and right in the reader) or even contains more channels than the source (e.g. create a 5.1 reader based on a stereo source).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_HANDLE</term><description>The <paramref name="channel"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The <paramref name="channel"/> is not a decoding channel.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="mapping"/> contains an invalid channel index.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding streams (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported (ie. no WDM drivers).</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The device/drivers do not support the requested speaker(s), or you're attempting to assign a stereo stream to a mono speaker.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficent memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Couldn't initialize 3D support for the stream.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            </remarks>
            <example>
            Create two 1:1 clones:
            <code>
            int source = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_STREAM_DECODE);
            int reader1 = BassMix.BASS_Split_StreamCreate(source, BASSFlag.BASS_SAMPLE_FLOAT, null);
            int reader2 = BassMix.BASS_Split_StreamCreate(source, BASSFlag.BASS_SAMPLE_FLOAT, null);
            ...
            </code>
            <code lang="vbnet">
            Dim source As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_STREAM_DECODE)
            Dim reader1 As Integer = BassMix.BASS_Split_StreamCreate(source, BASSFlag.BASS_SAMPLE_FLOAT, Nothing)
            Dim reader2 As Integer = BassMix.BASS_Split_StreamCreate(source, BASSFlag.BASS_SAMPLE_FLOAT, Nothing)
            ...
            </code>
            Here are some more channel mapping examples...
            <code lang="null">
            // create a mono reader containing only the right channel based on a stereo source
            int[] mapping = {1,-1};
            
            // create a stereo reader which swaps the left and right channel of the stereo source
            int[] mapping = {1,0,-1};
            
            // create a quad-channel reader based on a stereo source
            int[] mapping = {0,1,0,1,-1};
            
            // create a sterao reader based on a mono source
            int[] mapping = {0,0,-1};
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamGetSource(System.Int32)">
            <summary>
            Retrieves the source of a splitter stream.
            </summary>
            <param name="handle">The splitter stream handle (which was add via <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32[])"/> beforehand).</param>
            <returns>If successful, the source stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The <paramref name="handle"/> is not a splitter stream.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamReset(System.Int32)">
            <summary>
            Resets a splitter stream or all splitter streams of a source.
            </summary>
            <param name="handle">The splitter (as obtained by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32[])"/>) or the source channel handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function resets the splitter stream's buffer state, so that the next sample data it receives will be from the source's current position. 
            If the stream has ended, that is reset too, so that it can be played again. Unless called from within a mixtime sync callback, the stream's output buffer (if it has one) is also flushed.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The <paramref name="handle"/> is neither a splitter stream or source.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamResetEx(System.Int32,System.Int32)">
            <summary>
            Resets a splitter stream and sets its position in the source buffer.
            </summary>
            <param name="handle">The splitter (as obtained by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32[])"/>) or the source channel handle.</param>
            <param name="offset">How far back (in bytes) to position the splitter in the source buffer. This is based on the source's sample format, which may have a different channel count to the splitter.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function is the same as <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamReset(System.Int32)"/> except that it also provides the ability to position the splitter stream within the buffer that is shared by all of the splitter streams of the same source.
            A splitter stream's buffer position determines what data it will next receive. For example, if its position is half a second back, it will receive half a second of buffered data before receiving new data from the source.
            Calling this function with offset = 0 will result in the next data that the splitter stream receives being new data from the source, and is identical to using <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamReset(System.Int32)"/>.
            <para><paramref name="offset"/> is automatically limited to the amount of data that the source buffer contains, which is in turn limited to the buffer size, determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SPLIT_BUFFER"/> config option.
            The amount of source data buffered, as well as a splitter stream's position within it, is available from <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamGetAvailable(System.Int32)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The <paramref name="handle"/> is neither a splitter stream or source.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamGetSplits(System.Int32,System.Int32[],System.Int32)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="splits"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamGetSplits(System.Int32)">
            <summary>
            Retrieves the channel's splitters.
            </summary>
            <param name="handle">The handle to check.</param>
            <returns>The array of splitter handles (<see langword="null"/> on error, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamGetAvailable(System.Int32)">
            <summary>
            Retrieves the amount of buffered data available to a splitter stream, or the amount of data in a splitter source buffer.
            </summary>
            <param name="handle">The splitter (as obtained by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32[])"/>) or the source channel handle.</param>
            <returns>If successful, then the amount of buffered data (in bytes) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            With a splitter source, this function reports how much data is in the buffer that is shared by all of its splitter streams. With a splitter stream, this function reports how much data is ahead of it in the buffer, before it will receive any new data from the source.
            A splitter stream can be repositioned within the buffer via the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamResetEx(System.Int32,System.Int32)"/> function.
            <para>The amount of data that can be buffered is limited by the buffer size, which is determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SPLIT_BUFFER"/> config option.</para>
            <para>The returned buffered byte count is always based on the source's sample format, even with splitter streams that were created with a different channel count.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>The <paramref name="handle"/> is neither a splitter stream or source.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Create two 1:1 clones:
            <code>
            // create a new splitter
            int newsplit = BassMix.BASS_Split_StreamCreate(source, ...);
            // get the amount of data an existing splitter has buffered
            int offset = BassMix.BASS_Split_StreamGetAvailable(oldsplit);
            // add the amount in its playback buffer
            offset += BASS_ChannelGetData(oldsplit, null, BASSData.BASS_DATA_AVAILABLE);
            // reset the new splitter to that far back in the source buffer
            BassMix.BASS_Split_StreamResetEx(newsplit, offset);
            // start playing it
            Bass.BASS_ChannelPlay(newsplit, false);
            </code>
            <code lang="vbnet">
            ' create a new splitter
            Dim newsplit As Integer = BassMix.BASS_Split_StreamCreate(source, 0)
            ' get the amount of data an existing splitter has buffered
            Dim offset As Integer = BassMix.BASS_Split_StreamGetAvailable(oldsplit)
            ' add the amount in its playback buffer
            offset += BASS_ChannelGetData(oldsplit, Nothing, BASSData.BASS_DATA_AVAILABLE)
            ' reset the new splitter to that far back in the source buffer
            BassMix.BASS_Split_StreamResetEx(newsplit, offset)
            ' start playing it
            Bass.BASS_ChannelPlay(newsplit, False)
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BassMix.BASSMIXVERSION">
            <summary>
            Current BASSmix version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">
            <summary>
            Mixer envelope attribute types, used with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Single@)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelopePos(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,System.Int64)"/> to set/retrieve an envelope on a mixer source channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_FREQ">
            <summary>
            Sample rate.
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final sample rate is the product of the channel attribute and the envelope.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_VOL">
            <summary>
            Volume.
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final volume is the product of the channel attribute and the envelope.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_PAN">
            <summary>
            Panning/Balance.
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            The final panning is a sum of the channel attribute and envelope.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope.BASS_MIXER_ENV_LOOP">
            <summary>
            Loop the envelope (flag).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetEnvelope(System.Int32,Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope,Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE[],System.Int32)"/> to set an envelope on a mixer source channel.
            </summary>
            <remarks>
            <para>Envelopes are applied on top of the channel's attributes, as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            In the case of <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_FREQ</see> and <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_VOL</see>, 
            the final sample rate and volume is a product of the channel attribute and the envelope. 
            While in the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope">BASS_MIXER_ENV_PAN</see> case, the final panning is a sum of the channel attribute and envelope.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.pos">
            <summary>
            The postion of the node in bytes. This is based on the mixer's sample format, not the source channel's format!
            </summary>
            <remarks>Note: Envelopes deal with mixer positions, not sources!</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.val">
            <summary>
            The envelope value at the position.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.#ctor(System.Int64,System.Single)">
            <summary>
            Constructor to initialize the members.
            </summary>
            <param name="Pos">The postion of the node in bytes. This is based on the mixer's sample format, not the source channel's format.</param>
            <param name="Val">The envelope value at the position.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mix.BASS_MIXER_NODE.ToString">
            <summary>
            A description of the mixer envelope node (position, value).
            </summary>
            <returns>A description of the mixer envelope node (position, value).</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mix.SYNCPROCEX">
            <summary>
            User defined extended mixer synchronizer callback function (see <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSyncEx(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)"/> for details).
            </summary>
            <param name="handle">The sync handle that has occured (as returned by <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelSetSyncEx(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.AddOn.Mix.SYNCPROCEX,System.IntPtr)"/>).</param>
            <param name="channel">The channel that the sync occured on (the mixer source channel).</param>
            <param name="data">Additional data associated with the sync's occurance.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> was called.</param>
            <param name="offset">The offset in bytes containing the position of the sync occurrence within the update cycle converted to the mixer stream.</param>
            <remarks>
            <para>A sync callback function should be very quick as other syncs can't be processed until it has finished. Attribute slides (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/>) are also performed by the sync thread, so are also affected if a sync callback takes a long time.</para>
            <para>If the sync is a "mixtime" sync (BASS_SYNC_MIXTIME), then depending on the sync type, the callback will be executed in the update thread.
            The <paramref name="offset"/> specifies the position of the sync within the update buffer converted to the mixer stream position.
            Note that the <paramref name="offset"/> is based on the mixer's sample format, so you'll need to convert that to the source's format if using the sync to trigger things on the source.</para>
            <para>The usual restrictions on which BASS functions can be called that apply to stream callbacks (<see cref="T:Un4seen.Bass.STREAMPROC"/>) also apply here. 
            It is also unsafe to call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> on the same channel from a mixtime sync callback. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be used in a mixtime sync to implement custom looping, eg. set a BASS_SYNC_POS sync at the loop end position and seek to the loop start position in the callback.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Mpc.BassMpc">
            <summary>
            BASS.NET API wrapper for BASS_MPC.DLL
            <para>Requires: bass_mpc.dll - MusePack Audio Codec (MPC) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_MPC is an extension to the BASS audio library, enabling the playback of MusePack files.</para>
            <para>MusePack is an audio compression format with a strong emphasis on high quality. It's not lossless, but it is designed for transparency, so that you won't be able to hear differences between the original lossless file and the much smaller MPC. It is based on the MPEG 1 Layer II algorithms, but has rapidly developed and vastly improved and is now at an advanced stage in which it contains heavily optimized and patentless code.</para>
            <para>The MusePack format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /User functions.</para>
            <para>More information can be found on <a href="http://www.musepack.net">www.musepack.net</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a MusePack Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a MusePack Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a MusePack Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file function (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Mpc.BassMpc.BASS_MPC_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a MPC file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.
            <para>Seeking is only possible once the entire file has been downloaded.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mpc.BassMpc.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_mpc.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Mpc.BassMpc.SupportedStreamName">
            <summary>
            Supported file format name of the bass_mpc.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Opus.BassOpus">
            <summary>
            BASS.NET API wrapper for BASSOPUS.DLL
            <para>Requires: bassopus.dll - Opus Interactive Audio Codec (OPUS) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSOPUS is an extension to the BASS audio library, enabling the playing of Opus (Opus Interactive Audio Codec) encoded files.</para>
            <para>The OPUS format is used in very much the same way as any of the built-in BASS stream formats - simply call the OPUS stream creation function instead of the BASS built-in functions. The BASS plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>) is also supported.</para>
            <para>More information can be found on <a href="http://www.opus-codec.org/">opus-codec.org</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a OPUS file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a OPUS memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a OPUS file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Opus.BassOpus.BASS_OPUS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a OPUS file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Opus.BassOpus.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bassopus.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Opus.BassOpus.SupportedStreamName">
            <summary>
            Supported file format name of the bassopus.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Spx.BassSpx">
            <summary>
            BASS.NET API wrapper for BASS_SPX.DLL
            <para>Requires: bass_spx.dll - Speex Audio Codec (SPX) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_SPX is an extension to the BASS audio library, enabling the playback of Speex files.</para>
            <para>Speex is an open source and patent-free audio compression format designed for speech. The Speex Project aims to lower the barrier of entry for voice applications by providing a free alternative to expensive proprietary speech codecs. 
            Moreover, Speex is well-adapted to Internet applications and provides useful features that are not present in most other codecs.</para>
            <para>The Speex format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/URL/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> /URL/User functions.</para>
            <para>More information can be found on <a href="http://www.speex.org">www.speex.org</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Speex Audio file.
            <para>This overload implements UNICODE filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a Speex Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a Speex Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Spx.BassSpx.BASS_SPX_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from a Speex Audio file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Spx.BassSpx.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_spx.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Spx.BassSpx.SupportedStreamName">
            <summary>
            Supported file format name of the bass_spx.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.BassTags">
            <summary>
            Internal Tag support of the BASS.NET API .
            <para>Requires: bass.dll - for better Tag reading support.</para>
            </summary>
            <remarks>
            <para>The BASS audio library has limited support for reading tags, associated with a stream. 
            This class extends that functionality, allowing you to extract specific TAG information from a stream or file. 
            The extracted tag values are formatted into a general <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class structure.</para>
            <para>Supported tags are ID3v1, ID3v2, WMA, OGG, RIFF, BWF, MOD, MP4, MF and APE and are evaluated as followed:</para>
            <para>MP3, MP2, MP1: first ID3v2, then ID3v1, then APE, then BWF.</para>
            <para>OGG: first OGG, then APE.</para>
            <para>WMA: only WMA.</para>
            <para>MP4, AAC: first MP4, then ID3v2, then APE, then OGG</para>
            <para>WAV: RIFF_INFO, then BWF, then ID3v2</para>
            <para>all others: first APE, then OGG, then ID3v2, then ID3v1.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.BassTags.ReadPictureTAGs">
            <summary>
            Gets or Sets, if picture tags should be read.
            </summary>
            <remarks>Set this value to <see langword="false"/> to not read any picture tags with e.g. the <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> methods.
            The default is <see langword="true"/>.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.BassTags.EvalNativeTAGs">
            <summary>
            Gets or Sets, if native tags should be stored.
            </summary>
            <remarks>Set this value to <see langword="false"/> to not store any native tags with e.g. the <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> methods.
            The default is <see langword="true"/>.
            Note: This option does NOT apply to Riff BEXT and CART tags (see <see cref="F:Un4seen.Bass.AddOn.Tags.BassTags.EvalNativeTAGsBEXT"/> and <see cref="F:Un4seen.Bass.AddOn.Tags.BassTags.EvalNativeTAGsCART"/>).</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.BassTags.EvalNativeTAGsBEXT">
            <summary>
            Gets or Sets, if native Riff BEXT tags should be stored.
            </summary>
            <remarks>Set this value to <see langword="false"/> to not store native Riff BEXT tags with e.g. the <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> methods.
            The default is <see langword="true"/>.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.BassTags.EvalNativeTAGsCART">
            <summary>
            Gets or Sets, if native Riff CART tags should be stored.
            </summary>
            <remarks>Set this value to <see langword="false"/> to not store native Riff CART tags with e.g. the <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> methods.
            The default is <see langword="true"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)">
            <summary>
            Retrieves the requested tags/headers from a file, if they are available.
            </summary>
            <param name="file">The fully qualified name of the file stream to get the TAG information from.</param>
            <returns>Returns a new <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance if successful. If TAGs could be retrieved successfully <see langword="null"/> is returned.</returns>
            <remarks>
            <para>Note: This method uses the BASS plug-in system and such supports all formats which are supported by BASS or any of its add-ons.
            So make sure to load all needed add-ons via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.</para>
            <para>This method first evaluates the file name extension. If using with a ".wma" or ".wmv" file and you are using the WMA DRM version, the WMA tags are received immediately.
            For all other file types an internal stream handle is created by using the plug-in system and calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. If successful, the TAG_INFO is returned via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> (see overload list).
            All members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated. However, some files and tag structures might not support all members.
            This overload 
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            Getting TAGs from a file directly:
            <code>
            TAG_INFO tagInfo = BassTags.BASS_TAG_GetFromFile(fileName);
            if ( tagInfo != null )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            Dim tagInfo As TAG_INFO = BassTags.BASS_TAG_GetFromFile(fileName)
            If Not (tagInfo Is Nothing) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String,System.Boolean,System.Boolean)">
            <summary>
            Retrieves the requested tags/headers from a file, if they are available.
            </summary>
            <param name="file">The fully qualified name of the file stream to get the TAG information from.</param>
            <param name="setDefaultTitle">If <see langword="true"/> the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> property will be set to a default value (filename without extension).</param>
            <param name="prescan">If <see langword="true"/> the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN"/> flag is used to return an exact <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> value - else the duration might just be good approximation, but the method will perform faster.</param>
            <returns>Returns a new <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance if successful. If <paramref name="file"/> could not be found <see langword="null"/> is returned.</returns>
            <remarks>
            <para>Note: This method uses the BASS plug-in system and such supports all formats which are supported by BASS or any of its add-ons.
            So make sure to load all needed add-ons via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.</para>
            <para>This method first evaluates the file name extension. If using with a ".wma" or ".wmv" file and you are using the WMA DRM version, the WMA tags are received immediately.
            For all other file types an internal stream handle is created by using the plug-in system and calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. If successful, the TAG_INFO is returned via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> (see overload list).
            All members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated. However, some files and tag structures might not support all members.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            Getting TAGs from a file directly:
            <code>
            TAG_INFO tagInfo = BassTags.BASS_TAG_GetFromFile(fileName, true, true);
            if ( tagInfo != null )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            Dim tagInfo As TAG_INFO = BassTags.BASS_TAG_GetFromFile(fileName, True, True)
            If Not (tagInfo Is Nothing) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String,System.Boolean,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Retrieves the requested tags/headers from a file, if they are available.
            </summary>
            <param name="file">The fully qualified name of the file stream to get the TAG information from.</param>
            <param name="prescan">If <see langword="true"/> the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN"/> flag is used to return an exact <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> value - else the duration might just be good approximation, but the method will perform faster.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class where to put the data.</param>
            <returns>If TAGs could be retrieved successfully <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
            <remarks>
            <para>Note: This method uses the BASS plug-in system and such supports all formats which are supported by BASS or any of its add-ons.
            So make sure to load all needed add-ons via <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>.</para>
            <para>This method first evaluates the file name extension. If using with a ".wma" or ".wmv" file and you are using the WMA DRM version, the WMA tags are received immediately.
            For all other file types an internal stream handle is created by using the plug-in system and calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. If successful, the TAG_INFO is returned via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> (see overload list).
            Only those members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated which have been found in the file. However, some files and tag structures might not support all members.
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            Getting TAGs from a file directly:
            <code>
            TAG_INFO tagInfo = BassTags.BASS_TAG_GetFromFile(fileName, true, true);
            if ( tagInfo != null )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            Dim tagInfo As TAG_INFO = BassTags.BASS_TAG_GetFromFile(fileName, True, True)
            If Not (tagInfo Is Nothing) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.Int32,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Retrieves the requested tags/headers from a stream channel, if they are available.
            </summary>
            <param name="stream">The stream channel to get the TAG information from.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class where to put the data.</param>
            <returns>If TAGs could be retrieved successfully <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
            <remarks>
            <para>This method first evaluates the BASS_CTYPE_xxx for the stream, by calling the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> function internally.
            Based on the retrieved <see cref="T:Un4seen.Bass.BASSChannelType"/> a call to the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> function is made in order to retrieve the pointer to the tags/header data - if available.
            Finally this tag pointer is evaluated and the related tag/header data is evaluated.</para>
            <para>This method is able to retrieve the following TAGs:
            <list type="table">
            <item><term>MP3, MP2, MP1</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_ID3, then BASS_TAG_APE, then BASS_TAG_RIFF_BEXT.</description></item>
            <item><term>OGG, FLAC, OPUS</term><description>BASS_TAG_OGG first, then BASS_TAG_APE</description></item>
            <item><term>WAV, BWF</term><description>BASS_TAG_RIFF_INFO first, then BASS_TAG_RIFF_BEXT.</description></item>
            <item><term>MF</term><description>BASS_TAG_MF.</description></item>
            <item><term>WMA</term><description>BASS_TAG_WMA</description></item>
            <item><term>MP4, AAC, ALAC</term><description>BASS_TAG_MP4 first, then BASS_TAG_ID3V2, then BASS_TAG_APE</description></item>
            <item><term>APE, MPC, OFR, WV</term><description>BASS_TAG_APE first, then BASS_TAG_ID3V2, then BASS_TAG_ID3</description></item>
            <item><term>WINAMP</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_APE</description></item>
            <item><term>SPX, AC3</term><description>not available</description></item>
            <item><term>MOD</term><description>MOD music name and message are evaluated only.</description></item>
            </list>
            All members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated. However, some files and tag structures might not support all members.
            </para>
            <para>The following TAGs are combined in the following order (if multiple TAGs are found):
            <list type="table">
            <item><term>BASS_TAG_ID3V2</term><description>BASS_TAG_ID3 + BASS_TAG_APE + BASS_TAG_ID3V2</description></item>
            <item><term>BASS_TAG_ID3</term><description>BASS_TAG_APE + BASS_TAG_ID3</description></item>
            <item><term>BASS_TAG_WMA</term><description>BASS_TAG_WMA</description></item>
            <item><term>BASS_TAG_OGG</term><description>BASS_TAG_APE + BASS_TAG_OGG</description></item>
            <item><term>BASS_TAG_APE</term><description>BASS_TAG_ID3 + BASS_TAG_APE</description></item>
            <item><term>BASS_TAG_MP4</term><description>BASS_TAG_APE + BASS_TAG_ID3V2 + BASS_TAG_MP4</description></item>
            <item><term>BASS_TAG_RIFF_INFO</term><description>BASS_TAG_RIFF_BEXT + BASS_TAG_RIFF_CART + BASS_TAG_ID3V2 + BASS_TAG_RIFF_INFO</description></item>
            </list>
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported tag version detected.</exception>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in tag data.</exception>
            <example>
            <code>
            // create a stream
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, BASSFlag.BASS_DEFAULT);
            // update the tags
            TAG_INFO tagInfo = new TAG_INFO(fileName);
            if ( BassTags.BASS_TAG_GetFromFile( stream, tagInfo) )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            ' create a stream
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tagInfo As New TAG_INFO(fileName)
            If BassTags.BASS_TAG_GetFromFile(stream, tagInfo) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromURL(System.Int32,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Retrieves the requested tags/headers from a URL stream, if they are available.
            </summary>
            <param name="stream">The stream to get the TAG information from.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> class where to put the data.</param>
            <returns>If TAGs could be retrieved successfully <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
            <remarks>
            <para>This method first tries to get streaming header information via BASS_TAG_ICY and BASS_TAG_HTTP.
            Then it tries the following tags in that order: BASS_TAG_META, BASS_TAG_OGG, BASS_TAG_APE and BASS_TAG_WMA.</para>
            <para>This method is able to retrieve the following TAGs:
            <list type="table">
            <item><term>Shoutcast streaming</term><description>BASS_TAG_ICY and BASS_TAG_META</description></item>
            <item><term>Icecast streaming</term><description>BASS_TAG_HTTP and BASS_TAG_OGG</description></item>
            <item><term>WMA streaming</term><description>Use <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> instead, since WMA URL stream are created with the file method.</description></item>
            <item><term>APE streaming</term><description>BASS_TAG_HTTP and BASS_TAG_APE</description></item>
            </list>
            </para>
            The following members of the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure will be updated:
            <list type="table">
            <item><term>title</term><description>With the detected new stream title, if found.
            <para>Note: The 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be split at the first occurence of a " - " seperator.</para></description></item>
            <item><term>artist</term><description>With the detected new artist, if found.
            <para>Note: For Shoutcast stream this will be set as the 'streamtile' will splitted.</para></description></item>
            <item><term>album</term><description>With the detected name of the stream, if found (eg. icy-name).</description></item>
            <item><term>genre</term><description>With the detected genre of the stream, if found (eg. icy-genre).</description></item>
            <item><term>comment</term><description>With the detected new stream url, if found (eg. icy-url).</description></item>
            <item><term>year</term><description>With the detected bitrate, if found (only used with shoutcast streams, eg. icy-br).</description></item>
            </list>
            </remarks>
            <example>
            <code>
            // create a stream
            int stream = BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, null, 0);
            // update the tags
            TAG_INFO tagInfo = new TAG_INFO(url);
            if ( BassTags.BASS_TAG_GetFromURL( stream, tagInfo) )
            {
              // display the tags...
            }
            </code>
            <code lang="vbnet">
            ' create a stream
            Dim stream As Integer = BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, Nothing, 0)
            ' update the tags
            Dim tagInfo As New TAG_INFO(url)
            If BassTags.BASS_TAG_GetFromURL(stream, tagInfo) Then
              ' display the tags...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetIntPtr(System.Int32,Un4seen.Bass.BASS_CHANNELINFO,Un4seen.Bass.BASSTag@)">
            <summary>
            Gets an IntPtr to the memory block containing the meta tag data.
            </summary>
            <param name="stream">The stream to get the tags from.</param>
            <param name="info">The <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure containing the CTYPE, which will be used to find the tags.</param>
            <param name="tagType">Returns the detected <see cref="T:Un4seen.Bass.BASSTag"/> type.</param>
            <returns>An <see cref="T:System.IntPtr"/> to the tag memory block, or <see cref="F:System.IntPtr.Zero"/> if no tags could be found.</returns>
            <remarks>
            This method supports the following tags, which are evaluated in the following order:
            <list type="table">
            <item><term>MP3, MP2, MP1</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_ID3, then BASS_TAG_RIFF_BEXT</description></item>
            <item><term>OGG</term><description>BASS_TAG_OGG first, then BASS_TAG_APE</description></item>
            <item><term>WMA</term><description>BASS_TAG_WMA</description></item>
            <item><term>MP4, AAC, ALAC</term><description>BASS_TAG_MP4 first, then BASS_TAG_ID3V2, then BASS_TAG_APE, then BASS_TAG_OGG</description></item>
            <item><term>APE, FLAC, MPC, OFR, WV</term><description>BASS_TAG_APE first, then BASS_TAG_OGG, then BASS_TAG_ID3V2, then BASS_TAG_ID3</description></item>
            <item><term>WINAMP</term><description>BASS_TAG_ID3V2 first, then BASS_TAG_APE, then BASS_TAG_OGG</description></item>
            <item><term>WAV, SPX, AC3</term><description>not available</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.ReadID3v1(System.IntPtr,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Reads an ID3v1 tag structure.
            </summary>
            <param name="p">The pointer to the ID3v1 structure.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance to read the tag values into.</param>
            <returns>If TAGs could be retrieved successfully <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.BassTags.ReadID3v2(System.IntPtr,Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Reads an ID3v2 tag structure.
            </summary>
            <param name="p">The pointer to the ID3v2 structure.</param>
            <param name="tags">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance to read the tag values into.</param>
            <returns>If TAGs could be retrieved successfully <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.BassTags.ID3v1Genre">
            <summary>
            Contains a list of ID3v1 audio generes.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TAG_INFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve information on the current tags of a stream.
            </summary>
            <remarks>
            The following mapping is used with the diferent tag formats to read the content:
            <list type="table">
            <listheader><term>Name</term><description>Mapping</description></listheader>
            <item><term>title</term><description>
            <para>ID3v2: TIT2, TT2</para>
            <para>OGG: TITLE</para>
            <para>APE: Title</para>
            <para>MP4: nam</para>
            <para>ASF: WM/Title</para>
            <para>RIFF: INAM</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>artist</term><description>
            <para>ID3v2: TPE1, TP1</para>
            <para>OGG: ARTIST</para>
            <para>APE: Artist</para>
            <para>MP4: ART</para>
            <para>ASF: WM/Author</para>
            <para>RIFF: IART</para>
            <para>Alternatives: ISTR, AUTHOR</para>
            </description></item>
            <item><term>album</term><description>
            <para>ID3v2: TALB, TAL</para>
            <para>OGG: ALBUM</para>
            <para>APE: Album</para>
            <para>MP4: alb</para>
            <para>ASF: WM/AlbumTitle</para>
            <para>RIFF: IPRD</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>albumartist</term><description>
            <para>ID3v2: TPE2, TP2</para>
            <para>OGG: ALBUMARTIST</para>
            <para>APE: Album Artist</para>
            <para>MP4: aART</para>
            <para>ASF: WM/AlbumArtist</para>
            <para>RIFF: ISBJ</para>
            <para>Alternatives: H2_ALBUMARTIST, ENSEMBLE, ORCHESTRA, BAND, PERFORMER, iaar</para>
            </description></item>
            <item><term>track</term><description>
            <para>ID3v2: TRCK, TRK</para>
            <para>OGG: TRACKNUMBER</para>
            <para>APE: Track</para>
            <para>MP4: trkn</para>
            <para>ASF: WM/TrackNumber</para>
            <para>RIFF: IPRT, ITRK</para>
            <para>Alternatives: TRACKNUM</para>
            </description></item>
            <item><term>disc</term><description>
            <para>ID3v2: TPOS, TPA</para>
            <para>OGG: DISCNUMBER</para>
            <para>APE: Disc</para>
            <para>MP4: disk</para>
            <para>ASF: WM/PartOfSet</para>
            <para>RIFF: IFRM</para>
            <para>Alternatives: DISCNUM</para>
            </description></item>
            <item><term>year</term><description>
            <para>ID3v2: TYER, TYE</para>
            <para>OGG: DATE</para>
            <para>APE: Year</para>
            <para>MP4: day</para>
            <para>ASF: WM/Year</para>
            <para>RIFF: ICRD</para>
            <para>Alternatives: TDRC, RELEASEDATE, RELEASE DATE</para>
            </description></item>
            <item><term>genre</term><description>
            <para>ID3v2: TCON, TCO</para>
            <para>OGG: GENRE</para>
            <para>APE: Genre</para>
            <para>MP4: gen</para>
            <para>ASF: WM/Genre</para>
            <para>RIFF: IGNR</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>copyright</term><description>
            <para>ID3v2: TCOP, TCR</para>
            <para>OGG: COPYRIGHT</para>
            <para>APE: Copyright</para>
            <para>MP4: cprt</para>
            <para>ASF: Copyright</para>
            <para>RIFF: ICOP</para>
            <para>Alternatives: PROVIDER, WM/Provider</para>
            </description></item>
            <item><term>encodedby</term><description>
            <para>ID3v2: TENC, TEN</para>
            <para>OGG: ENCODEDBY</para>
            <para>APE: EncodedBy</para>
            <para>MP4: too</para>
            <para>ASF: WM/EncodedBy</para>
            <para>RIFF: ISFT</para>
            <para>Alternatives: VERSION, ENCODED BY, ENCODED-BY, ENCODER, SOFTWARE, TOOL</para>
            </description></item>
            <item><term>publisher</term><description>
            <para>ID3v2: TPUB, TPB</para>
            <para>OGG: LABEL</para>
            <para>APE: Label</para>
            <para>MP4: ----:com.apple.iTunes:LABEL</para>
            <para>ASF: WM/Publisher</para>
            <para>RIFF: ICMS</para>
            <para>Alternatives: PUBLISHER, ORIGINALSOURCE, VENDOR</para>
            </description></item>
            <item><term>composer</term><description>
            <para>ID3v2: TCOM, TCM</para>
            <para>OGG: COMPOSER</para>
            <para>APE: Composer</para>
            <para>MP4: wrt</para>
            <para>ASF: WM/Composer</para>
            <para>RIFF: IENG</para>
            <para>Alternatives: ORGANIZATION, WRITER, IMUS</para>
            </description></item>
            <item><term>conductor</term><description>
            <para>ID3v2: TPE3, TP3</para>
            <para>OGG: CONDUCTOR</para>
            <para>APE: Conductor</para>
            <para>MP4: ----:com.apple.iTunes:CONDUCTOR</para>
            <para>ASF: WM/Conductor</para>
            <para>RIFF: ITCH</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>lyricist</term><description>
            <para>ID3v2: TEXT, TXT</para>
            <para>OGG: LYRICIST</para>
            <para>APE: Lyricist</para>
            <para>MP4: ----:com.apple.iTunes:LYRICIST</para>
            <para>ASF: WM/Writer</para>
            <para>RIFF: IWRI</para>
            <para>Alternatives: TEXTER, SONGWRITER</para>
            </description></item>
            <item><term>remixer</term><description>
            <para>ID3v2: TPE4, TP4</para>
            <para>OGG: REMIXER</para>
            <para>APE: MixArtist</para>
            <para>MP4: ----:com.apple.iTunes:REMIXER</para>
            <para>ASF: WM/ModifiedBy</para>
            <para>RIFF: IEDT</para>
            <para>Alternatives: ModifiedBy</para>
            </description></item>
            <item><term>producer</term><description>
            <para>ID3v2: TIPL, IPL</para>
            <para>OGG: PRODUCER</para>
            <para>APE: Producer</para>
            <para>MP4: ----:com.apple.iTunes:PRODUCER</para>
            <para>ASF: WM/Producer</para>
            <para>RIFF: IPRO</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>comment</term><description>
            <para>ID3v2: COMM, COM</para>
            <para>OGG: COMMENT</para>
            <para>APE: Comment</para>
            <para>MP4: cmt</para>
            <para>ASF: WM/Description</para>
            <para>RIFF: ICMT</para>
            <para>Alternatives: DESCRIPTION</para>
            </description></item>
            <item><term>grouping</term><description>
            <para>ID3v2: TIT1, TT1</para>
            <para>OGG: GROUPING</para>
            <para>APE: Grouping</para>
            <para>MP4: grp</para>
            <para>ASF: WM/ContentGroupDescription</para>
            <para>RIFF: ISRF</para>
            <para>Alternatives: GROUP</para>
            </description></item>
            <item><term>mood</term><description>
            <para>ID3v2: TMOO</para>
            <para>OGG: MOOD</para>
            <para>APE: Mood</para>
            <para>MP4: ----:com.apple.iTunes:MOOD</para>
            <para>ASF: WM/Mood</para>
            <para>RIFF: IKEY</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>rating</term><description>
            <para>ID3v2: POPM</para>
            <para>OGG: RATING</para>
            <para>APE: Rating</para>
            <para>MP4: rtng</para>
            <para>ASF: WM/SharedUserRating</para>
            <para>RIFF: ISHP</para>
            <para>Alternatives: TXXX:RATING, IRTD</para>
            </description></item>
            <item><term>isrc</term><description>
            <para>ID3v2: TSCR</para>
            <para>OGG: ISRC</para>
            <para>APE: ISRC</para>
            <para>MP4: ----:com.apple.iTunes:ISRC</para>
            <para>ASF: WM/ISRC</para>
            <para>RIFF: ISRC</para>
            <para>Alternatives: --</para>
            </description></item>
            <item><term>bpm</term><description>
            <para>ID3v2: TBPM, TBP</para>
            <para>OGG: BPM</para>
            <para>APE: BPM</para>
            <para>MP4: ----:com.apple.iTunes:BPM</para>
            <para>ASF: WM/BeatsPerMinute</para>
            <para>RIFF: IBPM</para>
            <para>Alternatives: TEMPO, IDPI, tmpo, H2_BPM, BEATSPERMINUTE</para>
            </description></item>
            <item><term>replaygain_track_gain</term><description>
            <para>ID3v2: TXXX:replaygain_track_gain</para>
            <para>OGG: replaygain_track_gain</para>
            <para>APE: replaygain_track_gain</para>
            <para>MP4: ----:com.apple.iTunes:replaygain_track_gain</para>
            <para>ASF: replaygain_track_gain</para>
            <para>RIFF: IRGG</para>
            <para>Alternatives: itgl</para>
            </description></item>
            <item><term>replaygain_track_peak</term><description>
            <para>ID3v2: TXXX:replaygain_track_peak</para>
            <para>OGG: replaygain_track_peak</para>
            <para>APE: replaygain_track_peak</para>
            <para>MP4: ----:com.apple.iTunes:replaygain_track_peak</para>
            <para>ASF: replaygain_track_peak</para>
            <para>RIFF: IRGP</para>
            <para>Alternatives: --</para>
            </description></item>
            </list>
            Note: The mapping is performed case insensitive. The Alternatives are only used, if the regular mapping doesn't find any matching entry.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title">
            <summary>
            The song title.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.artist">
            <summary>
            The Artist name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.album">
            <summary>
            The Album name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.albumartist">
            <summary>
            The Album Artist name (Band/Orchestra/Remixer).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.year">
            <summary>
            The Year (as a string, typically in the format YYYY or YYYY-MM).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.comment">
            <summary>
            The Comment text.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.genre">
            <summary>
            The Genre (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.track">
            <summary>
            The track number (as a string, either '99' or '99/99').
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.disc">
            <summary>
            The disc number (as a string, either '99' or '99/99').
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.copyright">
            <summary>
            The Copyright (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.encodedby">
            <summary>
            The EncodedBy (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.composer">
            <summary>
            The Composer (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.publisher">
            <summary>
            The Publisher, Label (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.lyricist">
            <summary>
            The Lyricist, Songwriter (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.remixer">
            <summary>
            The Remixer, Modifier (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.producer">
            <summary>
            The Producer (as a string).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.bpm">
            <summary>
            Beats Per Minute.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.filename">
            <summary>
            The name of the file (only available, if set in the constructor or manually)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.pictures">
            <summary>
            Keeps optional pictures.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.nativetags">
            <summary>
            Keeps all native tags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.channelinfo">
            <summary>
            The <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.tagType">
            <summary>
            The type of TAG being read (one of <see cref="T:Un4seen.Bass.BASSTag"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.duration">
            <summary>
            The estimated duration of the track in seconds.
            </summary>
            <remarks>This value doesn't have to be 100% accurate but is typically a very good estimation.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.bitrate">
            <summary>
            The estimated bitrate of the track in kBit/sec.
            </summary>
            <remarks>This value doesn't have to be 100% accurate but is typically a good estimation.
            Note: Only usefull with files encoded in CBR (constant bitrate).</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.replaygain_track_gain">
            <summary>
            The track replaygain gain value in dB between -60.0 and +60.0 dB.
            </summary>
            <remarks>Set to -100.0 if not present.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.replaygain_track_peak">
            <summary>
            The track replaygain peak level value as a float value between 0.0 (silence) and 1.0 (0dB).
            </summary>
            /// <remarks>Set to -1.0 if not present.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.conductor">
            <summary>
            The conductor (or director) of the content.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.grouping">
            <summary>
            Content groups are collections of media to which individual files may belong. For example, an audio file may be a song that is a track on one compact disc that is part of a boxed set.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.mood">
            <summary>
            The mood of the content.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.rating">
            <summary>
            The rating of the content (e.g. 0=unrated, 1-20=poor, 21-40=average, 41-60=good, 61-80=very good, 81-100=excellent).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.isrc">
            <summary>
            The International Standard Recording Code (a 12 digit unique alphanumeric number).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor">
            <summary>
            Default constructor (filename must be set manually in order to be available).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor(Un4seen.Bass.AddOn.Tags.TAG_INFO)">
            <summary>
            Creates a new instance as a clone of an existing instance.
            </summary>
            <param name="clone">The instance to clone.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor(System.String)">
            <summary>
            Constructor already setting the filename (full path) and the title (file name only).
            </summary>
            <param name="FileName">The filename to remember.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor already setting the filename (full path) and the title (file name only).
            </summary>
            <param name="FileName">The filename to remember.</param>
            <param name="setDefaultTitle">If <see langword="true"/> the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.title"/> property will be set to a default value (filename without extension).</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.Clone">
            <summary>
            Returns a new TAG_INFO instance which is a clone of the current one.
            </summary>
            <returns>The cloned instance.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ToString">
            <summary>
            A description of the tag info object (artist - title or filename).
            </summary>
            <returns>A description of the tag info object (artist - title or filename).</returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTagsCount">
            <summary>
            Returns the total number of available native tags.
            </summary>
            <returns>The number of native tags.</returns>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTags">
            <summary>
            Returns all native tags.
            </summary>
            <returns>A string array containing all native tags as being gathered.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ClearAllNativeTags">
            <summary>
            Clears the collection of native tag entries.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTag(System.String)">
            <summary>
            Returns a certain native tag.
            </summary>
            <param name="tagname">The name of the native tag to retrieve (case-sensitive!) - e.g. use "TPE1" to query for the artist of ID3v2 tags.</param>
            <returns>The value of the tag or <see langword="null"/> if tag with that name could be found.</returns>
            <remarks>If multiple tags with the same name do exist, only the first tag value will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.UpdateFromMETA(System.IntPtr,System.Boolean,System.Boolean)">
            <summary>
            Update the tags from a meta data pointer, e.g. when streaming from a URL as triggered by a <see cref="T:Un4seen.Bass.SYNCPROC"/> using BASS_SYNC_META and as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
            <param name="data">The pointer to the memory block containing the meta data, e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</param>
            <param name="utf8">Set to <see langword="true"/>, if the tags are presented in UTF-8, else set to <see langword="false"/> to use Latin-1 encoding.</param>
            <param name="multiple">Set to <see langword="true"/>, if a single tag entry is further seperated by ';' (e.g. as for BASS_TAG_META) - in all other cases this should be set to <see langword="false"/>.</param>
            <returns>If any tag was updated <see langword="true"/> is returned. If nothing was changed <see langword="false"/> will be returned.</returns>
            <remarks>
            The following members will be updated:
            <list type="table">
            <item><term>title</term><description>With the detected new stream title, if found.
            <para>Note: For URL streams (Shoutcast, Oddcast) the 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be splitted at the first occurence of a '-' seperator.</para></description></item>
            <item><term>artist</term><description>With the detected new artist, if found.
            <para>Note: For URL streams (Shoutcast, Oddcast) the 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be splitted at the first occurence of a '-' seperator.</para></description></item>
            <item><term>album</term><description>With the detected album name of the stream, if found (eg. icy-name).</description></item>
            <item><term>genre</term><description>With the detected genre of the stream, if found (eg. icy-genre).</description></item>
            <item><term>comment</term><description>With the detected new comment, if found (e.g. icy-url).</description></item>
            <item><term>year</term><description>With the detected year, if found.</description></item>
            <item><term>bitrate</term><description>With the detected bitrate, if found (e.g. icy-br).
            <para>Note: For URL streams (Shoutcast, Oddcast), the new url location will be used.</para>
            <para>Note: For MIDI lyric text syncs please use the <see cref="!:UpdateFromMIDILyric"/> method.</para></description></item>
            </list>
            </remarks>
            <example>
            Update tags with a sync proc together with Bass.BASS_StreamCreateURL:
            <code>
            private SYNCPROC _mySync;
            private TAG_INFO _tags;
            ...
            string url = "http://someurl...";
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, null, 0);
            _tags = new TAG_INFO(url);
            // set a sync to get the title updates out of the meta data...
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered on meta changes of SHOUTcast streams
              _tags.UpdateFromMETA( Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_META), true, false );
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            Private _tags As TAG_INFO
            ...
            Dim url As String = "http://someurl..."
            Dim stream As Integer = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, Nothing, 0)
            _tags = New TAG_INFO(url)
            ' set a sync to get the title updates out of the meta data...
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            ...
            Private Sub MetaSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              ' BASS_SYNC_META is triggered on meta changes of SHOUTcast streams
              _tags.UpdateFromMETA(Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_META), True, False)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.UpdateFromMETA(System.IntPtr,Un4seen.Bass.AddOn.Tags.TAGINFOEncoding,System.Boolean)">
            <summary>
            Update the tags from a meta data pointer, e.g. when streaming from a URL as triggered by a <see cref="T:Un4seen.Bass.SYNCPROC"/> using BASS_SYNC_META and as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
            <param name="data">The pointer to the memory block containing the meta data, e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</param>
            <param name="encoding">Set to <see langword="true"/>, if the tags are present in UTF-8 (8-bit), else set to <see langword="false"/> to use ANSI characters (7-bit).</param>
            <param name="multiple">Set to <see langword="true"/>, if a single tag entry is further seperated by ';' (e.g. as for BASS_TAG_META) - in all other cases this should be set to <see langword="false"/>.</param>
            <returns>If any tag was updated <see langword="true"/> is returned. If nothing was changed <see langword="false"/> will be returned.</returns>
            <remarks>
            The following members will be updated:
            <list type="table">
            <item><term>title</term><description>With the detected new stream title, if found.
            <para>Note: For URL streams (Shoutcast, Oddcast) the 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be splitted at the first occurence of a '-' seperator.</para></description></item>
            <item><term>artist</term><description>With the detected new artist, if found.
            <para>Note: For URL streams (Shoutcast, Oddcast) the 'streamtitle' might be composed within the meta data, e.g. Shoutcast combines the artist name and the real track name together. Shoutcast titles will be splitted at the first occurence of a '-' seperator.</para></description></item>
            <item><term>album</term><description>With the detected album name of the stream, if found (eg. icy-name).</description></item>
            <item><term>genre</term><description>With the detected genre of the stream, if found (eg. icy-genre).</description></item>
            <item><term>comment</term><description>With the detected new comment, if found (e.g. icy-url).</description></item>
            <item><term>year</term><description>With the detected year, if found.</description></item>
            <item><term>bitrate</term><description>With the detected bitrate, if found (e.g. icy-br).
            <para>Note: For URL streams (Shoutcast, Oddcast), the new url location will be used.</para>
            <para>Note: For MIDI lyric text syncs please use the <see cref="!:UpdateFromMIDILyric"/> method.</para></description></item>
            </list>
            </remarks>
            <example>
            Update tags with a sync proc together with Bass.BASS_StreamCreateURL:
            <code>
            private SYNCPROC _mySync;
            private TAG_INFO _tags;
            ...
            string url = "http://someurl...";
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, null, 0);
            _tags = new TAG_INFO(url);
            // set a sync to get the title updates out of the meta data...
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered on meta changes of SHOUTcast streams
              _tags.UpdateFromMETA( Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_META), TAGINFOEncoding.Utf8OrLatin1, false );
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            Private _tags As TAG_INFO
            ...
            Dim url As String = "http://someurl..."
            Dim stream As Integer = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_STREAM_STATUS, Nothing, 0)
            _tags = New TAG_INFO(url)
            ' set a sync to get the title updates out of the meta data...
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            ...
            Private Sub MetaSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              ' BASS_SYNC_META is triggered on meta changes of SHOUTcast streams
              _tags.UpdateFromMETA(Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_META), , TAGINFOEncoding.Utf8OrLatin1, False)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.AddNativeTag(System.String,System.Object)">
            <summary>
            Adds a native tag.
            </summary>
            <param name="key">The tag name to add.</param>
            <param name="value">The tag value to use.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.AddOrReplaceNativeTag(System.String,System.Object)">
            <summary>
            Adds or Replaces a native tag.
            </summary>
            <param name="key">The tag name to replace.</param>
            <param name="value">The tag value to use.</param>
            <remarks>If the <paramref name="key"/> tag was found its content will be replaced, else a new nativ tag will be created.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.RemoveNativeTag(System.String)">
            <summary>
            Removes a native tag.
            </summary>
            <param name="key">The tag name to replace.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.EvalTagEntry(System.String)">
            <summary>
            Takes one tag (key=value) and changes the internal members accordingly.
            </summary>
            <param name="tagEntry">The tag string to evaluate (in the format: key=value or or key:value)</param>
            <returns><see langword="true"/>, if a tag member was changed, else <see langword="false"/>.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.AddPicture(Un4seen.Bass.AddOn.Tags.TagPicture)">
            <summary>
            Adds a picture tag.
            </summary>
            <param name="tagPicture">The tag picture instance to add.</param>
            <returns><see langword="true"/> on success - else <see langword="false"/>.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.RemovePicture(System.Int32)">
            <summary>
            Removes a picture tag.
            </summary>
            <param name="i">The index of the picture to remove.</param>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.RemoveAllPictures">
            <summary>
            Removes all picture tags.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount">
            <summary>
            Returns the number of pictures which are available.
            </summary>
            <remarks>Pictures might not be available to all formats.
            <para>If the global <see cref="F:Un4seen.Bass.AddOn.Tags.BassTags.ReadPictureTAGs"/> is set to <see langword="false"/> picture tags might not be read in.</para>
            <para>You can access the available picture tags via the <see cref="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGet(System.Int32)"/>, <see cref="!:PictureGetImage"/>, <see cref="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetDescription(System.Int32)"/> or <see cref="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetType(System.Int32)"/> methods.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGet(System.Int32)">
            <summary>
            Returns a picture tag.
            </summary>
            <param name="i">The zero-based index (number) of the picture to get. You might use <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> to retrieve the total number of pictures available.</param>
            <returns>The tag of the picture on success or <see langword="null"/> if no picture is available (at that index).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetDescription(System.Int32)">
            <summary>
            Returns the description of a picture.
            </summary>
            <param name="i">The zero-based index (number) of the picture to access. You might use <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> to retrieve the total number of pictures available.</param>
            <returns>The description of the picture on success or <see langword="null"/> if no picture is available (at that index).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureGetType(System.Int32)">
            <summary>
            Returns the type of the picture.
            </summary>
            <param name="i">The zero-based index (number) of the picture to access. You might use <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> to retrieve the total number of pictures available.</param>
            <returns>The type of the picture on success or <see langword="null"/> if no picture is available (at that index).</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ReadPicturesFromDirectory(System.String,System.Boolean)">
            <summary>
            Scans the directory of the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.filename"/> location for additional pictures and adds them to the internal picture tags (see <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.PictureCount"/> for details).
            </summary>
            <param name="searchPattern">An optional search string, such as "*.jpg" or "Album*.jpg" or <see langword="null"/> to scan for default images.</param>
            <param name="all"><see langword="true"/> to add all found images to the picture list or <see langword="false"/> to only add the first found image.</param>
            <remarks>When scanning for default images (<paramref name="searchPattern"/> is <see langword="null"/>) the following order will be used:
            <list type="number">
            <item><term>&lt;filename&gt;.jpg</term></item>
            <item><term>&lt;filename&gt;.gif</term></item>
            <item><term>&lt;filename&gt;.png</term></item>
            <item><term>&lt;filename&gt;.bmp</term></item>
            <item><term>Folder*.jpg</term></item>
            <item><term>Album*.jpg</term></item>
            <item><term>&lt;album&gt;.jpg</term></item>
            <item><term>&lt;album&gt;.gif</term></item>
            <item><term>&lt;album&gt;.png</term></item>
            <item><term>&lt;album&gt;.bmp</term></item>
            </list>
            In the above list &lt;filename&gt; resp. &lt;album&gt; will be replaced by the actual tag content field values.
            <para>This methods adds any found pictures to the internal picture tags.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ReadPicturesFromDirectory(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Scans the directory of the <see cref="F:Un4seen.Bass.AddOn.Tags.TAG_INFO.filename"/> location for additional pictures and returns any found pictures.
            </summary>
            <param name="filename">The fully qualified path and file name to get the picture(s) from.</param>
            <param name="album">The optional name of the album tag to use to find a picture file (see below).</param>
            <param name="searchPattern">An optional search string, such as "*.jpg" or "Album*.jpg" or <see langword="null"/> to scan for default images.</param>
            <param name="all"><see langword="true"/> to return all found pictures or <see langword="false"/> to only return the first found picture.</param>
            <returns>A list of found <see cref="T:Un4seen.Bass.AddOn.Tags.TagPicture"/> items or an empty list if no pictures could be found.</returns>
            <remarks>When scanning for default images (<paramref name="searchPattern"/> is <see langword="null"/>) the following order will be used:
            <list type="number">
            <item><term>&lt;filename&gt;.jpg</term></item>
            <item><term>&lt;filename&gt;.gif</term></item>
            <item><term>&lt;filename&gt;.png</term></item>
            <item><term>&lt;filename&gt;.bmp</term></item>
            <item><term>Folder*.jpg</term></item>
            <item><term>Album*.jpg</term></item>
            <item><term>&lt;album&gt;.jpg</term></item>
            <item><term>&lt;album&gt;.gif</term></item>
            <item><term>&lt;album&gt;.png</term></item>
            <item><term>&lt;album&gt;.bmp</term></item>
            </list>
            In the above list &lt;filename&gt; resp. &lt;album&gt; will be replaced by the actual parameter values.
            <para>This methods does not add any pictures to the internal picture tags.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ConvertToRiffINFO(System.Boolean)">
            <summary>
            Converts the members of this instance to a WAV RIFF LIST INFO chunk.
            </summary>
            <param name="fromNativeTags"><see langword="true"/> to create the INFO chunk out of the <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTags"/>, <see langword="false"/> to create them from the standard members.</param>
            <returns>The byte array containing the LIST INFO chunk data.</returns>
            <remarks>You might use this method to write a RIFF LIST INFO chunk to a wave file using the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.IntPtr,System.Int32)"/> method.
            <para>When creating the INFO chunk from the the standard members, the following mapping is used:
            <list type="table">
            <listheader><term>INFO chunk id</term><description>Content</description></listheader>
            <item><term>INAM</term><description>title</description></item>
            <item><term>IART</term><description>artist</description></item>
            <item><term>IPRD</term><description>album</description></item>
            <item><term>ISBJ</term><description>albumartist</description></item>
            <item><term>IPRT</term><description>track</description></item>
            <item><term>IFRM</term><description>disc</description></item>
            <item><term>ICRD</term><description>year</description></item>
            <item><term>IGNR</term><description>genre</description></item>
            <item><term>ICOP</term><description>copyright</description></item>
            <item><term>ISFT</term><description>encodedby</description></item>
            <item><term>ICMT</term><description>comment</description></item>
            <item><term>IENG</term><description>composer</description></item>
            <item><term>ICMS</term><description>publisher</description></item>
            <item><term>ITCH</term><description>conductor</description></item>
            <item><term>IWRI</term><description>lyricist</description></item>
            <item><term>IEDT</term><description>remixer</description></item>
            <item><term>IPRO</term><description>producer</description></item>
            <item><term>ISRF</term><description>grouping</description></item>
            <item><term>IKEY</term><description>mood</description></item>
            <item><term>ISHP</term><description>rating</description></item>
            <item><term>ISRC</term><description>isrc</description></item>
            <item><term>IBPM</term><description>bpm</description></item>
            <item><term>IRGP</term><description>replaygain_track_peak</description></item>
            <item><term>IRGG</term><description>replaygain_track_gain</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            byte[] listData = TAGs.ConvertToRiffINFO(false);
            if (listData != null)
                BassEnc.BASS_Encode_AddChunk(_encoderHandle, "LIST", listData, listData.Length);
            </code>
            <code lang="vbnet">
            Dim listData As Byte() = TAGs.ConvertToRiffINFO(False)
            If listData IsNot Nothing Then 
                BassEnc.BASS_Encode_AddChunk(_encoderHandle, "LIST", listData, listData.Length) 
            End If 
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ConvertToRiffBEXT(System.Boolean)">
            <summary>
            Converts the members of this instance to a WAV RIFF BEXT chunk.
            </summary>
            <param name="fromNativeTags"><see langword="true"/> to create the BEXT chunk out of the <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTags"/>, <see langword="false"/> to create them from the standard members.</param>
            <returns>The byte array containing the BEXT chunk data.</returns>
            <remarks>You might use this method to write a RIFF BEXT chunk to a wave file using the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.IntPtr,System.Int32)"/> method.
            <para>When creating the BEXT chunk from the the standard members, the following mapping is used:
            <list type="table">
            <listheader><term>BEXT field</term><description>Content</description></listheader>
            <item><term>Description</term><description>title</description></item>
            <item><term>Originator</term><description>artist</description></item>
            <item><term>OriginatorReference</term><description>encodedby</description></item>
            <item><term>OriginationDate</term><description>year</description></item>
            <item><term>OriginationTime</term><description>year</description></item>
            <item><term>TimeReference</term><description>--</description></item>
            <item><term>UMID</term><description>--</description></item>
            <item><term>Version</term><description>1</description></item>
            <item><term>CodingHistory</term><description>--</description></item>
            </list>
            Note: Broadcast Wave Format (bext) native tags are named as above with the prefix 'BWF'.
            </para>
            </remarks>
            <example>
            <code>
            byte[] bextData = TAGs.ConvertToRiffBEXT(true);
            if (bextData != null)
                BassEnc.BASS_Encode_AddChunk(_encoderHandle, "bext", bextData, bextData.Length);
            </code>
            <code lang="vbnet">
            Dim bextData As Byte() = TAGs.ConvertToRiffBEXT(True)
            If bextData IsNot Nothing Then 
                BassEnc.BASS_Encode_AddChunk(_encoderHandle, "bext", bextData, bextData.Length) 
            End If 
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.ConvertToRiffCART(System.Boolean)">
            <summary>
            Converts the members of this instance to a WAV RIFF CART chunk.
            </summary>
            <param name="fromNativeTags"><see langword="true"/> to create the CART chunk out of the <see cref="P:Un4seen.Bass.AddOn.Tags.TAG_INFO.NativeTags"/>, <see langword="false"/> to create them from the standard members.</param>
            <returns>The byte array containing the CART chunk data.</returns>
            <remarks>You might use this method to write a RIFF CART chunk to a wave file using the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.IntPtr,System.Int32)"/> method.
            <para>When creating the CART chunk from the the standard members, the following mapping is used:
            <list type="table">
            <listheader><term>CART field</term><description>Content</description></listheader>
            <item><term>Version</term><description>--</description></item>
            <item><term>Title</term><description>title</description></item>
            <item><term>Artist</term><description>artist</description></item>
            <item><term>CutID</term><description>album</description></item>
            <item><term>ClientID</term><description>copyright</description></item>
            <item><term>Category</term><description>genre</description></item>
            <item><term>Classification</term><description>grouping</description></item>
            <item><term>OutCue</term><description>--</description></item>
            <item><term>StartDate</term><description>--</description></item>
            <item><term>StartTime</term><description>--</description></item>
            <item><term>EndDate</term><description>--</description></item>
            <item><term>EndTime</term><description>--</description></item>
            <item><term>ProducerAppID</term><description>encodedby</description></item>
            <item><term>ProducerAppVersion</term><description>--</description></item>
            <item><term>UserDef</term><description>--</description></item>
            <item><term>LevelReference</term><description>--</description></item>
            <item><term>Timer1-8</term><description>--</description></item>
            <item><term>URL</term><description>--</description></item>
            <item><term>TagText</term><description>comment</description></item>
            </list>
            Note: Broadcast Wave Format (cart) native tags are named as above with the prefix 'CART'.
            </para>
            </remarks>
            <example>
            <code>
            byte[] cartData = TAGs.ConvertToRiffCART(true);
            if (cartData != null)
                BassEnc.BASS_Encode_AddChunk(_encoderHandle, "cart", cartData, cartData.Length);
            </code>
            <code lang="vbnet">
            Dim cartData As Byte() = TAGs.ConvertToRiffCART(True)
            If cartData IsNot Nothing Then 
                BassEnc.BASS_Encode_AddChunk(_encoderHandle, "cart", cartData, cartData.Length) 
            End If 
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.ID3v2Reader">
            <summary>
            A class for reading the tags from an ID3 header.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.ID3v2Reader.#ctor(System.IntPtr)">
            <summary>
            Reads the tags from an ID3v2 header.
            </summary>
            <param name="pID3v2">The memory pointer to the ID3v2 header.</param>
            <exception cref="T:System.FormatException">Invalid syncsafe integer found in ID3v2 data.</exception>
            <example>
            <code>
            The 10 byte header looks like this:
            struct Id3v2Header 
            {
            	char magic[3];	// always "Id3"
            	char majorVersion;
            	char minorVersion;
            	char flags;
            	int28 size;
            };
            The version is always v2.maj.min -- the v2 is implied.
            flags currently only defines 4 flags.  More on these later.
            The int28 type is a 28-bit integer padded out to a
            32-bit integer, to make it sync-safe.  It's padded by setting
            the most significant bit of each byte to zero.
            i.e. it looks like this:
            0xxxxxxx0xxxxxxx0xxxxxxx0xxxxxxx
            Integers in Id3v2 are big-endian.
            A frame looks like this:
            struct Id3v2Frame 
            {
            	char frame_id[4];
            	int28 size;
            	char flags[2];
            };
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TagPicture">
            <summary>
            This class represents a picture tag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.MIMEType">
            <summary>
            The MIMEType of the picture.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureType">
            <summary>
            The type of the picture - one of the <see cref="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE"/> values.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.Description">
            <summary>
            The description of the picture.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data">
            <summary>
            The raw image data of the picture or the UTF-8 encoded location of the picture.
            </summary>
            <remarks>
            If the <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> is set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/>, this property directly contains the picture image data.
            If the <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> is set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/>, this property contains the link to the picture image as a fully qualified name (UTF-8 encoded).
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.AttributeIndex">
            <summary>
            The index or number of the related picture tag (-1 = undefined).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage">
            <summary>
            The storage type of the picture <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data"/>.
            </summary>
            <remarks>
            This property denotes where the image data is stored.
            <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/> specifies, that <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data"/> directly contains the picture image.
            <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/> specifies, that <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.Data"/> contains the link to the picture image as a fully qualified name (UTF-8 encoded).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.Int32,System.String,Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE,System.String,System.Byte[])">
            <summary>
            Creates a picture tag from the given values.
            </summary>
            <param name="attribIndex">The index/number of picture.</param>
            <param name="mimeType">The MIMEType of the picture.</param>
            <param name="pictureType">The PICTURE_TYPE.</param>
            <param name="description">The description of the picture.</param>
            <param name="data">The raw image data.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.String)">
            <summary>
            Creates a picture tag as an external link to a file.
            </summary>
            <param name="file">A string that contains the fully qualified name of the file from which to create the picture.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.String,Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE,System.String)">
            <summary>
            Creates a picture tag as an external link to a file.
            </summary>
            <param name="file">A string that contains the fully qualified name of the file from which to create the picture.</param>
            <param name="type">The type of the picture (one of the <see cref="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE"/> values).</param>
            <param name="description">The description of the picture.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.#ctor(System.Byte[],System.Int32)">
            <summary>
            Loads a picture from a byte[] containing the PIC/FLAC image struct.
            </summary>
            <param name="pData">The byte[] containing the PIC/FLAC image struct.</param>
            <param name="pType">0=raw image, 1=FLAC structure, 2=APE structure.</param>
            <remarks>The <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PictureStorage"/> will be set to <see cref="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.ToString">
            <summary>
            Returns the description, picture type and MIMEType of the picture.
            </summary>
            <returns>The picture description string.</returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tags.TagPicture.GetMimeTypeFromFile(System.String)">
            <summary>
            Returns the MIMEType of a given file by evaluating the file extension.
            </summary>
            <param name="pFile">The name of the file to get the MIMEType from.</param>
            <returns>The MIMEType string of the image.</returns>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE">
            <summary>
            Picture Type enumeration.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Unknown">
            <summary>
            Picture of a type not specifically listed (unknown or other).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Icon32">
            <summary>
            32 pixel by 32 pixel file icon. Use only with portable network graphics (PNG) format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.OtherIcon">
            <summary>
            File icon not conforming to type 1 above.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.FrontAlbumCover">
            <summary>
            Front album cover.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.BackAlbumCover">
            <summary>
            Back album cover.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.LeafletPage">
            <summary>
            Leaflet page.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Media">
            <summary>
            Media, typically this type of image is of the label side of a CD.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.LeadArtist">
            <summary>
            Picture of the lead artist, lead performer, or soloist.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Artists">
            <summary>
            Picture of one of the artists or performers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Conductor">
            <summary>
            Picture of the conductor.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Orchestra">
            <summary>
            Picture of the band or orchestra.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Composer">
            <summary>
            Picture of the composer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Writer">
            <summary>
            Picture of the lyricist or writer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Location">
            <summary>
            Picture of the recording studio or location.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.RecordingSession">
            <summary>
            Picture taken during a recording session.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Performance">
            <summary>
            Picture taken during a performance.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.VideoCapture">
            <summary>
            Screen capture from a movie or video.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.ColoredFish">
            <summary>
            A bright colored fish.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.Illustration">
            <summary>
            Illustration.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.BandLogo">
            <summary>
            Logo of the band or artist.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_TYPE.PublisherLogo">
            <summary>
            Logo of the publisher or studio.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE">
            <summary>
            Picture Storage enumeration.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.Internal">
            <summary>
            The picture is stored internally as an image.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TagPicture.PICTURE_STORAGE.External">
            <summary>
            The picture is stored externally as an image link.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tags.TAGINFOEncoding">
            <summary>
            Used with <see cref="M:Un4seen.Bass.AddOn.Tags.TAG_INFO.UpdateFromMETA(System.IntPtr,System.Boolean,System.Boolean)"/> to define which encoding to use.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAGINFOEncoding.Ansi">
            <summary>
            Use the default ANSI encoding (current operating system's settings).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAGINFOEncoding.Latin1">
            <summary>
            Use Latin-1 (ISO-8859-1) encoding.
            <para>Note: If the <see cref="P:Un4seen.Bass.BassNet.UseBrokenLatin1Behavior"/> property is set this also uses the default Ansi encoding.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAGINFOEncoding.Utf8">
            <summary>
            Use Utf-8 encoding.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tags.TAGINFOEncoding.Utf8OrLatin1">
            <summary>
            Use Utf-8 or Latin-1 encoding (whatever returns the shorter string).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Tta.BassTta">
            <summary>
            BASS.NET API wrapper for BASS_TTA.DLL
            <para>Requires: bass_tta.dll - The True Audio Codec (TTA) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS_TTA is an extension to the BASS audio library, enabling the playing of TTA (The True Audio Codec) encoded files. TTA is a free, simple, realtime lossless audio compressor based on adaptive prognostic filters. The codec was built to offer adequate compression levels while maintaining high operation speeds.</para>
            <para>The True Audio format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> or User functions.</para>
            <para>More information can be found on <a href="http://www.true-audio.com">www.true-audio.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a True Audio file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a True Audio memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Tta.BassTta.BASS_TTA_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a True Audio file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tta.BassTta.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the bass_tta.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Tta.BassTta.SupportedStreamName">
            <summary>
            Supported file format name of the bass_tta.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.AddOn.Wv.BassWv">
            <summary>
            BASS.NET API wrapper for BASSWV.DLL
            <para>Requires: basswv.dll - WavPack Audio Format (WV) Add-On - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSWV is an extension to the BASS audio library, enabling the playback of WavPack files.</para>
            <para>WavPack is a completely open audio compression format providing lossless, high quality lossy, and an unique hybrid compression mode.
            In the default lossless mode WavPack acts just like a WinZip compressor for audio files. Unlike MP3 or WMA encoding which can affect the sound quality,
            not a single bit of the original information is lost. The hybrid mode provides all the advantages of lossless compression with an additional bonus: instead of creating a single file, this mode creates both a
            relatively small, high quality lossy file that can be used all by itself, and a correction file that, when combined with the lossy file, provides full lossless restoration.</para>
            <para>The WavPack format is used in the same way as any of the built-in BASS stream formats. Simply call <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> to load the add-on into BASS and benefit the usage of the standard sample/stream/user functions, or call the <see cref="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> / User functions.</para>
            <para>More information can be found on <a href="http://www.wavpack.com">www.wavpack.com</a>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a WavPack file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from a WavPack memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory streams in bytes which should be played).</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> does - so for details look there.</remarks>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from a WavPack file via a user callback function.
            </summary>
            <param name="system">File system to use: see <see cref="T:Un4seen.Bass.BASSStreamSystem"/>.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="procs">The user defined file functions (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> does - so for details look there.</remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.AddOn.Wv.BassWv.BASS_WV_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from an WavPack file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
             <param name="url">URL of the file to stream. Should begin with "http://" or "ftp://".</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown.</param>
            <param name="flags">Any combination of these flags: see <see cref="T:Un4seen.Bass.BASSFlag"/>.</param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Works in the same way <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> does - so for details look there.</remarks>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wv.BassWv.SupportedStreamExtensions">
            <summary>
            Supported file extensions of the basswv.dll
            </summary>
        </member>
        <member name="F:Un4seen.Bass.AddOn.Wv.BassWv.SupportedStreamName">
            <summary>
            Supported file format name of the basswv.dll
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BassNet">
            <summary>
            Bass.Net class.
            <para>Contains a few optional and global settings.</para>
            </summary>
            <remarks>
            <para>When you purchased a valid license for BASS.NET you will obtain a 'Registration-Key' together with your 'eMail'.
            Call the <see cref="M:Un4seen.Bass.BassNet.Registration(System.String,System.String)"/> method prior to any other BASS method with these 2 parameters in order to register your product.</para>
            <para>If you like to support BASS.NET, you might call the <see cref="!:ShowSplash"/> method manually.</para>
            </remarks>
            <example>
            Register BASS.NET:
            <code>
            BassNet.Registration("your emai", "your registration code");
            ...
            Bass.Init(...);
            </code>
            Register BASS.NET, but show splash anyhow (for 30sec., center parent, 5% transparent):
            <code>
            BassNet.Registration("your email", "your registration code");
            BassNet.ShowSplash(this, 30000, 0.95, 2);
            ...
            Bass.Init(...);
            </code>
            <code lang="vbnet">
            BassNet.Registration("your email", "your registration code") 
            BassNet.ShowSplash(Me, 30000, 0.95, 2) 
            ...
            Bass.Init(...) 
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BassNet.#ctor">
            <summary>
            NOT needed - all members are static.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BassNet.#cctor">
            <summary>
            Base static contructor.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BassNet.InternalName">
            <summary>
            Gets the internal name, which the productname and version.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BassNet.OmitCheckVersion">
            <summary>
            Gets or Sets, if the version check should be omitted when initializing Bass, BassWaspi or BassAsio.
            </summary>
            <remarks>
            By default a version check is performed whenever Bass, BassWaspi or BassAsio is initialized.
            However, this automatic version check might sometimes not be desired,
            in such case you might want to set this property to <see langword="true"/>.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BassNet.UseBrokenLatin1Behavior">
            <summary>
            Gets or Sets whether or not to use a broken behavior for Latin-1 strings (e.g. common to ID3v1 and ID3v2 tags).
            </summary>
            <value>
            <see langword="true" /> if the broken behavior is to be used. Otherwise, <see langword="false" />.</value>
            <remarks>
            Many media players and taggers incorrectly treat Latin-1 fields as "default encoding" fields. As such, a
            tag may end up with Windows-1250 resp. Windows-1252 encoded text.
            While this problem would be apparent when moving a file from one computer to another, it would not be apparent on the original machine.
            By setting this property to <see langword="true" />, your program will behave like Windows Media Player and others,
            who read tags with this broken behavior.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BassNet.UseRiffInfoUTF8">
            <summary>
            Gets or Sets whether or not to use UTF-8 strings when reading RIFF INFO (LIST INFO) chunks.
            </summary>
            <value>
            <see langword="true" /> if UTF-8 is to be used. Otherwise, <see langword="false" />.</value>
            <remarks>
            Some media players and taggers incorrectly use UTF-8 strings for RIFF INFO (LIST INFO) chunks instead of "Latin1".
            By setting this property to <see langword="true" />, your program will read any RIFF INFO (LIST INFO) chunks as UTF-8 strings.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BassNet.Registration(System.String,System.String)">
            <summary>
            Registers your BASS.NET version and suppresses the freeware splash screen.
            </summary>
            <param name="eMail">Your eMail address for which you obtained a license.</param>
            <param name="registrationKey">The Registration-Key as obtained with the license.</param>
            <remarks>IMPORTANT: Make sure to call this method prior to any other BASS method!</remarks>
        </member>
        <member name="T:Un4seen.Bass.Bass">
            <summary>
            BASS.NET API wrapper for BASS.DLL
            <para>Requires: bass.dll - Bass Audio Library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASS is an audio library for use in Windows and MacOSX software. It's purpose is to provide the most powerful and efficient (yet easy to use),
            sample, stream, MOD music, and recording functions. All in a tiny DLL, under 100KB in size.</para>
            <para>BASS requires DirectX 3 or above for output. BASS does not require that a	soundcard with DirectSound/DirectSound3D hardware accelerated drivers is
            installed, but it does improve performance if there is one. BASS also takes advantage of MMX, which improves the performance of the MOD music playback</para>
            <para>There is no guarantee that all future BASS versions will be compatible with all previous versions, so your program should use <see cref="M:Un4seen.Bass.Bass.BASS_GetVersion"/> to check the version that is loaded. 
            This also means that you should put the BASS module in the same directory as your executable (not just somewhere in the path), to avoid the possibility of a wrong version being loaded.</para>
            <para>There is no need to create an instance of this class, since all Bass methods are declared as static.</para>
            </remarks>
            <example>My first BASS application:
            <code>
            using System;
            using Un4seen.Bass;
            
            namespace MyFirstBass
            {
              class Program
              {
                static void Main(string[] args)
                {
                  // init BASS using the default output device
                  if ( Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero) )
                  {
                    // create a stream channel from a file
                    int stream = Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT);
                    if (stream != 0)
                    {
                      // play the stream channel
                      Bass.BASS_ChannelPlay(stream, false);
                    }
                    else
                    {
                      // error creating the stream
                      Console.WriteLine("Stream error: {0}", Bass.BASS_ErrorGetCode());
                    }
            
                    // wait for a key
                    Console.WriteLine("Press any key to exit");
                    Console.ReadKey(false);
            
                    // free the stream
                    Bass.BASS_StreamFree(stream);
                    // free BASS
                    Bass.BASS_Free();
                  }
                }
              }
            }
            </code>
            <code lang="vbnet">
            Imports System
            Imports Un4seen.Bass
            
            Namespace MyFirstBass
              Class Program
                Shared  Sub Main(ByVal args() As String)
                  ' init BASS using the default output device
                  If Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero) Then
                    ' create a stream channel from a file
                    Dim stream As Integer =  Bass.BASS_StreamCreateFile("test.mp3", 0L, 0L, BASSFlag.BASS_DEFAULT) 
                    If stream &lt;&gt; 0 Then
                      ' play the stream channel
                      Bass.BASS_ChannelPlay(stream, False)
                    Else 
                      ' error creating the stream
                      Console.WriteLine("Stream error: {0}", Bass.BASS_ErrorGetCode())
                    End If
            
                    ' wait for a key
                    Console.WriteLine("Press any key to exit")
                    Console.ReadKey(False)
            
                    ' free the stream
                    Bass.BASS_StreamFree(stream)
                    ' free BASS
                    Bass.BASS_Free()
                  End If
                End Sub
              End Class
            End Namespace
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.#cctor">
            <summary>
            Base static contructor.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Bass.UsesMediaFoundation">
            <summary>
            Gets, if BASS leverages additional Windows Media Foundation audio codecs as installed with the OS.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Bass.UsesCoreAudio">
            <summary>
            Gets, if BASS leverages additional Apple Core Audio Format audio codecs as installed with the OS (MacOSX only).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="freq"></param>
            <param name="flags"></param>
            <param name="win"></param>
            <param name="clsid"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr)">
            <summary>
            Initializes an output device.
            </summary>
            <param name="device">The device to use... -1 = default device, 0 = no sound, 1 = first real output device.
            <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceCount"/> can be used to get the total number of devices.
            </param>
            <param name="freq">Output sample rate.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSInit"/>):
            <list type="table">
            <item><term>BASS_DEVICE_8BITS</term><description>Use 8-bit resolution, else 16-bit.</description></item>
            <item><term>BASS_DEVICE_MONO</term><description>Use mono, else stereo.</description></item>
            <item><term>BASS_DEVICE_STEREO</term><description>Limit the output to stereo, saving some CPU if the device has more speakers available.</description></item>
            <item><term>BASS_DEVICE_3D</term><description>Enable 3D functionality. If this flag is not specified, then the BASS_SAMPLE_3D flag is ignored when loading/creating a sample/stream/music.</description></item>
            <item><term>BASS_DEVICE_LATENCY</term><description>Calculates the latency of the device, that is the delay between requesting a sound to play and it acually being heard. A recommended minimum buffer length is also calculated. Both values are retrievable in the BASS_INFO structure (latency and minbuf members). These calculations can increase the time taken by this function by 1-3 seconds.</description></item>
            <item><term>BASS_DEVICE_SPEAKERS</term><description>Force the enabling of <a href="../Overview.html#SpeakerAssignement">speaker assignment</a>. With some devices/drivers, the number of speakers BASS detects may be 2, when the device in fact supports more than 2 speakers. This flag forces the enabling of assignment to all 8 possible speakers. This flag has no effect with non-WDM drivers.</description></item>
            <item><term>BASS_DEVICE_CPSPEAKER</term><description>Use the Windows control panel setting to detect the number of speakers. Soundcards generally have their own control panel to set the speaker config, so the Windows control panel setting may not be accurate unless it matches that. This flag has no effect on Vista, as the speakers are already accurately detected.</description></item>
            <item><term>BASS_DEVICE_NOSPEAKER</term><description>Ignore speaker arrangement. This flag tells BASS not to make any special consideration for speaker arrangements when using the SPEAKER flags, eg. swapping the CENLFE and REAR speaker channels in 5/7.1 speaker output. This flag should be used with plain multi-channel (rather than 5/7.1) devices.</description></item>
            <item><term>BASS_DEVICE_DMIX</term><description>Linux only: Initialize the device using the ALSA "dmix" plugin, else initialize the device for exclusive access.</description></item>
            <item><term>BASS_DEVICE_FREQ</term><description>Set the device's output rate to <paramref name="freq"/>, otherwise leave it as it is.</description></item>
            <item><term>BASS_DEVICE_DSOUND</term><description>Initialize the device to use the old DirectSound output system instead of WASAPI. If WASAPI is not available (pre-Vista Windows), then this will be applied automatically.</description></item>
            <item><term>BASS_DEVICE_AUDIOTRACK</term><description>Initialize the device to use AudioTrack output instead of OpenSL ES. If OpenSL ES is not available (pre-2.3 Android), then this will be applied automatically.</description></item>
            </list>
            </param>
            <param name="win">The application's main window... <see cref="F:System.IntPtr.Zero"/> = the desktop window (use this for console applications).</param>
            <returns>If the device was successfully initialized, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before using any sample, stream or MOD music functions. The recording functions may be used without having called this function.</para>
            <para>Playback is not possible with the "no sound" device, but it does allow the use of "decoding channels", eg. to decode files.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/> is used to switch the current device. When successful, BASS_Init automatically sets the current thread's device to the one that was just initialized.</para>
            <para>When using the default device (device = -1), <see cref="M:Un4seen.Bass.Bass.BASS_GetDevice"/> can be used to find out which device it was mapped to. On Windows, it'll always be the first device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DX</term><description>DirectX (or ALSA) is not installed.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. You must call <see cref="M:Un4seen.Bass.Bass.BASS_Free"/> before you can initialize it again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>There is no available device driver... the device may already be in use.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported by the device. Try changing the <paramref name="freq"/> and <paramref name="flags"/> parameters.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device has no 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>On Linux, a 'Default' device is hardcoded to device number 1, which uses the default output set in the ALSA config; that could map directly to one of the other devices or it could use ALSA plugins. If the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DEV_DEFAULT"/> config option has been enbled, a "Default" device is also available on Windows, who's output will follow default device changes on Windows 7. In both cases, the "Default" device will also be the default device (device = -1).</para>
            <para>The sample format specified in the freq and flags parameters has no effect on the device output on iOS or OSX, and not on Windows unless VxD drivers are used (on Windows 98/95); with WDM drivers (on Windows XP/2000/Me/98SE), the output format is automatically set depending on the format of what is played and what the device supports, while on Vista and newer, the output format is determined by the user's choice in the Sound control panel. On Linux, the output device will use the specified format if possible, but will otherwise use a format as close to it as possible. On Android, the device's native sample rate (as reported by the AudioTrack getNativeOutputSampleRate method) will be used unless the BASS_DEVICE_FREQ flag is specified, in which case the freq parameter will be used (this only affects BASS's output format, not the device's output format). If the BASS_DEVICE_FREQ flag is specified on iOS or OSX, then the device's output rate will be set to the freq parameter if possible. The BASS_DEVICE_FREQ flag has no effect on other platforms. BASS_GetInfo can be used to check what the output format actually is.</para>
            <para>The <paramref name="win"/> parameter is only used on Windows and are ignored on other platforms. That applies to the BASS_DEVICE_CPSPEAKERS and BASS_DEVICE_SPEAKERS flags too, as the number of available speakers is always accurately detected on the other platforms. The BASS_DEVICE_LATENCY flag is also ignored on Linux/OSX/Android/Windows CE, as latency information is available without it. The latency is also available without it on iOS, but not immediately following this function call unless the flag is used.</para>
            <para>The BASS_DEVICE_DMIX flag is only available on Linux, and allows multiple applications to share the device (if they all use 'dmix'). It may also be possible for multiple applications to use exclusive access if the device is capable of hardware mixing. If exclusive access initialization fails, the BASS_DEVICE_DMIX flag will automatically be tried; if that happens, it can be detected via <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> and the initflags.</para>
            <para>On Linux and Windows CE, the length of the device's buffer can be set via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DEV_BUFFER"/> config option.</para>
            </remarks>
            <example>
            Initialize BASS with the current form window handle:
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_InitGuid(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="freq"></param>
            <param name="flags"></param>
            <param name="win"></param>
            <param name="clsid"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.Guid)">
            <summary>
            Initializes an output device.
            </summary>
            <param name="device">The device to use... -1 = default device, 0 = no sound, 1 = first real output device.
            <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceCount"/> can be used to get the total number of devices.
            </param>
            <param name="freq">Output sample rate.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSInit"/>):
            <list type="table">
            <item><term>BASS_DEVICE_8BITS</term><description>Use 8-bit resolution, else 16-bit.</description></item>
            <item><term>BASS_DEVICE_MONO</term><description>Use mono, else stereo.</description></item>
            <item><term>BASS_DEVICE_STEREO</term><description>Limit the output to stereo, saving some CPU if the device has more speakers available.</description></item>
            <item><term>BASS_DEVICE_3D</term><description>Enable 3D functionality. If this flag is not specified, then the BASS_SAMPLE_3D flag is ignored when loading/creating a sample/stream/music.</description></item>
            <item><term>BASS_DEVICE_LATENCY</term><description>Calculates the latency of the device, that is the delay between requesting a sound to play and it acually being heard. A recommended minimum buffer length is also calculated. Both values are retrievable in the BASS_INFO structure (latency and minbuf members). These calculations can increase the time taken by this function by 1-3 seconds.</description></item>
            <item><term>BASS_DEVICE_SPEAKERS</term><description>Force the enabling of <a href="../Overview.html#SpeakerAssignement">speaker assignment</a>. With some devices/drivers, the number of speakers BASS detects may be 2, when the device in fact supports more than 2 speakers. This flag forces the enabling of assignment to all 8 possible speakers. This flag has no effect with non-WDM drivers.</description></item>
            <item><term>BASS_DEVICE_CPSPEAKER</term><description>Use the Windows control panel setting to detect the number of speakers. Soundcards generally have their own control panel to set the speaker config, so the Windows control panel setting may not be accurate unless it matches that. This flag has no effect on Vista, as the speakers are already accurately detected.</description></item>
            <item><term>BASS_DEVICE_NOSPEAKER</term><description>Ignore speaker arrangement. This flag tells BASS not to make any special consideration for speaker arrangements when using the SPEAKER flags, eg. swapping the CENLFE and REAR speaker channels in 5/7.1 speaker output. This flag should be used with plain multi-channel (rather than 5/7.1) devices.</description></item>
            <item><term>BASS_DEVICE_DMIX</term><description>Linux only: Initialize the device using the ALSA "dmix" plugin, else initialize the device for exclusive access.</description></item>
            <item><term>BASS_DEVICE_FREQ</term><description>Set the device's output rate to <paramref name="freq"/>, otherwise leave it as it is.</description></item>
            <item><term>BASS_DEVICE_DSOUND</term><description>Initialize the device to use the old DirectSound output system instead of WASAPI. If WASAPI is not available (pre-Vista Windows), then this will be applied automatically.</description></item>
            <item><term>BASS_DEVICE_AUDIOTRACK</term><description>Initialize the device to use AudioTrack output instead of OpenSL ES. If OpenSL ES is not available (pre-2.3 Android), then this will be applied automatically.</description></item>
            </list>
            </param>
            <param name="win">The application's main window... <see cref="F:System.IntPtr.Zero"/> = the desktop window (use this for console applications).</param>
            <param name="clsid">Class identifier of the object to create, that will be used to initialize DirectSound... <see langword="null"/> = use default</param>
            <returns>If the device was successfully initialized, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before using any sample, stream or MOD music functions. The recording functions may be used without having called this function.</para>
            <para>Playback is not possible with the "no sound" device, but it does allow the use of "decoding channels", eg. to decode files.</para>
            <para>When specifying a class identifier (clsid), after successful initialization, you can use <see cref="!:Bass.BASS_GetDSoundObject"/> to retrieve the DirectSound object, and through that access any special interfaces that the object may provide.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/> is used to switch the current device. When successful, BASS_Init automatically sets the current thread's device to the one that was just initialized.</para>
            <para>When using the default device (device = -1), <see cref="M:Un4seen.Bass.Bass.BASS_GetDevice"/> can be used to find out which device it was mapped to. On Windows, it'll always be the first device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. You must call <see cref="M:Un4seen.Bass.Bass.BASS_Free"/> before you can initialize it again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>There is no available device driver... the device may already be in use.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported by the device. Try changing the <paramref name="freq"/> and <paramref name="flags"/> parameters.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device has no 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>On Linux, a 'Default' device is hardcoded to device number 1, which uses the default output set in the ALSA config; that could map directly to one of the other devices or it could use ALSA plugins. If the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DEV_DEFAULT"/> config option has been enbled, a "Default" device is also available on Windows, who's output will follow default device changes on Windows 7. In both cases, the "Default" device will also be the default device (device = -1).</para>
            <para>The sample format specified in the <paramref name="freq"/> and <paramref name="flags"/> parameters has no effect on the device output on iOS or OSX, and not on Windows unless VxD drivers are used (on Windows 98/95); with WDM drivers (on Windows XP/2000/Me/98SE), the output format is automatically set depending on the format of what is played and what the device supports, while on Vista and above, the output format is determined by the user's choice in the Sound control panel. On Linux the output device will use the specified format if possible, but will otherwise use a format as close to it as possible. If the BASS_DEVICE_FREQ flag is specified on iOS or OSX, then the device's output rate will be set to the freq parameter (if possible). The BASS_DEVICE_FREQ flag has no effect on other platforms. <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> can be used to check what the output format actually is.</para>
            <para>The <paramref name="win"/> and <paramref name="clsid"/> parameters are only used on Windows and are ignored on other platforms. That applies to the BASS_DEVICE_CPSPEAKERS and BASS_DEVICE_SPEAKERS flags too, as the number of available speakers is always accurately detected on the other platforms. The BASS_DEVICE_LATENCY flag is also ignored on Linux/OSX/Android/Windows CE, as latency information is available without it. The latency is also available without it on iOS, but not immediately following this function call unless the flag is used.</para>
            <para>The BASS_DEVICE_DMIX flag is only available on Linux, and allows multiple applications to share the device (if they all use 'dmix'). It may also be possible for multiple applications to use exclusive access if the device is capable of hardware mixing. If exclusive access initialization fails, the BASS_DEVICE_DMIX flag will automatically be tried; if that happens, it can be detected via <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> and the initflags.</para>
            <para>On Linux and Windows CE, the length of the device's buffer can be set via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DEV_BUFFER"/> config option.</para>
            </remarks>
            <example>
            Initialize BASS with the current form window handle:
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            </code>
            Initialize BASS/DirectSound with A3D
            <code>
            Guid clsidA3d = new Guid(0xd8f1eee0, 0xf634, 0x11cf, 0x87, 0x0, 0x0, 0xa0, 0x24, 0x5d, 0x91, 0x8b);
            Bass.BASS_Init(-1, 44100, 0, this.Handle, clsidA3d);
            </code>
            <code lang="vbnet">
            Dim clsidA3d As Guid =  New Guid(0xd8f1eee0, 0xf634, 0x11cf, 0x87, 0x0, 0x0, 0xa0, 0x24, 0x5d, 0x91, 0x8b) 
            Bass.BASS_Init(-1, 44100, 0, Me.Handle, clsidA3d)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_IsStarted">
            <summary>
            Checks if the output has been started.
            </summary>
            <returns>If the device has been started, then <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
            <remarks>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfoInternal(System.Int32,Un4seen.Bass.BASS_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog. 
            Device 0 is always the "no sound" device, so if you should start at device 1 if you only want to list real devices.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>On Linux, a "Default" device is hardcoded to device number 1, which uses the default output set in the ALSA config, and the real devices start at number 2.
            That is also the case on Windows when the BASS_CONFIG_DEV_DEFAULT option is enabled.</para>
            <para>On OSX, the BASS_DEVICES_AIRPLAY flag can be used in the <paramref name="device"/> paramater to enumerate Airplay receivers instead of soundcards. 
            A shared buffer is used for the Airplay receiver name information, which gets overwritten each time Airplay receiver information is requested, so it should be copied if needed. 
            The BASS_CONFIG_AIRPLAY config option can be used to change which of the receiver(s) are used.</para>
            </remarks>
            <example>
            List all available devices:
            <code>
            BASS_DEVICEINFO info = new BASS_DEVICEINFO();
            for (int n=0; Bass.BASS_GetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While (Bass.BASS_GetDeviceInfo(n, info))
              Console.WriteLine(info.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an output device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available devices for a setup dialog. 
            Device 0 is always the "no sound" device, so if you should start at device 1 if you only want to list real devices.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>On Linux, a "Default" device is hardcoded to device number 1, which uses the default output set in the ALSA config, and the real devices start at number 2.</para>
            </remarks>
            <example>Find the system default device:
            <code>
            int defDevice = -1;
            BASS_DEVICEINFO info;
            for (int n = 0; (info = Bass.BASS_GetDeviceInfo(n)) != null; n++)
            {
              if (info.IsDefault)
              {
                defDevice = n;
                break;
              }
            }
            </code>
            <code lang="vbnet">
            Dim defDevice As Integer = -1
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While Not (info Is Nothing)
              info = Bass.BASS_GetDeviceDescription(n)
              If Not (info Is Nothing) And info.IsDefault Then
                defDevice = n
                Exit While
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceInfos">
            <summary>
            Returns all available output devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> elements representing the available output devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDeviceCount">
            <summary>
            Returns the total number of available output devices.
            </summary>
            <returns>Number of real output devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_INFO"/> class to store the information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            if ( Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle) )
            {
              BASS_INFO info = new BASS_INFO();
              if (Bass.BASS_GetInfo(info))
                Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle) Then
              Dim info As New BASS_INFO()
              If Bass.BASS_GetInfo(info) Then
                Console.WriteLine(info.ToString())
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetInfo">
            <summary>
            Retrieves information on the device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_INFO"/> class on success - or <see langword="null"/> on error.</returns>
            <remarks>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Check if the current device has DirectSound support:
            <code>
            if ( Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle) )
            {
              BASS_INFO info = Bass.BASS_GetInfo();
              if (info != null &amp;&amp; !info.SupportsDirectSound)
                Console.WriteLine("Device does NOT have DirectSound support");
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle) Then
              Dim info As BASS_INFO = Bass.BASS_GetInfo()
              If info IsNot Nothing AndAlso Not info.SupportsDirectSound Then
                Console.WriteLine("Device does NOT have DirectSound support")
              End If
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ErrorGetCode">
            <summary>
            Retrieves the error code for the most recent BASS function call in the current thread.
            </summary>
            <returns>If no error occured during the last BASS function call then BASS_OK is returned, else one of the <see cref="T:Un4seen.Bass.BASSError"/> values is returned. 
            See the function description for an explanation of what the error code means.</returns>
            <remarks>Error codes are stored for each thread. So if you happen to call 2 or more BASS functions at the same time, they will not interfere with eachother's error codes.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Stop">
            <summary>
            Stops the output, stopping all musics/samples/streams.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function can be used after <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/> to stop the paused channels, so that they will not be resumed the next time <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> is called.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Free">
            <summary>
            Frees all resources used by the output device, including all it's samples, streams, and MOD musics.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized devices before your program exits. It's not necessary to individually free the samples/streams/musics as these are all automatically freed by this function.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            ...
            // create the stream for device 1
            Bass.BASS_SetDevice(1);
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // create the stream for device 2
            Bass.BASS_SetDevice(2);
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // free any initialized device
            Bass.BASS_SetDevice(1);
            Bass.BASS_Free();
            Bass.BASS_SetDevice(2);
            Bass.BASS_Free();
            </code>
            <code lang="vbnet">
            ' init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            ...
            ' create the stream for device 1
            Bass.BASS_SetDevice(1)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ' create the stream for device 2
            Bass.BASS_SetDevice(2)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' free any initialized device
            Bass.BASS_SetDevice(1)
            Bass.BASS_Free()
            Bass.BASS_SetDevice(2)
            Bass.BASS_Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetVersion">
            <summary>
            Retrieves the version number of the BASS.DLL that is loaded.
            </summary>
            <returns>The BASS version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASS supports all the BASS functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.Bass.Bass.BASSVERSION"/> to check the major revision.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(Bass.BASS_GetVersion()) != Bass.BASSVERSION )
            {
              MessageBox.Show(this, "Wrong Bass Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(Bass.BASS_GetVersion()) &lt;&gt; Bass.BASSVERSION Then
              MessageBox.Show(Me, "Wrong Bass Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (Bass.BASS_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong Bass Version!");
            }
            </code>
            <code lang="vbnet">
            If Bass.BASS_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong Bass Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASS.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASS version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASS supports all the BASS functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.</remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (Bass.BASS_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong Bass Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If Bass.BASS_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong Bass Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)">
            <summary>
            Sets the device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = no sound, 1 = first real output device.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The functions that use the device selection are the following: 
            <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="!:Bass.BASS_GetDSoundObject"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SetVolume(System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetVolume"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Set3DFactors(System.Single,System.Single,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Get3DFactors(System.Single@,System.Single@,System.Single@)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Get3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, <see cref="!:Bass.BASS_SetEAXParameters"/>, <see cref="!:Bass.BASS_GetEAXParameters"/>. 
            It also determines which device is used by a new sample/stream/music: <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, etc...</para>
            <para>When one of the above functions (or <see cref="M:Un4seen.Bass.Bass.BASS_GetDevice"/>) is called, BASS will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized. This means that when using a single device, there is no need to use this function; BASS will automatically use the device that is initialized. Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            // now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            // now device 2 is the current one
            ...
            // create the stream for device 1
            Bass.BASS_SetDevice(1);
            // now device 1 is the current one
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // create the stream for device 2
            Bass.BASS_SetDevice(2);
            // now device 2 is the current one
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // free any initialized device
            Bass.BASS_SetDevice(1);
            Bass.BASS_Free();
            Bass.BASS_SetDevice(2);
            Bass.BASS_Free();
            </code>
            <code lang="vbnet">
            ' init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            ' now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            ' now device 2 is the current one
            ...
            ' create the stream for device 1
            Bass.BASS_SetDevice(1)
            ' now device 1 is the current one
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ' create the stream for device 2
            Bass.BASS_SetDevice(2)
            ' now device 2 is the current one
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' free any initialized device
            Bass.BASS_SetDevice(1)
            Bass.BASS_Free()
            Bass.BASS_SetDevice(2)
            Bass.BASS_Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetDevice">
            <summary>
            Retrieves the device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/>to get the error code.</returns>
            <remarks>See also <seealso cref="M:Un4seen.Bass.Bass.BASS_ChannelGetDevice(System.Int32)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called - there are no initialized devices.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)">
            <summary>
            "Manually" updates the HSTREAM and HMUSIC channel buffers.
            </summary>
            <param name="length">The amount to render, in milliseconds.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When automatic updating is disabled, this function (or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/>) needs to be called to keep the playback buffers updated. 
            The length parameter should include some safety margin, in case the next update cycle gets delayed. 
            For example, if calling this function every 100ms, 200 would be a reasonable length parameter.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Updating is already in progress.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetCPU">
            <summary>
            Retrieves the current CPU usage of BASS.
            </summary>
            <returns>The BASS CPU usage as a percentage of total CPU time.</returns>
            <remarks>
            <para>This function includes the time taken to render stream (HSTREAM) and MOD music (HMUSIC) channels during playback, and any DSP functions set on those channels. Also, any FX that are not using the "with FX flag" DX8 effect implementation.</para>
            <para>The rendering of some add-on stream formats may not be entirely included, if they use additional decoding threads. See the add-on documentation for details.</para>
            <para>This function does not strictly tell the CPU usage, but rather how timely the buffer updates are. For example, if it takes 10ms to render 100ms of data, that would be 10%. If the reported usage gets to 100%, that means the channel data is being played faster than it can be rendered, and buffer underruns are likely to occur.</para>
            <para>If automatic updating is disabled, then the value returned by this function is only updated after each call to <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/>. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> usage is not included.</para>
            <para><b>Platform-specific</b></para>
            <para>On Windows, the CPU usage does not include sample channels (HCHANNEL), which are mixed by the output device/drivers (hardware mixing) or Windows (software mixing). On other platforms, the CPU usage does include sample playback as well as the generation of the final output mix.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Start">
            <summary>
            Starts (or resumes) the output.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The output is automatically started by <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>, so there is no need to use this function unless you've stopped or paused the output.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Pause">
            <summary>
            Stops the output, pausing all musics/samples/streams.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> to resume the output and paused channels.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetVolume(System.Single)">
            <summary>
            Sets the output master volume.
            </summary>
            <param name="volume">The volume level... 0 (silent) to 1 (max).</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The actual volume level may not be exactly the same as requested, due to underlying precision differences. 
            <see cref="M:Un4seen.Bass.Bass.BASS_GetVolume"/> can be used to confirm what the volume is.
            <para>This function affects the volume level of all applications using the same output device. 
            If you wish to only affect the level of your app's sounds, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> and/or the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_GVOL_MUSIC / BASS_CONFIG_GVOL_SAMPLE / BASS_CONFIG_GVOL_STREAM</see> config options should be used instead.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="volume"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetVolume">
            <summary>
            Retrieves the current master volume level.
            </summary>
            <returns>If successful, the volume level is returned, else -1.0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The volume level... 0 (silent) to 1 (max) will be returned.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">
            <summary>
            Sets the value of a config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <param name="newvalue">The new option value (as an int). See the option's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_3DALGORITHM</term><description>The 3D algorithm for software mixed 3D channels.
            <para>newvalue (int): Use one of these algorithms <see cref="T:Un4seen.Bass.BASS3DAlgorithm"/></para>
            <para>These algorithms only affect 3D channels that are being mixed in software. You can check if a channel is being software mixed with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>This config option allows you to use higher quality 3D processing on more powerful CPUs, and more efficient 3D processing on less powerful CPUs. Changing the algorithm only affects subsequently created or loaded samples, musics or streams, it does not affect those that already exist.</para>
            </description></item>
            <item><term>BASS_CONFIG_ASYNCFILE_BUFFER</term><description>The buffer length for asynchronous file reading.
            <para>length (int): The buffer length in bytes. This will be rounded up to the nearest 4096 byte (4KB) boundary.</para>
            <para>This determines the amount of file data that can be read ahead of time with asynchronous file reading. The default setting is 65536 bytes (64KB).</para>
            <para>Using this config option only affects channels that are created afterwards, not any that have already been created. So it is possible to have channels with differing buffer lengths by using this config option each time before creating them.</para>
            </description></item>
            <item><term>BASS_CONFIG_BUFFER</term><description>Playback buffer length.
            <para>newvalue (int): The buffer length in milliseconds. The minimum length is 1ms above the update period (BASS_CONFIG_UPDATEPERIOD), the maximum is 5000 milliseconds. If the length specified is outside this range, it is automatically capped.</para>
            <para>The default buffer length is 500 milliseconds. Increasing the length, decreases the chance of the sound possibly breaking-up on slower computers, but also increases the latency for DSP/FX.</para>
            <para>Small buffer lengths are only required if the sound is going to be changing in real-time, for example, in a soft-synth. If you need to use a small buffer, then the minbuf member of BASS_INFO should be used to get the recommended minimum buffer length supported by the device and it's drivers. Even at this default length, it's still possible that the sound could break up on some systems, it's also possible that smaller buffers may be fine. So when using small buffers, you should have an option in your software for the user to finetune the length used, for optimal performance.</para>
            <para>Using this config option only affects the HMUSIC/HSTREAM channels that you create afterwards, not the ones that have already been created. So you can have channels with differing buffer lengths by using this config option each time before creating them.</para>
            <para>If automatic updating is disabled, make sure you call BASS_Update frequently enough to keep the buffers updated.</para>
            </description></item>
            <item><term>BASS_CONFIG_DEV_BUFFER</term><description>The output device buffer length (Linux and Windows CE).
            <para>newvalue (int): The buffer length in milliseconds.</para>
            <para>The device buffer is where the final mix of all playing channels is placed, ready for the device to play. Its length affects the latency of things like starting and stopping playback of a channel, so you will probably want to avoid setting it unnecessarily high, but setting it too short could result in breaks in the output.</para>
            <para>When using a large device buffer, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_NOBUFFER"/> attribute could be used to skip the channel buffering stage, to avoid further increasing latency for real-time generated sound and/or DSP/FX changes.</para>
            <para>Changes to this config setting only affect subsequently initialized devices, not any that are already initialized.</para>
            <para>This config option is only available on Linux and Windows CE. The device's buffer is determined automatically on other platforms. On Linux, the driver may choose to use a different buffer length if it decides that the specified length is too short or long. The buffer length actually being used can be obtained with <see cref="T:Un4seen.Bass.BASS_INFO"/>, like this: latency + minbuf / 2.</para>
            </description></item>
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.
            <para>newvalue (bool): Volume curve... <see langword="false"/> = linear, <see langword="true"/> = logarithmic.</para>
            <para>DirectSound uses logarithmic volume and panning curves, which can be awkward to work with. 
            For example, with a logarithmic curve, the audible difference between 10000 and 9000, is not the same as between 9000 and 8000. 
            With a linear "curve" the audible difference is spread equally across the whole range of values, so in the previous example the audible difference between 10000 and 9000, and between 9000 and 8000 would be identical.</para>
            <para>When using the linear curve, the volume range is from 0% (silent) to 100% (full). 
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full). For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.
            <para>newvalue (bool): Panning curve... <see langword="false"/> = linear, <see langword="true"/> = logarithmic.</para>
            <para>The panning curve affects panning in exactly the same way as the volume curve (BASS_CONFIG_CURVE_VOL) affects the volume.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?
            <para>newvalue (bool): If <see langword="true"/>, 32-bit floating-point sample data is passed to all <see cref="T:Un4seen.Bass.DSPPROC"/> callback functions.</para>
            <para>Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit. But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing it to DSP functions, and then convert it back after all the DSP functions are done. As well as simplifying the DSP code (no need for 8/16-bit processing), this also means that there is no degradation of quality as sample data passes through a chain of DSP.</para>
            <para>This option also affects DX8 effects when using the "without FX flag" DX8 effect implementation. Note that floating-point FX processing requires DX9 or above.</para>
            </description></item>
            <item><term>BASS_CONFIG_GVOL_MUSIC</term><description>Global music volume.
            <para>newvalue (int): MOD music global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the MOD musics, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </description></item>
            <item><term>BASS_CONFIG_GVOL_SAMPLE</term><description>Global sample volume.
            <para>newvalue (int): Sample global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the samples, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </description></item>
            <item><term>BASS_CONFIG_GVOL_STREAM</term><description>Global stream volume.
            <para>newvalue (int): Stream global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the streams, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use.
            <para>newvalue (int): The MP3 decoder to use... 0 = BASS, 1 = Windows.</para>
            <para>Most Windows users will have an MP3 codec installed - it comes preinstalled with modern Windows (ME/2K/XP), and can be installed on older Windows, eg. with Windows Media Player. By default, BASS will use it's own built-in MP3 decoder, as it provides better performance, but the Windows codec can be used instead.</para>
            <para>When using the Windows codec, BASS still does the file processing, so all the usual features are still supported, including streaming, tag reading, pre-scanning, gapless playback, etc...</para>
            <para>If the Windows codec option is chosen, but an MP3 codec is not installed, then MP3 files/streams will not be playable and the stream/sample creation functions will produce a BASS_ERROR_CODEC error.</para>
            </description></item>
            <item><term>BASS_CONFIG_MUSIC_VIRTUAL</term><description>The maximum number of virtual channels to use in the rendering of IT files.
            <para>newvalue (int): The number of virtual channels... 1 (min) - 512 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>This setting only affects IT files, as the other MOD music formats do not have virtual channels. The default setting is 64. Changes only apply to subsequently loaded files, not any that are already loaded.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PLAYLIST</term><description>Process URLs in PLS and M3U playlists?
            <para>newvalue (int): When to process URLs in PLS and M3U playlists... 0 = never, 1 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> only, 2 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> too.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_BUFFER</term><description>Internet download buffer length.
            <para>newvalue (int): The buffer length, in milliseconds.</para>
            <para>Increasing the buffer length decreases the chance of the stream stalling, but also increases the time taken by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> to create the stream, as it has to pre-buffer more data (adjustable via the BASS_CONFIG_NET_PREBUF config option). Aside from the pre-buffering, this setting has no effect on streams without either the BASS_STREAM_BLOCK or BASS_STREAM_RESTRATE flags.</para>
            <para>When streaming in blocks, this option determines the download buffer length. The effective buffer length can actually be a bit more than that specified, including data that's been read from the buffer by the decoder but not been used yet.</para>
            <para>This config option also determines the buffering used by "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>The default buffer length is 5 seconds (5000 milliseconds). The net buffer length should be larger than the length of the playback buffer (BASS_CONFIG_BUFFER), otherwise the stream is likely to briefly stall soon after starting playback.</para>
            <para>Using this config option only affects streams created afterwards, not any that have already been created.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?
            <para>passive (bool): If <see langword="true"/>, passive mode is used, otherwise normal/active mode is used.</para>
            <para>Changes take effect from the next internet stream creation call. By default, passive mode is disabled.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PREBUF</term><description>Amount to pre-buffer when opening internet streams.
            <para>newvalue (int): Amount (percentage) to pre-buffer.</para>
            <para>This setting determines what percentage of the buffer length (BASS_CONFIG_NET_BUFFER) should be filled by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. The default is 75%. Setting this lower (eg. 0) is useful if you want to display a "buffering progress" (using <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>) when opening internet streams, but note that this setting is just a minimum - BASS will always pre-download a certain amount to verify the stream</para>
            <para>As well as internet streams, this config setting also applies to "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_TIMEOUT</term><description>Time to wait for a server to respond to a connection request.
            <para>newvalue (int): The time to wait, in milliseconds.</para>
            <para>The default timeout is 5 seconds (5000 milliseconds).</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_READTIMEOUT</term><description>The time to wait for a server to deliver more data for an internet stream.
            <para>newvalue (int): The time to wait, in milliseconds... 0 = no timeout.</para>
            <para>When the timeout is hit, the connection with the server will be closed. The default setting is 0, no timeout.</para>
            </description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?
            <para>newvalue (bool): If <see langword="true"/>, channels can't be played while the output is paused.</para>
            <para>When the output is paused using <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, and this config option is enabled, channels can't be played until the output is resumed using <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>. Attempts to play a channel will give a BASS_ERROR_START error.</para>
            </description></item>
            <item><term>BASS_CONFIG_REC_BUFFER</term><description>The buffer length for recording channels.
            <para>newvalue (int): The buffer length in milliseconds... 1000 (min) - 5000 (max). If the length specified is outside this range, it is automatically capped.</para>
            <para>Unlike a playback buffer, where the aim is to keep the buffer full, a recording buffer is kept as empty as possible and so this setting has no effect on latency. The default recording buffer length is 2000 milliseconds. Unless processing of the recorded data could cause significant delays, or you want to use a large recording period with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>, there should be no need to increase this.</para>
            <para>Using this config option only affects the recording channels that are created afterwards, not any that have already been created. So it is possible to have channels with differing buffer lengths by using this config option each time before creating them.</para>
            </description></item>
            <item><term>BASS_CONFIG_SRC</term><description>The default sample rate conversion quality.
            <para>quality (int): The sample rate conversion quality... 0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation, 4 = 64 point sinc interpolation. Other values are also accepted.</para>
            <para>This config option determines what sample rate conversion quality new channels will initially have, except for sample channels (HCHANNEL), which use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SRC_SAMPLE"/> setting.
            A channel's sample rate conversion quality can subsequently be changed via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SRC"/> attribute.</para>
            <para>The default setting is 1 (8 point sinc interpolation).</para>
            </description></item>
            <item><term>BASS_CONFIG_SRC_SAMPLE</term><description>The default sample rate conversion quality for samples.
            <para>quality (int): The sample rate conversion quality... 0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation, 4 = 64 point sinc interpolation. Other values are also accepted.</para>
            <para>This config option determines what sample rate conversion quality a new sample channel will initially have, following a <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/> call.
            The channel's sample rate conversion quality can subsequently be changed via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SRC"/> attribute.</para>
            <para>The default setting is 0 (linear interpolation).</para>
            </description></item>
            <item><term>BASS_CONFIG_UPDATEPERIOD</term><description>Update period of playback buffers.
            <para>newvalue (int): The update period in milliseconds... 0 = disable automatic updating. The minimum period is 5ms, the maximum is 100ms. If the period specified is outside this range, it is automatically capped.</para>
            <para>The update period is the amount of time between updates of the playback buffers of HSTREAM/HMUSIC channels. Shorter update periods allow smaller buffers to be set with the BASS_CONFIG_BUFFER config option, but as the rate of updates increases, so the overhead of setting up the updates becomes a greater part of the CPU usage. The update period only affects HSTREAM and HMUSIC channels, it does not affect samples. Nor does it have any effect on decoding channels, as they are not played.</para>
            <para>BASS creates a thread specifically to perform the updating, except when automatic updating is disabled (period=0) - then you must regularly call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> instead. This allows you to synchronize BASS's CPU usage with your program's. For example, in a game loop you could call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> once per frame, which keeps all the processing in sync so that the frame rate is as smooth as possible. <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> should be called at least around 8 times per second, even more often if the BASS_CONFIG_BUFFER config option is used to set smaller buffers.</para>
            <para>The update period can be altered at any time, including during playback. The default period is 100ms.</para>
            </description></item>
            <item><term>BASS_CONFIG_UPDATETHREADS</term><description>Number of update threads.
            <para>newvalue (int): The number of threads to use... 0 = disable automatic updating.</para>
            <para>The number of update threads determines how many HSTREAM/HMUSIC channel playback buffers can be updated in parallel; each thread can process one channel at a time. The default is to use a single thread, but additional threads can be used to take advantage of multiple CPU cores. There is generally nothing much to be gained by creating more threads than there are CPU cores, but one benefit of using multiple threads even with a single CPU core is that a slow updating channel need not delay the updating of other channels.</para>
            <para>When automatic updating is disabled (threads = 0), <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> should be used instead.</para>
            <para>The number of update threads can be changed at any time, including during playback.</para>
            </description></item>
            <item><term>BASS_CONFIG_VERIFY</term><description>The amount of data to check in order to verify/detect the file format.
            <para>length (int): The amount of data to check, in bytes... 1000 (min) to 100000 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats, 
            but it may also be used by add-ons (see the documentation). For internet (and "buffered" user file) streams, a quarter of the length is used, up to a minimum of 1000 bytes.</para>
            <para>The verification length excludes any tags that may be at the start of the file. The default length is 16000 bytes.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Setting the playback buffer to 100ms and the update period to 20ms:
            <code>
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100);
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20);
            </code>
            <code lang="vbnet">
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Boolean)">
            <summary>
            Sets the value of a config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <param name="newvalue">The new option value (as a bool). See the option's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.
            <para>newvalue (bool): Volume curve... <see langword="false"/> = linear, <see langword="true"/> = logarithmic.</para>
            <para>DirectSound uses logarithmic volume and panning curves, which can be awkward to work with. 
            For example, with a logarithmic curve, the audible difference between 10000 and 9000, is not the same as between 9000 and 8000. 
            With a linear "curve" the audible difference is spread equally across the whole range of values, so in the previous example the audible difference between 10000 and 9000, and between 9000 and 8000 would be identical.</para>
            <para>When using the linear curve, the volume range is from 0% (silent) to 100% (full). 
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full). For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.
            <para>newvalue (bool): Panning curve... <see langword="false"/> = linear, <see langword="true"/> = logarithmic.</para>
            <para>The panning curve affects panning in exactly the same way as the volume curve (BASS_CONFIG_CURVE_VOL) affects the volume.</para>
            <para>The linear curve is used by default.</para>
            </description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?
            <para>newvalue (bool): If <see langword="true"/>, 32-bit floating-point sample data is passed to all <see cref="T:Un4seen.Bass.DSPPROC"/> callback functions.</para>
            <para>Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit. But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing it to DSP functions, and then convert it back after all the DSP functions are done. As well as simplifying the DSP code (no need for 8/16-bit processing), this also means that there is no degradation of quality as sample data passes through a chain of DSP.</para>
            <para>This option also affects DX8 effects when using the "without FX flag" DX8 effect implementation. Note that floating-point FX processing requires DX9 or above.</para>
            </description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use.
            <para>newvalue (bool): The MP3 decoder to use... <see langword="false"/> = BASS, <see langword="true"/> = Windows.</para>
            <para>Most Windows users will have an MP3 codec installed - it comes preinstalled with modern Windows (ME/2K/XP), and can be installed on older Windows, eg. with Windows Media Player. By default, BASS will use it's own built-in MP3 decoder, as it provides better performance, but the Windows codec can be used instead.</para>
            <para>When using the Windows codec, BASS still does the file processing, so all the usual features are still supported, including streaming, tag reading, pre-scanning, gapless playback, etc...</para>
            <para>If the Windows codec option is chosen, but an MP3 codec is not installed, then MP3 files/streams will not be playable and the stream/sample creation functions will produce a BASS_ERROR_CODEC error.</para>
            </description></item>
            <item><term>BASS_CONFIG_OGG_PRESCAN</term><description>Pre-scan chained OGG files?
            <para>prescan (bool): If <see langword="true"/>, chained OGG files are pre-scanned.</para>
            <para>This option is enabled by default, and is equivalent to including the BASS_STREAM_PRESCAN flag in a <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call when opening an OGG file. It can be disabled if seeking and an accurate length reading are not required from chained OGG files, for faster stream creation.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?
            <para>passive (bool): If <see langword="true"/>, passive mode is used, otherwise normal/active mode is used.</para>
            <para>Changes take effect from the next internet stream creation call. By default, passive mode is disabled.</para>
            </description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?
            <para>newvalue (bool): If <see langword="true"/>, channels can't be played while the output is paused.</para>
            <para>When the output is paused using <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, and this config option is enabled, channels can't be played until the output is resumed using <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>. Attempts to play a channel will give a BASS_ERROR_START error.</para>
            </description></item>
            <item><term>BASS_CONFIG_DEV_DEFAULT</term><description>Include a 'Default' entry in the output device list?
            <para>default (bool): If <see langword="true"/>, a 'Default' device will be included in the device list.</para>
            <para>BASS does not usually include a 'Default' entry in its device list, as that would ultimately map to one of the other devices and be a duplicate entry. When the default device is requested in a <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call (with device = -1), BASS will check the default device at that time, and initialize it. But Windows 7 has the ability to automatically switch the default output to the new default device whenever it changes, and in order for that to happen, the default device (rather than a specific device) needs to be used. That is where this option comes in.</para>
            <para>When enabled, the 'Default' device will also become the default device to <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> (with device = -1). When the "Default" device is used, the <see cref="M:Un4seen.Bass.Bass.BASS_SetVolume(System.Single)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_GetVolume"/> functions work a bit differently to usual; they deal with the "session" volume, which only affects the current process's output on the device, rather than the device's volume.</para>
            <para>This option can only be set before <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has been called.</para>
            <para>This config option is only available on Windows. It is available on all Windows versions (not including CE), but only Windows 7 has the default output switching feature.</para>
            </description></item>
            <item><term>BASS_CONFIG_VISTA_SPEAKERS</term><description>Enable <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> with panning/balance control on Windows Vista and newer?
            <para>enable (bool): If <see langword="true"/>, speaker assignment with panning/balance control is enabled on Windows Vista and newer.</para>
            <para>Panning/balance control via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_PAN"/> attribute is not available when <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> is used on Windows due to the way that the speaker assignment needs to be implemented there. The situation is improved with Windows Vista, and speaker assignment can generally be done in a way that does permit panning/balance control to be used at the same time, but there may still be some drivers that it does not work properly with, so it is disabled by default and can be enabled via this config option. Changes only affect channels that are created afterwards, not any that already exist.</para>
            <para><b>Platform-specific:</b> This config option is only available on Windows. It is available on all Windows versions (not including CE), but only has effect on Windows Vista and newer. Speaker assignment with panning/balance control is always possible on other platforms, where BASS generates the final mix.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Setting the DSP processing to 32-bit float:
            <code>
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP, true);
            </code>
            <code lang="vbnet">
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfigPtr(Un4seen.Bass.BASSConfig,System.IntPtr)">
            <summary>
            Sets the value of a pointer config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <param name="newvalue">The new option value (as an IntPtr). See the option's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.
            <para>newvalue (IntPtr): The "User-Agent" header.</para>
            <para>BASS does make a copy of the header string, so it doesn't have to reside in the heap.</para>
            <para>Changes take effect from the next internet stream creation call.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.
            <para>newvalue (IntPtr): The "User-Agent" header.</para>
            <para>The proxy server settings, in the form of "user:pass@server:port"... <see langword="null"/> = don't use a proxy. "" (empty string) = use the default proxy settings. 
            If only the "user:pass@" part is specified, then those authorization credentials are used with the default proxy server. 
            If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.</para>
            <para>BASS does make a copy of the proxy string, so it doesn't have to reside in the heap.</para>
            <para>Changes take effect from the next internet stream creation call. By default, BASS will use the Windows proxy settings, as set in the Internet Properties control panel.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            As the BASS_CONFIG_NET_PROXY and BASS_CONFIG_NET_AGENT options take a pointer to an ANSI string as an argument (unless you add the BASS_UNICODE flag).
            Alternatively you might also use the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfigString(Un4seen.Bass.BASSConfig,System.String)"/> method, which always supports unicode.
            <para>The following example copies the contents of a managed String into unmanaged memory:</para>
            <code>
            // create an unmanaged pointer containing a copy of the string
            IntPtr myUserAgentPtr = Marshal.StringToHGlobalAnsi("radio42");
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, myUserAgentPtr);
            // make sure to free the myUserAgentPtr!
            Marshal.FreeHGlobal(myUserAgentPtr);
            </code>
            <code lang="vbnet">
            ' create an unmanaged pointer containing a copy of the string
            Dim myUserAgentPtr As IntPtr = Marshal.StringToHGlobalAnsi("radio42")
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, myUserAgentPtr)
            ' make sure to free the myUserAgentPtr!
            Marshal.FreeHGlobal(myUserAgentPtr)
            </code>
            If you need to dynamically change the BASS_CONFIG_NET_PROXY or BASS_CONFIG_NET_AGENT option, 
            you will need to call <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> each time again!
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SetConfigString(Un4seen.Bass.BASSConfig,System.String)">
            <summary>
            Sets the value of a string config option.
            </summary>
            <param name="option">The option to set the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>; the BASS_UNICODE flag is added automatically).</param>
            <param name="newvalue">The new option value (as a unicode string). See the option's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.
            <para>newvalue (string): The "User-Agent" header.</para>
            <para>BASS does make a copy of the header string, so you do not need to keep it. Changes take effect from the next internet stream creation call.</para>
            </description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.
            <para>newvalue (string): The "User-Agent" header.</para>
            <para>The proxy server settings, in the form of "user:pass@server:port"... <see langword="null"/> = don't use a proxy. "" (empty string) = use the default proxy settings. 
            If only the "user:pass@" part is specified, then those authorization credentials are used with the default proxy server. 
            If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.</para>
            <para>BASS does make a copy of the proxy string, so you do not need to keep it. Changes take effect from the next internet stream creation call.</para>
            <para>By default, BASS will use the Windows proxy settings, as set in the Internet Properties control panel.</para>
            </description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, "radio42");
            </code>
            <code lang="vbnet">
            Bass.BASS_SetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT, "radio42")
            </code>
            If you need to change the BASS_CONFIG_NET_PROXY or BASS_CONFIG_NET_AGENT option, 
            you will need to call <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> again!
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a config option.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as an int), else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_3DALGORITHM</term><description>The 3D algorithm for software mixed 3D channels.</description></item>
            <item><term>BASS_CONFIG_ASYNCFILE_BUFFER</term><description>Asynchronous file reading buffer length.</description></item>
            <item><term>BASS_CONFIG_BUFFER</term><description>Playback buffer length.</description></item>
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.</description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.</description></item>
            <item><term>BASS_CONFIG_DEV_BUFFER</term><description>Output device buffer length (Linux and Windows CE only).</description></item>
            <item><term>BASS_CONFIG_DEV_DEFAULT</term><description>Include a "Default" entry in the output device list?</description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?</description></item>
            <item><term>BASS_CONFIG_GVOL_MUSIC</term><description>Global music volume.</description></item>
            <item><term>BASS_CONFIG_GVOL_SAMPLE</term><description>Global sample volume.</description></item>
            <item><term>BASS_CONFIG_GVOL_STREAM</term><description>Global stream volume.</description></item>
            <item><term>BASS_CONFIG_MUSIC_VIRTUAL</term><description>The maximum number of virtual channels to use in the rendering of IT files.</description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use... 0 = BASS, 1 = Windows.</description></item>
            <item><term>BASS_CONFIG_OGG_PRESCAN</term><description>Pre-scan chained OGG files?</description></item>
            <item><term>BASS_CONFIG_NET_PLAYLIST</term><description>Process URLs in PLS and M3U playlists?</description></item>
            <item><term>BASS_CONFIG_NET_BUFFER</term><description>Internet download buffer length.</description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.</description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?</description></item>
            <item><term>BASS_CONFIG_NET_PREBUF</term><description>Amount to pre-buffer when opening internet streams.</description></item>
            <item><term>BASS_CONFIG_NET_TIMEOUT</term><description>Time to wait for a server to respond to a connection request.</description></item>
            <item><term>BASS_CONFIG_NET_READTIMEOUT</term><description>Time to wait for a server to deliver more data.</description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?</description></item>
            <item><term>BASS_CONFIG_REC_BUFFER</term><description>Recording buffer length.</description></item>
            <item><term>BASS_CONFIG_SRC</term><description>Default sample rate conversion quality.</description></item>
            <item><term>BASS_CONFIG_SRC_SAMPLE</term><description>Default sample rate conversion quality for samples.</description></item>
            <item><term>BASS_CONFIG_UPDATEPERIOD</term><description>Update period of playback buffers.</description></item>
            <item><term>BASS_CONFIG_UPDATETHREADS</term><description>Number of update threads.</description></item>
            <item><term>BASS_CONFIG_VERIFY</term><description>File format verification length.</description></item>
            <item><term>BASS_CONFIG_VISTA_SPEAKERS</term><description>Enable <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> with panning/balance control on Windows Vista and newer?</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the current playback buffer length:
            <code>
            int bufLen = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER);
            </code>
            <code lang="vbnet">
            Dim bufLen As Integer = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfigBool(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a config option as a bool.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as a bool). Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_CURVE_VOL</term><description>Volume translation curve.</description></item>
            <item><term>BASS_CONFIG_CURVE_PAN</term><description>Panning translation curve.</description></item>
            <item><term>BASS_CONFIG_FLOATDSP</term><description>Pass 32-bit floating-point sample data to all DSP functions?</description></item>
            <item><term>BASS_CONFIG_MP3_CODEC</term><description>The MP3 decoder to use... <see langword="false"/> = BASS, <see langword="true"/> = Windows.</description></item>
            <item><term>BASS_CONFIG_NET_PASSIVE</term><description>Use passive mode in FTP connections?</description></item>
            <item><term>BASS_CONFIG_PAUSE_NOPLAY</term><description>Prevent channels being played when the output is paused?</description></item>
            <item><term>BASS_CONFIG_VISTA_SPEAKERS</term><description>Enable <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> with panning/balance control on Windows Vista and newer?</description></item>
            <item><term>BASS_CONFIG_OGG_PRESCAN</term><description>Pre-scan chained OGG files?</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the DSP processing option:
            <code>
            bool floatDSP = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP);
            </code>
            <code lang="vbnet">
            Dim floatDSP As Boolean = Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_FLOATDSP)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfigPtr(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a pointer config option.
            </summary>
            <param name="option">The option to get the value of...(see <see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as an IntPtr). Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.</description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the current user agent header:
            <code>
            string userAgent = String.Empty;
            IntPtr p = Bass.BASS_GetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT);
            if (p != IntPtr.Zero)
            {
              userAgent = Utils.IntPtrAsStringAnsi(p);
            }
            </code>
            <code lang="vbnet">
            Dim userAgent As String = [String].Empty
            Dim p As IntPtr = Bass.BASS_GetConfigPtr(BASSConfig.BASS_CONFIG_NET_AGENT)
            If p &lt;&gt; IntPtr.Zero Then
              userAgent = Utils.IntPtrAsStringAnsi(p)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_GetConfigString(Un4seen.Bass.BASSConfig)">
            <summary>
            Retrieves the value of a pointer config option as an Ansi string.
            </summary>
            <param name="option">The option to get the value of... one of the following (<see cref="T:Un4seen.Bass.BASSConfig"/>).</param>
            <returns>If successful, the value of the requested config option is returned (as an Ansi String). Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Options:
            <list type="table">
            <item><term>BASS_CONFIG_NET_AGENT</term><description>"User-Agent" header.</description></item>
            <item><term>BASS_CONFIG_NET_PROXY</term><description>Proxy server settings.</description></item>
            </list>
            <i>Other config options may be supported by Add-Ons, see the documentation.</i>
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="option"/> is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the current user agent header:
            <code>
            string userAgent = Bass.BASS_GetConfigString(BASSConfig.BASS_CONFIG_NET_AGENT);
            if (userAgent != null)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            Dim userAgent As String = Bass.BASS_GetConfigString(BASSConfig.BASS_CONFIG_NET_AGENT)
            If Not (userAgent Is Nothing) Then
              ...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoadUnicode(System.String,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="file"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)">
            <summary>
            Plugs on "add-on" into the standard stream and sample creation functions.
            <para>This overload implements the Unicode version for the file name.</para>
            </summary>
            <param name="file">Filename of the add-on/plugin.</param>
            <returns>If successful, the loaded plugin's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>There are 2 ways in which add-ons can provide support for additional formats. They can provide dedicated functions to create streams of the specific format(s) they support and/or they can plug into the standard stream creation functions: 
            <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, and <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>. This function enables the latter method. Both methods can be used side by side. 
            The obvious advantage of the plugin system is convenience, while the dedicated functions can provide extra options that are not possible via the shared function interfaces. See an add-on's documentation for more specific details on it.</para>
            <para>As well as the stream creation functions, plugins also add their additional format support to <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>Information on what file formats a plugin supports is available via the <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> function.</para>
            <para>When using multiple plugins, the stream/sample creation functions will try each of them in the order that they were loaded via this function, until one that accepts the file is found.
            When an add-on is already loaded (eg. if you are using functions from it), the plugin system will use the same instance (the reference count will just be incremented); there will not be 2 copies of the add-on in memory.</para>
            <para>Note: Only stream/music add-ons are loaded (e.g. bass_fx.dll or bassmix.dll are NOT loaded).</para>
            <para><b>Platform-specific:</b></para>
            <para>Dynamic libraries are not permitted on iOS, so add-ons are provided as static libraries instead, which means this function has to work a little differently. The add-on needs to be linked into the executable, and a "plugin" symbol declared and passed to this function (instead of a filename).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="file"/> is not a plugin.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The <paramref name="file"/> is already plugged in.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Add-On residing in same directory:
            <code>
            // load the FLAC add-on
            int pluginFlac = Bass.BASS_PluginLoad("bassflac.dll");
            ...
            // use the add-on
            int stream = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac);
            </code>
            <code lang="vbnet">
            ' load the FLAC add-on
            Dim pluginFlac As Integer = Bass.BASS_PluginLoad("bassflac.dll")
            ...
            ' use the add-on
            Dim stream As Integer = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginFree(System.Int32)">
            <summary>
            Unplugs an add-on.
            </summary>
            <param name="handle">The plugin handle... 0 = all plugins.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If there are streams created by a plugin in existence when it is being freed, the streams will automatically be freed too. Samples loaded by the plugin are unaffected as the plugin has nothing to do with them once they are loaded (the sample data is already fully decoded).
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Add-On residing in same directory:
            <code>
            // load the FLAC add-on
            int pluginFlac = Bass.BASS_PluginLoad("bassflac.dll");
            ...
            // use the add-on
            int stream = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT);
            ...
            // un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac);
            </code>
            <code lang="vbnet">
            ' load the FLAC add-on
            Dim pluginFlac As Integer = Bass.BASS_PluginLoad("bassflac.dll")
            ...
            ' use the add-on
            Dim stream As Integer = Bass.BASS_StreamCreateFile("file.flac", 0, 0, BASSFlag.BASS_DEFAULT)
            ...
            ' un-load the FLAC add-on
            Bass.BASS_PluginFree(pluginFlac)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)">
            <summary>
            Tries to loads all BASS add-ons (bass*.dll) contained in the specified directory.
            </summary>
            <param name="dir">The directory in which to search for BASS add-ons (bass*.dll).</param>
            <returns>A hash table containing all successfully loaded BASS add-ons.
            <para>The hash table will be constructed as: Key=pluginHandle and Value=filename.</para>
            <para>Note: Only stream/music add-ons are loaded (e.g. bass_fx.dll or bassenc.dll are NOT loaded).</para>
            </returns>
            <remarks>Internally the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> method will be used to load all add-ons contained in the specified directory folder (sub-folders are not scanned as well).</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory("C:\\BASS");
            if (loadedPlugIns != null)
            {
              foreach (string file in loadedPlugIns.Values)
                Console.Writeln( file );
            }
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory("C:\BASS")
            If Not (loadedPlugIns Is Nothing) Then
              Dim file As String
              For Each file In loadedPlugIns.Values
                Console.Writeln(file)
              Next file
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Tries to loads all BASS add-ons (bass*.dll) contained in the specified directory.
            </summary>
            <param name="dir">The directory in which to search for BASS add-ons (bass*.dll).</param>
            <param name="exclude">An optional list of file names (without path and extension) to exclude (e.g. "basswma").</param>
            <returns>A hash table containing all successfully loaded BASS add-ons.
            <para>The hash table will be constructed as: Key=pluginHandle and Value=filename.</para>
            <para>Note: Only stream/music add-ons are loaded (e.g. bass_fx.dll or bassenc.dll are NOT loaded).</para>
            </returns>
            <remarks>Internally the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/> method will be used to load all add-ons contained in the specified directory folder (sub-folders are not scanned as well).</remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory("C:\\BASS");
            if (loadedPlugIns != null)
            {
              foreach (string file in loadedPlugIns.Values)
                Console.Writeln( file );
            }
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory("C:\BASS")
            If Not (loadedPlugIns Is Nothing) Then
              Dim file As String
              For Each file In loadedPlugIns.Values
                Console.Writeln(file)
              Next file
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginGetInfoPtr(System.Int32)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)">
            <summary>
            Retrieves information on a plugin.
            </summary>
            <param name="handle">The plugin handle - or 0 to retrieve native BASS information.</param>
            <returns>If successful, an instance of <see cref="T:Un4seen.Bass.BASS_PLUGININFO"/> is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The plugin information does not change, so the returned info remains valid for as long as the plugin is loaded.
            <para>Note: There is no guarantee that the check is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>List the formats supported by a plugin:
            <code>
            int pluginFlac = Bass.BASS_PluginLoad("bassflac.dll");
            BASS_PLUGININFO info = Bass.BASS_PluginGetInfo(pluginFlac);
            foreach (BASS_PLUGINFORM f in info.formats)
              Console.WriteLine("Type={0}, Name={1}, Exts={2}", f.ctype, f.name, f.exts);
            </code>
            <code lang="vbnet">
            Dim pluginFlac As Integer = Bass.BASS_PluginLoad("bassflac.dll")
            Dim info As BASS_PLUGININFO = Bass.BASS_PluginGetInfo(pluginFlac)
            Dim f As BASS_PLUGINFORM
            For Each f In info.formats
              Console.WriteLine("Type={0}, Name={1}, Exts={2}", f.ctype, f.name, f.exts)
            Next f
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Apply3D">
            <summary>
            Applies changes made to the 3D system.
            </summary>
            <remarks>
            <para>This must be called to apply any changes made with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DFactors(System.Single,System.Single,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>. 
            It improves performance to have DirectSound do all the required recalculating at the same time like this, rather than recalculating after every little change is made.</para>
            <para>This function applies 3D changes on all the initialized devices - there's no need to re-call it for each individual device when using multiple devices.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Set3DFactors(System.Single,System.Single,System.Single)">
            <summary>
            Sets the factors that affect the calculations of 3D sound.
            </summary>
            <param name="distf">The distance factor... less than 0.0 = leave current... examples: 1.0 = use meters, 0.9144 = use yards, 0.3048 = use feet. By default BASS measures distances in meters, you can change this setting if you are using a different unit of measurement.</param>
            <param name="rollf">The rolloff factor, how fast the sound quietens with distance... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no rolloff, 1.0 = real world, 2.0 = 2x real.</param>
            <param name="doppf">The doppler factor... 0.0 (min) - 10.0 (max), less than 0.0 = leave current... examples: 0.0 = no doppler, 1.0 = real world, 2.0 = 2x real. The doppler effect is the way a sound appears to change pitch when it is moving towards or away from you (say hello to Einstein!). The listener and sound velocity settings are used to calculate this effect, this doppf value can be used to lessen or exaggerate the effect.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As with all 3D functions, use <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            To use yards as the distance measurement unit, while leaving the current rolloff and doppler factors untouched:
            <code>
            Bass.BASS_Set3DFactors(0.9144f, -1f, -1f);
            Bass.BASS_Apply3D(); // apply the change
            </code>
            <code lang="vbnet">
            Bass.BASS_Set3DFactors(0.9144F, -1F, -1F)
            Bass.BASS_Apply3D() ' apply the change
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Get3DFactors(System.Single@,System.Single@,System.Single@)">
            <summary>
            Retrieves the factors that affect the calculations of 3D sound.
            <para>This overload allows you to only get all three values at a time.</para>
            </summary>
            <param name="distf">The distance factor.</param>
            <param name="rollf">The rolloff factor.</param>
            <param name="doppf">The doppler factor.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            float distf = 0f;
            float rollf = 0f;
            float doppf = 0f;
            Bass.BASS_Get3DFactors(ref distf, ref rollf, ref doppf);
            </code>
            <code lang="vbnet">
            Dim distf As Single = 0F
            Dim rollf As Single = 0F
            Dim doppf As Single = 0F
            Bass.BASS_Get3DFactors(distf, rollf, doppf)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Get3DFactors(System.Object,System.Object,System.Object)">
            <summary>
            Retrieves the factors that affect the calculations of 3D sound.
            <para>This overload uses objects (so you can pass <see langword="null"/> in order to NOT retrieve a value). However a requested return value needs to be casted back into a float after getting it.</para>
            </summary>
            <param name="distf">The distance factor... <see langword="null"/> = don't retrieve it.</param>
            <param name="rollf">The rolloff factor... <see langword="null"/> = don't retrieve it.</param>
            <param name="doppf">The doppler factor... <see langword="null"/> = don't retrieve it.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Only get the distance factor:
            <code>
            object distf = 0f;
            Bass.BASS_Get3DFactors(distf, null, null);
            float distanceFactor = (float)distf;
            </code>
            <code lang="vbnet">
            Dim distf As Object = 0F
            Bass.BASS_Get3DFactors(distf, Nothing, Nothing)
            Dim distanceFactor As Single = CSng(distf)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Retrieves the position, velocity, and orientation of the listener.
            </summary>
            <param name="pos">The position of the listener... <see langword="null"/> = don't retrieve it.</param>
            <param name="vel">The listener's velocity... <see langword="null"/> = don't retrieve it.</param>
            <param name="front">The direction that the listener's front is pointing... <see langword="null"/>=don't retrieve it.</param>
            <param name="top">The direction that the listener's top is pointing... <see langword="null"/> = don't retrieve it.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The <paramref name="front"/> and <paramref name="top"/> parameters must both be retrieved in a single call, they can not be retrieved individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the current listener position only:
            <code>
            BASS_3DVECTOR pos = new BASS_3DVECTOR();
            Bass.BASS_Set3DPosition(pos, null, null, null);
            </code>
            <code lang="vbnet">
            Dim pos As New BASS_3DVECTOR()
            Bass.BASS_Set3DPosition(pos, Nothing, Nothing, Nothing)
            </code>
            Updates the position, velocity and top of the listener:
            <code>
            BASS_3DVECTOR position = new BASS_3DVECTOR(camera.RealPosition.x, camera.RealPosition.y, camera.RealPosition.z);
            BASS_3DVECTOR direction = new BASS_3DVECTOR(camera.RealDirection.x, camera.RealDirection.y, camera.RealDirection.z);
            BASS_3DVECTOR up = new BASS_3DVECTOR(-camera.RealUp.x, -camera.RealUp.y, -camera.RealUp.z);
            
            if (!Bass.BASS_Set3DPosition(position, velocity, direction, up))
                throw new AudioException("Could not set the 3d position of the listener", "listener", Bass.BASS_ErrorGetCode());
                
            Bass.BASS_Apply3D();
            </code>
            <code lang="vbnet">
            Dim position As New BASS_3DVECTOR(camera.RealPosition.x, camera.RealPosition.y, camera.RealPosition.z)
            Dim direction As New BASS_3DVECTOR(camera.RealDirection.x, camera.RealDirection.y, camera.RealDirection.z)
            Dim up As New BASS_3DVECTOR(-camera.RealUp.x, -camera.RealUp.y, -camera.RealUp.z)
            
            If Not Bass.BASS_Set3DPosition(position, velocity, direction, up) Then
                Throw New AudioException("Could not set the 3d position of the listener", "listener", Bass.BASS_ErrorGetCode())
            End If
            
            Bass.BASS_Apply3D()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_Get3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Retrieves the position, velocity, and orientation of the listener.
            </summary>
            <param name="pos">The position of the listener... <see langword="null"/> = don't retrieve it.</param>
            <param name="vel">The listener's velocity... <see langword="null"/> = don't retrieve it.</param>
            <param name="front">The direction that the listener's front is pointing... <see langword="null"/>=don't retrieve it.</param>
            <param name="top">The direction that the listener's top is pointing... <see langword="null"/> = don't retrieve it.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The <paramref name="front"/> and <paramref name="top"/> parameters must both be retrieved in a single call, they can not be retrieved individually.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The device was not initialized with 3D support.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the current listener position only:
            <code>
            BASS_3DVECTOR pos = new BASS_3DVECTOR();
            Bass.BASS_Get3DPosition(pos, null, null, null);
            </code>
            <code lang="vbnet">
            Dim pos As New BASS_3DVECTOR()
            Bass.BASS_Get3DPosition(pos, Nothing, Nothing, Nothing)
            </code>
            Updates the position, velocity and top of the listener:
            <code>
            BASS_3DVECTOR position = new BASS_3DVECTOR(camera.RealPosition.x, camera.RealPosition.y, camera.RealPosition.z);
            BASS_3DVECTOR direction = new BASS_3DVECTOR(camera.RealDirection.x, camera.RealDirection.y, camera.RealDirection.z);
            BASS_3DVECTOR up = new BASS_3DVECTOR(-camera.RealUp.x, -camera.RealUp.y, -camera.RealUp.z);
            
            if (!Bass.BASS_Set3DPosition(position, velocity, direction, up))
                throw new AudioException("Could not set the 3d position of the listener", "listener", Bass.BASS_ErrorGetCode());
                
            Bass.BASS_Apply3D();
            </code>
            <code lang="vbnet">
            Dim position As New BASS_3DVECTOR(camera.RealPosition.x, camera.RealPosition.y, camera.RealPosition.z)
            Dim direction As New BASS_3DVECTOR(camera.RealDirection.x, camera.RealDirection.y, camera.RealDirection.z)
            Dim up As New BASS_3DVECTOR(-camera.RealUp.x, -camera.RealUp.y, -camera.RealUp.z)
            
            If Not Bass.BASS_Set3DPosition(position, velocity, direction, up) Then
                Throw New AudioException("Could not set the 3d position of the listener", "listener", Bass.BASS_ErrorGetCode())
            End If
            
            Bass.BASS_Apply3D()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoadUnicode(System.Boolean,System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="max"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses Unicode file names! A BASS_UNICODE flag will automatically be added.</para>
            </summary>
            <param name="file">The file name to load the sample from.</param>
            <param name="offset">File offset to load the sample from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved by streaming the file.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Convert the sample (MP3/MP2/MP1 only) to mono, if it's not already. This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D samples must be mono.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (no need to set this for this overload).</description></item>
            </list>
            </param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>).</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> and/or <paramref name="length"/> is invalid. The <paramref name="length"/> must be specified when loading from memory.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="file"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="file"/>'s format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The BASS_SAMPLE_VAM flag requires DirectX 7 (or above). Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.</para>
            </remarks>
            <example>
            Play a sample with it's default settings:
            <code>
            int sample = Bass.BASS_SampleLoad("test.wav", 0L, 0, 1, BASSFlag.BASS_DEFAULT);
            int channel = Bass.BASS_SampleGetChannel(sample, false); // get a sample channel
            Bass.BASS_ChannelPlay(channel, false); // play it
            </code>
            <code lang="vbnet">
            Dim sample As Integer = Bass.BASS_SampleLoad("test.wav", 0L.ToUInt32(), 0, 1, BASSFlag.BASS_DEFAULT)
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False) ' get a sample channel
            Bass.BASS_ChannelPlay(channel, False) ' play it
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoadMemory(System.Boolean,System.IntPtr,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="max"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.IntPtr,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="memory">An unmanaged IntPtr to the allocated memory block at which the sample data resides.</param>
            <param name="offset">File offset to load the sample from (NOT used here!).</param>
            <param name="length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved by streaming the file.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Convert the sample (MP3/MP2/MP1 only) to mono, if it's not already. This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D samples must be mono.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>).</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>There is no need to pin the memory buffer for this method, since after loading a sample from memory, the memory can safely be discarded, as a copy is made.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> and/or <paramref name="length"/> is invalid. The <paramref name="length"/> must be specified when loading from memory.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="memory"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="memory"/>'s format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The BASS_SAMPLE_VAM flag requires DirectX 7 (or above). Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.</para>
            </remarks>
            <example>
            See <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>for examples on how to load data from memory.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoadMemory(System.Boolean,System.Byte[],System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            
            </summary>
            <param name="mem"></param>
            <param name="memory"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="max"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.Byte[],System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Loads a WAV, AIFF, MP3, MP2, MP1, OGG or plugin supported sample.
            <para>This overload uses an unmanaged IntPtr and implements loading a sample from memory.</para>
            </summary>
            <param name="memory">A managed byte[] containing the sample data to load.</param>
            <param name="offset">File offset to load the sample from (NOT used here!).</param>
            <param name="length">Data length. Should be set to the length of the data contained in memory.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved by streaming the file.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Convert the sample (MP3/MP2/MP1 only) to mono, if it's not already. This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D samples must be mono.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </param>
            <returns>If successful, the loaded sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Additional format support is available via the plugin system (see <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoad(System.String)"/>).</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>.</para>
            <para>There is no need to pin the memory buffer for this method, since BASS creates a copy of the data internally, 
            so the buffer provided will not be used anymore when the method returns.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> and/or <paramref name="length"/> is invalid. The <paramref name="length"/> must be specified when loading from memory.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="memory"/> could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The <paramref name="memory"/>'s format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The BASS_SAMPLE_VAM flag requires DirectX 7 (or above). Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed.</para>
            </remarks>
            <example>
            See <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for examples on how to load data from memory.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Initiates the creation of a user generated sample.
            </summary>
            <param name="length">The sample's length, in bytes.</param>
            <param name="freq">The default sample rate.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, etc... More than stereo requires WDM drivers in Windows.</param>
            <param name="max">Maximum number of simultaneous playbacks... 1 (min) - 65535 (max)... use one of the BASS_SAMPLE_OVER flags to choose the override decider, in the case of there being no free channel available for playback (ie. the sample is already playing max times).</param>
            <param name="flags">A combination of these flags (<see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data (not really recommended for samples). WDM drivers are required to use this flag in Windows. See Floating-point channels for more info.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped? Note that only complete sample loops are allowed, you can't loop just a part of the sample. More fancy looping can be achieved via streaming.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the sample to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>requires DirectX 7 or above: Enables the DX7 voice allocation and management features on the sample, which allows the sample to be played in software or hardware. This flag is ignored if the BASS_SAMPLE_SOFTWARE flag is also specified.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D samples must be mono (use BASS_SAMPLE_MONO).</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>Mute the sample when it is at (or beyond) it's max distance (software 3D samples only).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </param>
            <returns>If successful, the new sample's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The sample's initial content is undefined. <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.IntPtr)"/> should be used to set the sample's data.</para>
            <para>Unless the BASS_SAMPLE_SOFTWARE flag is used, the sample will use hardware mixing if hardware resources are available. 
            Use <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to see if there are hardware mixing resources available, and which sample formats are supported by the hardware. 
            The BASS_SAMPLE_VAM flag allows a sample to be played by both hardware and software, with the decision made when the sample is played rather than when it's loaded. 
            A sample's VAM options are set via <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.</para>
            <para>To play a sample, first a channel must be obtained using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>, which can then be played using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>.</para>
            <para>If you want to play a large or one-off sample, then it would probably be better to stream it instead with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Sample functions are not available when using the "no sound" device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="max"/> is invalid..</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the sample is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The BASS_SAMPLE_VAM flag requires DirectX 7 (or above). Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary.</para>
            </remarks>
            <example>
            Create a 440Hz sine-wave, 16-bit, mono:
            <code>
            // create the sample
            int sample = Bass.BASS_SampleCreate(256, 28160, 1, 1, 
                              BASSFlag.BASS_SAMPLE_LOOP | BASSFlag.BASS_SAMPLE_OVER_POS );
            // the data buffer (256 byte = 128 Int16)
            short[] data = new short[128];
            // create the sine wave
            for (int a=0; a&lt;128; a++)
              data[a] = (short)(32767.0 * Math.Sin((double)a * 6.283185 / 64d));
            // set the sample's data 
            Bass.BASS_SampleSetData(sample, data);
            // get a sample channel
            int channel = Bass.BASS_SampleGetChannel(sample, false);
            // play it
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            ' create the sample
            Dim sample As Integer = Bass.BASS_SampleCreate(256, 28160, 1, 1, BASSFlag.BASS_SAMPLE_LOOP Or BASSFlag.BASS_SAMPLE_OVER_POS)
            ' the data buffer (256 byte = 128 Int16)
            Dim data(128 - 1) As Short
            ' create the sine wave
            Dim a As Integer
            For a = 0 To 127
              data(a) = CShort(32767.0 * Math.Sin((CDbl(a) * 6.283185 / 64.0)))
            Next a 
            ' set the sample's data 
            Bass.BASS_SampleSetData(sample, data)
            ' get a sample channel
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False)
            ' play it
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.IntPtr)">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">Pointer to the data to set.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Single[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of float values representing the sample data to set.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Int32[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of Int32 values representing the sample data to set (Caution: Int32=2xInt16, so this overload can e.g. be used to provide a stereo sample containing of two 16-bit values).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Int16[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of Int16 values representing the sample data to set.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetData(System.Int32,System.Byte[])">
            <summary>
            Sets a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array of byte values representing the sample data to set.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The required length and format of the data can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>A sample's data can be set at any time, including during playback.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>See <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.IntPtr)">
            <summary>
            Retrieves a copy of a sample's data.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">Pointer to a buffer to receive the data.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Single[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed float[] to reference the buffer data as 32-bit!
            SHOULD ONLY BE USED, if the sample was created with BASS_SAMPLE_FLOAT!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array (float[]) to receive the data, use BASS_SAMPLE_FLOAT when creating the sample!</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            float[] buffer = new float[info.length/4];
            Bass.BASS_SampleGetData(sample, buffer);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            Dim buffer(info.length/4 - 1) As Single
            Bass.BASS_SampleGetData(sample, buffer)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Int32[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed int[] to reference the buffer data (Note: if we expect to receive 16-bit data, a single Int32 value will contain 2 x 16-bit, left and right channel)!
            SHOULD ONLY BE USED, if the sample was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array (int[]) to receive the data, e.g. when creating the sample with default setting, meaning 16-bit samples, an Int32 value contains 2 channels (left and right)!</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Int16[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed short[] to reference the buffer data as 16-bit!
            SHOULD ONLY BE USED, if the sample was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array (short[]) to receive the data, do not use BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS when creating the sample!</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            short[] buffer = new short[info.length/2];
            Bass.BASS_SampleGetData(sample, buffer);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            Dim buffer(info.length/2 - 1) As Short
            Bass.BASS_SampleGetData(sample, buffer)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetData(System.Int32,System.Byte[])">
            <summary>
            Retrieves a copy of a sample's data.
            <para>This overload uses a managed byte[] to reference the buffer data as 8-bit!
            SHOULD ONLY BE USED, if the sample was created with or BASS_SAMPLE_8BITS!</para>
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="buffer">The array array (byte[]) to receive the data, use or BASS_SAMPLE_8BITS when creating the sample!</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The buffer must be big enough to receive the sample's data, the size of which can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            byte[] buffer = new byte[info.length];
            Bass.BASS_SampleGetData(sample, buffer);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            Dim buffer(info.length - 1) As Byte
            Bass.BASS_SampleGetData(sample, buffer)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleFree(System.Int32)">
            <summary>
            Frees a sample's resources.
            </summary>
            <param name="handle">The sample handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play a sample with it's default settings:
            <code>
            int sample = Bass.BASS_SampleLoad("test.wav", 0L, 0, 1, BASSFlag.BASS_DEFAULT);
            int channel = Bass.BASS_SampleGetChannel(sample, false); // get a sample channel
            Bass.BASS_ChannelPlay(channel, false); // play it
            ...
            // when done
            Bass.BASS_SampleFree(sample);
            </code>
            <code lang="vbnet">
            Dim sample As Integer = Bass.BASS_SampleLoad("test.wav", 0L.ToUInt32(), 0, 1, BASSFlag.BASS_DEFAULT)
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False) ' get a sample channel
            Bass.BASS_ChannelPlay(channel, False) ' play it
            ...
            ' when done
            Bass.BASS_SampleFree(sample)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> class to store the sample information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = new BASS_SAMPLE();
            bool ok = Bass.BASS_SampleGetInfo(sample, info);
            </code>
            <code lang="vbnet">
            Dim info As New BASS_SAMPLE()
            Dim ok As Boolean = Bass.BASS_SampleGetInfo(sample, info)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32)">
            <summary>
            Retrieves a sample's default attributes and other information.
            </summary>
            <param name="handle">The sample handle.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> class on success - else <see langword="null"/>.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(sample);
            </code>
            <code lang="vbnet">
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(sample)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)">
            <summary>
            Sets a sample's default attributes.
            </summary>
            <param name="handle">The sample handle.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> class containing the sample information to set.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use this function and <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> to edit a sample's default attributes. 
            Changing a sample's default attributes does not affect any existing channels, it only affects channels subsequently created via <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>. 
            The exception is the VAM settings, changes to that apply to all the sample's channels at their next playback (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>). 
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> to change the attributes of an existing sample channel.</para>
            <para>The sample's maximum number of simultaneous playbacks can be changed via the max member of the BASS_SAMPLE structure. If the new maximum is lower than the existing number of channels, the channels will remain existing until they are stopped.</para>
            <para>The <i>length</i>, <i>origres</i> and <i>chans</i> members of the <see cref="T:Un4seen.Bass.BASS_SAMPLE"/> structure can't be modified - any changes are ignored. 
            The BASS_SAMPLE_8BITS, BASS_SAMPLE_MONO, BASS_SAMPLE_3D, BASS_SAMPLE_MUTEMAX, BASS_SAMPLE_SOFTWARE and BASS_SAMPLE_VAM flags also cannot be changed.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Use one of the BASS_SAMPLE constructors to set the values:
            <code>
            BASS_SAMPLE info = new BASS_SAMPLE(44100, 100, 0, ...);
            bool ok = Bass.BASS_SampleSetInfo(sample, info);
            </code>
            <code lang="vbnet">
            Dim info As New BASS_SAMPLE(44100, 100, 0, ...)
            Dim ok As Boolean = Bass.BASS_SampleSetInfo(sample, info)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)">
            <summary>
            Creates/initializes a playback channel for a sample.
            </summary>
            <param name="handle">Handle of the sample to play.</param>
            <param name="onlynew">Do not recycle/override one of the sample's existing channels?</param>
            <returns>If successful, the handle of the new channel is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> to set a sample's default attributes, which are used when creating a channel. 
            After creation, a channel's attributes can be changed via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>. 
            <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> should be called before starting playback of a 3D sample, even if you just want to use the default settings.</para>
            <para>If a sample has a maximum number of simultaneous playbacks of 1 (the max parameter was 1 when calling <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>), then the HCHANNEL handle returned will be identical to the HSAMPLE handle. 
            That means you can use the HSAMPLE handle with functions that usually require a HCHANNEL handle, but you must still call this function first to initialize the channel.</para>
            <para>A sample channel is automatically freed when it's overridden by a new channel, or when stopped manually via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleStop(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>. 
            If you wish to stop a channel and re-use it, it should be paused (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/>) instead of stopped. 
            Determining whether a channel still exists can be done by trying to use the handle in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.</para>
            <para>When channel overriding has been enabled via a BASS_SAMPLE_OVER flag and there are multiple candidates for overriding (eg. with identical volume), the oldest of them will be chosen to make way for the new channel.</para>
            <para>The new channel will have an initial state of being paused (BASS_ACTIVE_PAUSED). This prevents the channel being claimed by another call of this function before it has been played, unless it gets overridden due to a lack of free channels.</para>
            <para>All of a sample's channels share the same sample data, and just have their own individual playback state information (volume/position/etc).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            <item><term>BASS_ERROR_NOCHAN</term><description>The sample has no free channels... the maximum number of simultaneous playbacks has been reached, and no BASS_SAMPLE_OVER flag was specified for the sample or onlynew = <see langword="true"/>.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The sample's minimum time gap (<see cref="T:Un4seen.Bass.BASS_SAMPLE"/>) has not yet passed since the last channel was created.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Play a sample with it's default settings:
            <code>
            int sample = Bass.BASS_SampleLoad("test.wav", 0L, 0, 1, BASSFlag.BASS_DEFAULT);
            int channel = Bass.BASS_SampleGetChannel(sample, false); // get a sample channel
            Bass.BASS_ChannelPlay(channel, false); // play it
            </code>
            <code lang="vbnet">
            Dim sample As Integer = Bass.BASS_SampleLoad("test.wav", 0L.ToUInt32(), 0, 1, BASSFlag.BASS_DEFAULT)
            Dim channel As Integer = Bass.BASS_SampleGetChannel(sample, False) ' get a sample channel
            Bass.BASS_ChannelPlay(channel, False) ' play it
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannels(System.Int32,System.Int32[])">
            <summary>
            Retrieves all a sample's existing channels.
            </summary>
            <param name="handle">Handle of the sample.</param>
            <param name="channels">The array (int[])to put the sample's channel handles in. The array should be the same size as the sample's max setting when the sample was created, which can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/>. 
            <see langword="null"/> can be used to just check how many channels exist.</param>
            <returns>If successful, the number of existing channels is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>For ease of use you might also use the second overload, which directly returns an integer array to get the channels directly.
            <para>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the sample rate of all a sample's channels to 10000Hz:
            <code>
            // get sample info for "max" value
            BASS_SAMPLE info = Bass.BASS_SampleGetInfo(handle);
            // allocate channels array
            int[] chans = new int[info.max];
            // get the channels
            int count = Bass.BASS_SampleGetChannels(handle, chans);
            // go through them all and...
            for (int a=0; a&lt;count; a++)
            {
              // set the sample rate to 10000
              Bass.BASS_ChannelSetAttribute(chans[a], BASSAttribute.BASS_ATTRIB_FREQ, 10000f);
            }
            </code>
            <code lang="vbnet">
            ' get sample info for "max" value
            Dim info As BASS_SAMPLE = Bass.BASS_SampleGetInfo(handle)
            ' allocate channels array
            Dim chans(info.max) As Integer
            ' get the channels
            Dim count As Integer = Bass.BASS_SampleGetChannels(handle, hGC.AddrOfPinnedObject())
            ' go through them all and...
            Dim a As Integer
            For a = 0 To count - 1
              ' set the sample rate to 10000
              Bass.BASS_ChannelSetAttribute(chans(a), BASSAttribute.BASS_ATTRIB_FREQ, 10000F)
            Next a
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannels(System.Int32)">
            <summary>
            Retrieves all a sample's existing channels.
            </summary>
            <param name="handle">Handle of the sample.</param>
            <returns>If successful, the array of existing channels is returned (which might have zero elements), else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This overload only returns the existing channels in the array.
            <para>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the sample rate of all a sample's channels to 10000hz:
            <code>
            int[] chans = Bass.BASS_SampleGetChannels(handle);
            if (chans != null)
            {
              // go through them all and...
              for (int a=0; a&lt;chans.Length; a++)
              {
                // set the sample rate to 10000
                Bass.BASS_ChannelSetAttribute(chans[a], BASSAttribute.BASS_ATTRIB_FREQ, 10000f);
              }
            }
            </code>
            <code lang="vbnet">
            Dim chans As Integer() = Bass.BASS_SampleGetChannels(handle)
            If Not (chans Is Nothing) Then
              ' go through them all and...
              Dim a As Integer
              For a = 0 To chans.Length - 1
                ' set the sample rate to 10000
                Bass.BASS_ChannelSetAttribute(chans(a), BASSAttribute.BASS_ATTRIB_FREQ, 10000F)
              Next a
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleGetChannelCount(System.Int32)">
            <summary>
            Retrieves the number of existing sample's channels.
            </summary>
            <param name="handle">Handle of the sample.</param>
            <returns>If successful, the number of existing channels is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If you need to determine whether a particular sample channel still exists, it is simplest to just try it in a function call, eg. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_SampleStop(System.Int32)">
            <summary>
            Stops all instances of a sample.
            </summary>
            <param name="handle">The sample handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If a sample is playing simultaneously multiple times, calling this function will stop them all, which is obviously simpler than calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> multiple times.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid sample handle.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)">
            <summary>
            Creates a user sample stream.
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="proc">The user defined stream writing function (see <see cref="T:Un4seen.Bass.STREAMPROC"/>).
            <para>To create a DUMMY stream use the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateDummy(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> method.</para>
            <para>To create a PUSH stream use the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> method.</para>
            <para>To create a DEVICE stream use the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateDevice(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> method.</para>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Sample streams allow any sample data to be played through BASS, and are particularly useful for playing a large amount of sample data without requiring a large amount of memory.
            If you wish to play a sample format that BASS does not support, then you can create a stream and decode the sample data into it.</para>
            <para>BASS can automatically stream MP3, MP2, MP1, OGG, WAV and AIFF files, using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>, and also from HTTP and FTP servers, 
            using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> allows streaming from other sources too.</para>
            <para>However, the callback method must deliver PCM sample data as specified, so opening an MP3 file and just passing that file data will not work here.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            </remarks>
            <example>
            A callback function to stream a file, in 44100hz 16-bit stereo:
            <code>
            private STREAMPROC _myStreamCreate;  // make it global, so that the GC can not remove it
            private byte[] _data = null; // our local buffer
            ...
            _myStreamCreate = new STREAMPROC(MyFileProc);
            FileStream fs = File.OpenRead("test.raw");
            int channel = Bass.BASS_StreamCreate(44100, 2, 
                               BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false);
            ...
            private int MyFileProc(int handle, IntPtr buffer, int length, IntPtr user)
            {
              // implementing the callback for BASS_StreamCreate...
              // here we need to deliver PCM sample data
            
              // increase the data buffer as needed
              if (_data == null || _data.Length &lt; length)
                _data = new byte[length];
            
              int bytesread = _fs.Read( _data, 0, length ); 
              Marshal.Copy( _data, 0, buffer, bytesread );
              if ( bytesread &lt; length )
              {
                // set indicator flag
                bytesread |= (int)BASSStreamProc.BASS_STREAMPROC_END;
                _fs.Close();
              }
              return bytesread;
            }
            </code>
            <code lang="vbnet">
            Private _myStreamCreate As STREAMPROC  ' make it global, so that the GC can not remove it
            Private _data As Byte() = Nothing  ' our local buffer
            ...
            _myStreamCreate = New STREAMPROC(AddressOf MyFileProc)
            Dim fs As FileStream =  File.OpenRead("test.raw")
            Dim channel As Integer =  Bass.BASS_StreamCreate(44100, 2, 
                                           BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero) 
            Bass.BASS_ChannelPlay(channel, False)
            ...
            Private Function MyFileProc(ByVal handle As Integer, ByVal buffer As IntPtr, 
                                        ByVal length As Integer, ByVal user As IntPtr) As Integer
              ' implementing the callback for BASS_StreamCreate...
              ' here we need to deliver PCM sample data
            
              ' increase the data buffer as needed
              If _data = Nothing OrElse _data.Length &lt; length Then
                _data = New Byte(length) {}
              End If
            
              Dim bytesread As Integer = _fs.Read(_data, 0, length) 
              Marshal.Copy(_data, 0, buffer, bytesread)
              If bytesread &lt; length Then
                bytesread = bytesread Or CInt(BASSStreamProc.BASS_STREAMPROC_END) ' set indicator flag
                _fs.Close()
              EndIf
              Return bytesread
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreatePtr(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="freq"></param>
            <param name="chans"></param>
            <param name="flags"></param>
            <param name="procPtr"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSStreamProc)">
            <summary>
            Creates a "dummy" stream.
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="proc">One of the following (see <see cref="T:Un4seen.Bass.BASSStreamProc"/>):
            <list type="table">
            <item><term>STREAMPROC_DUMMY</term><description>Create a "dummy" stream. A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag) can be used to apply DSP/FX processing to any sample data, by setting DSP/FX on the stream and feeding the data through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. The dummy stream should have the same sample format as the data being fed through it.</description></item>
            <item><term>STREAMPROC_PUSH</term><description>Create a "push" stream. Instead of BASS pulling data from a STREAMPROC function, data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)"/>.</description></item>
            <item><term>STREAMPROC_DEVICE</term><description>Create a "dummy" stream for the device's final output mix. This allows DSP/FX to be applied to all channels that are playing on the device, rather than individual channels. DSP/FX parameter change latency is also reduced because channel playback buffering is avoided. The stream is created with the device's current output sample format; the freq, chans, and flags parameters are ignored. It will always be floating-point except on platforms/architectures that do not support floating-point (see BASS_CONFIG_FLOAT), where it will be 16-bit instead.</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with BASS_STREAM_DECODE flag) can be used to apply DSP/FX processing to any sample data, 
            by setting DSP/FX on the stream and feeding the data through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. 
            <para>The dummy stream should have the same sample format as the data being fed through it.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateDummy(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)">
            <summary>
            Creates a "dummy" stream (using the STREAMPROC_DUMMY option).
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with BASS_STREAM_DECODE flag) can be used to apply DSP/FX processing to any sample data, 
            by setting DSP/FX on the stream and feeding the data through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. 
            <para>The dummy stream should have the same sample format as the data being fed through it.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)">
            <summary>
            Creates a "push" stream (using the STREAMPROC_PUSH option).
            </summary>
            <param name="freq">The default sample rate. The sample rate can be changed using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, 4 = quadraphonic, 6 = 5.1, 8 = 7.1. More than stereo requires WDM drivers, and the SPEAKER flags are ignored.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Instead of BASS pulling data from a <see cref="T:Un4seen.Bass.STREAMPROC"/> function, data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateDevice(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)">
            <summary>
            Create a "dummy" stream for the device's final output mix (using the STREAMPROC_DEVICE option).
            </summary>
            <param name="freq">Ignored.</param>
            <param name="chans">Ignored.</param>
            <param name="flags">Ignored.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the device's final output mix stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This allows DSP/FX to be applied to all channels that are playing on the device, rather than individual channels. 
            DSP/FX parameter change latency is also reduced because channel playback buffering is avoided. 
            The stream is created with the device's current output sample format; the freq, chans, and flags parameters are ignored. 
            It will always be floating-point except on platforms/architectures that do not support floating-point (see BASS_CONFIG_FLOAT), where it will be 16-bit instead. 
            <para>Each device has a single final output mix stream, which can be used to apply DSP/FX to the device output. 
            Multiple requests for a final output mix stream (using STREAMPROC_DEVICE) on the same device will receive the same stream handle, which cannot be freed via <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>. 
            It will automatically be freed if the device's output format (sample rate or channel count) changes. A BASS_SYNC_FREE sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be notified when this happens, at which point a new stream with the device's new format could be created.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The STREAMPROC_DEVICE option is not available when using DirectSound output on Windows because BASS does not produce the final output mix then.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateDevice3D(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)">
            <summary>
            Create a "dummy" stream for the device's final output mix (using the STREAMPROC_DEVICE_3D option).
            </summary>
            <param name="freq">Ignored.</param>
            <param name="chans">Ignored.</param>
            <param name="flags">Ignored.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the device's final output mix stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This allows DSP/FX to be applied to all channels that are playing on the device, rather than individual channels. 
            DSP/FX parameter change latency is also reduced because channel playback buffering is avoided. 
            The stream is created with the device's current output sample format; the freq, chans, and flags parameters are ignored. 
            It will always be floating-point except on platforms/architectures that do not support floating-point (see BASS_CONFIG_FLOAT), where it will be 16-bit instead. 
            <para>Each device has a single final output mix stream, which can be used to apply DSP/FX to the device output. 
            Multiple requests for a final output mix stream (using STREAMPROC_DEVICE) on the same device will receive the same stream handle, which cannot be freed via <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>. 
            It will automatically be freed if the device's output format (sample rate or channel count) changes. A BASS_SYNC_FREE sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be notified when this happens, at which point a new stream with the device's new format could be created.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The STREAMPROC_DEVICE_3D option is not available when using DirectSound output on Windows because BASS does not produce the final output mix then.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file via user callback functions.
            </summary>
            <param name="system">File system to use (one of the <see cref="T:Un4seen.Bass.BASSStreamSystem"/>):
            <list type="table">
            <item><term>STREAMFILE_NOBUFFER</term><description>Unbuffered.</description></item>
            <item><term>STREAMFILE_BUFFER</term><description>Buffered.</description></item>
            <item><term>STREAMFILE_BUFFERPUSH</term><description>Buffered, with the data pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>.</description></item>
            </list>
            </param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_PRESCAN</term><description>Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream. This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points. This flag is ignored with "buffered" streams (buffered=<see langword="true"/>).</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>Restrict the download rate of the file to the rate required to sustain playback. If this flag is not used, then the file will be downloaded as quickly as possible. This flag has no effect on "unbuffered" streams (buffered=<see langword="false"/>).</description></item>
            <item><term>BASS_STREAM_BLOCK</term><description>Download and play the file in smaller chunks. Uses a lot less memory than otherwise, but it's not possible to seek or loop the stream - once it's ended, the file must be opened again to play it again. This flag will automatically be applied when the file length is unknown. This flag also has the effect of resticting the download rate. This flag has no effect on "unbuffered" streams (buffered=<see langword="false"/>).</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_ASYNCFILE</term><description>Read the file asynchronously. When enabled, the file is read and buffered in parallel with the decoding, to reduce the chances of the decoder being affected by I/O delays. This can be particularly useful with slow storage media and/or low latency output. The size of the file buffer is determined by the BASS_CONFIG_ASYNCFILE_BUFFER config option. This flag only applies when using the STREAMFILE_NOBUFFER system.</description></item>
            </list>
            </param>
            <param name="procs">The user defined file function (see <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).</param>
            <param name="user">User instance data to pass to the callback functions.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The buffered file system (STREAMFILE_BUFFER) is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. As the name suggests, data from the file is buffered so that it is readily available for decoding; BASS creates a thread dedicated to 'downloading' the data. This is ideal for when the data is coming from a source that has high latency, like the internet. It is not possible to seek in buffered file streams, until the download has reached the requested position; it is not possible to seek at all if it is being streamed in blocks. When streaming in blocks, it may be possible to reset the stream via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> with the BASS_POS_RESET flag, so that it is ready to process new data.</para>
            <para>The push buffered file system (STREAMFILE_BUFFERPUSH) is the same, except that instead of the file data being pulled from the <see cref="T:Un4seen.Bass.FILEREADPROC"/> function in a "download" thread, the data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>. A <see cref="T:Un4seen.Bass.FILEREADPROC"/> function is still required, to get the initial data used in the creation of the stream (see example below).</para>
            <para>The unbuffered file system (STREAMFILE_NOBUFFER) is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. In this system, BASS does not do any intermediate buffering - it simply requests data from the file as and when it needs it. This means that reading (<see cref="T:Un4seen.Bass.FILEREADPROC"/>) must be quick, otherwise the decoding will be delayed and playback buffer underruns (old data repeated) are a possibility. It's not so important for seeking (<see cref="T:Un4seen.Bass.FILESEEKPROC"/>) to be fast, as that is generally not required during decoding, except when looping a file.</para>
            <para>In all cases, BASS will automatically stall playback of the stream when insufficient data is available, and resume it when enough data does become available.</para>
            <para>A copy is made of the procs callback function table, so it does not have to persist beyond this function call. 
            This means it is not required to pin the <paramref name="procs"/> instance, but it is still required to keep a reference as long as BASS uses the callback delegates in order to prevent the callbacks from being garbage collected.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="system"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA. On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed. Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.</para>
            </remarks>
            <example>STREAMFILE_BUFFERPUSH:
            The first thing to note is that <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/> needs a stream handle. You don't have that until the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> call returns, 
            so some other way is needed for BASS to get the inital file data that it uses to detect the format/etc. That other way is the <see cref="T:Un4seen.Bass.BASS_FILEPROCS">FILEREADPROC</see>. 
            After the stream has been created, the <see cref="T:Un4seen.Bass.BASS_FILEPROCS">FILEREADPROC</see> is never called again, and the remaining file data is fed to the stream via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>.
            E.g. a function receiving the data from the Internet would need to buffer the received data until the stream has been created, at which point it can start using <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/> instead.
            The <see cref="T:Un4seen.Bass.BASS_FILEPROCS">FILEREADPROC</see> would read data from that buffer, and wait for the data to arrive if necessary. After the stream has been created, any buffered data that's remaining should be fed to the stream, before starting to feed newly arriving data. 
            You'll need some synchronization (eg. a mutex) to enforce that order of things. Something like this (pseudo-code):
            <code lang="null">
            void Connect()
            {
                bufferobj = new Buffer();
                stream = BASS_StreamCreateFileUser(STREAMFILE_BUFFERPUSH, ...);
                lock 
                {
                    BASS_StreamPutFileData(stream, ...); // feed remaining buffered data
                    bufferobj = NULL; // don't need the buffer anymore
                }
            }
            
            void OnReceiveData(pointer buffer, int length)
            {
                lock
                {
                    if (bufferobj)
                        bufferobj.Write(buffer, length);
                    else
                        BASS_StreamPutFileData(stream, buffer, length);
                }
            }
            
            int FileReadProc(pointer buffer, int length, pointer user)
            {
            	int todo = length;
            	while (TRUE) 
            	{
            		lock
            		{
            		    done = bufferobj.Read(buffer, todo);
            		}
            		buffer += done; // move pointer
            		todo -= done;
            		if (todo == 0)
            		    break;
            		if (!bufferobj.WaitForData(timeout)) // wait for more data
            		    break; // timed-out (or perhaps EOF)
            	}
            	return length - todo;
            }
            </code>
            </example>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUnicode(System.Boolean,System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Only used internal! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> for details!
            </summary>
            <param name="mem">Needs to be set to <see langword="true"/></param>
            <param name="file">The file name to open</param>
            <param name="offset">Set to 0 to start the stream from the beginning</param>
            <param name="length">Data length... 0 = use all data</param>
            <param name="flags">See <see cref="T:Un4seen.Bass.BASSFlag"/> for possible flags</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically, since all .Net strings are always unicode.</para>
            </summary>
            <param name="file">Filename for which a stream should be created.</param>
            <param name="offset">File offset to begin streaming from.</param>
            <param name="length">Data length... 0 = use all data up to the end of the file.</param>
            <param name="flags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>:
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_PRESCAN</term><description>Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream. This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            <item><term>BASS_ASYNCFILE</term><description>Read the file asynchronously. When enabled, the file is read and buffered in parallel with the decoding, to reduce the chances of the decoder being affected by I/O delays. This can be particularly useful with slow storage media and/or low latency output. The size of the file buffer is determined by the BASS_CONFIG_ASYNCFILE_BUFFER config option.</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (automatically set with this overload).</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS has built-in support for MPEG, OGG, WAV and AIFF files. Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported. Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded. So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM).
            All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the BASS_SAMPLE_FLOAT flag is used. 64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags.
            The file's original resolution is available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the BASS_STREAM_PRESCAN flag is used (or the BASS_CONFIG_OGG_PRESCAN config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start. The BASS_POS_OGG "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> to get the number of bitstreams and with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to seek to a particular one.
            A BASS_SYNC_OGG_CHANGE sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed of when a new bitstream begins during decoding/playback.</para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>.</para>
            <para>If length = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> will not be updated until the end is reached. The <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> return values will be updated during playback of the extra data though.</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA. On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed. Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.</para>
            </remarks>
            <example>
            The following example demonstrates how to stream from a file (floating-point):
            <code>
            // Init Bass
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            // create the stream
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_STREAM_PRESCAN);
            if (stream != 0 &amp;&amp; Bass.BASS_ChannelPlay(stream, false) )
            {
              // playing
            }
            else
            {
              Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode());
            }
            </code>
            <code lang="vbnet">
            ' Init Bass
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            ' create the stream
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_STREAM_PRESCAN)
            If stream &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(stream, False) Then
              ' playing
            Else
              Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFileMemory(System.Boolean,System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Only used internal! See the memory overload of <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> for details!
            </summary>
            <param name="mem">Needs to be set to <see langword="true"/></param>
            <param name="memory">The IntPtr to the unmananged buffer containing the stream data</param>
            <param name="offset">Set to 0 to start the stream from the beginning</param>
            <param name="length">Needs to be set to the total length of the buffer data</param>
            <param name="flags">See <see cref="T:Un4seen.Bass.BASSFlag"/> for possible flags</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.IntPtr,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported memory IntPtr.
            <para>This overload implements streaming from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">Offset to begin streaming from (unused for memory streams, set to 0).</param>
            <param name="length">Data length (needs to be set to the length of the memory stream in bytes which should be played).</param>
            <param name="flags">Any combination of these flags <see cref="T:Un4seen.Bass.BASSFlag"/>, needs to casted into an (int) because we needed another method signature here.
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_PRESCAN</term><description>Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream. This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS has built-in support for MPEG, OGG, WAV and AIFF files. Support for additional formats is available via add-ons, which can be downloaded from the BASS website: <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            <para>MPEG 1.0, 2.0 and 2.5 layer 3 (MP3) files are supported, layers 1 (MP1) and 2 (MP2) are also supported. Standard RIFF and RF64 WAV files are supported, with the sample data in a PCM format or compressed with an ACM codec, but the codec is required to be installed on the user's system for the WAV to be decoded. So you should either distribute the codec with your software, or use a codec that comes with Windows (eg. Microsoft ADPCM). All PCM formats from 8 to 32-bit are supported in WAV and AIFF files, but the output will be restricted to 16-bit unless the BASS_SAMPLE_FLOAT flag is used. 64-bit floating-point WAV and AIFF files are also supported, but are rendered in 16-bit or 32-bit floating-point depending on the flags. The file's original resolution is available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>Chained OGG files containing multiple logical bitstreams are supported, but seeking within them is only fully supported if the BASS_STREAM_PRESCAN flag is used (or the BASS_CONFIG_OGG_PRESCAN config option is enabled) to have them pre-scanned.
            Without pre-scanning, seeking will only be possible back to the start. The BASS_POS_OGG "mode" can be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> to get the number of bitstreams and with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> to seek to a particular one.
            A BASS_SYNC_OGG_CHANGE sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed of when a new bitstream begins during decoding/playback.</para>
            <para>Multi-channel (ie. more than stereo) OGG, WAV and AIFF files are supported.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>.</para>
            <para>If length = 0 (use all data up to the end of the file), and the file length increases after creating the stream (ie. the file is still being written), then BASS will play the extra data too, but the length returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> will not be updated until the end is reached. The <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> return values will be updated during playback of the extra data though.</para>
            <para>When streaming from memory, the memory must not be freed before the stream is freed. There may be exceptions to that with some add-ons (see the documentation).</para>
            <para>To stream a file from the internet, use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. To stream from other locations, see <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>Don't forget to pin your memory object when using this overload.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="length"/> must be specified when streaming from memory.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC/MP4 and WMA. On iOS and OSX, CoreAudio codecs are supported, adding support for any file formats that have a codec installed. Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file.</para>
            </remarks>
            <example>
            The following example demontrates how to stream from memory:
            <code>
            private GCHandle _hGCFile;
            ...
            // open a file
            FileStream fs = File.OpenRead( "test.mp3" );
            // get the legth of the file
            long length = fs.Length;
            // create the buffer which will keep the file in memory
            byte[] buffer = new byte[length];
            // read the file into the buffer
            fs.Read(buffer, 0, (int)length);
            // buffer is filled, file can be closed
            fs.Close();
            
            // now create a pinned handle, so that the Garbage Collector will not move this object
            _hGCFile = GCHandle.Alloc( buffer, GCHandleType.Pinned );
            // create the stream (AddrOfPinnedObject delivers the necessary IntPtr)
            int stream = Bass.BASS_StreamCreateFile(_hGCFile.AddrOfPinnedObject(),
                              0L, length, BASSFlag.BASS_SAMPLE_FLOAT);
            
            if (stream != 0 &amp;&amp; Bass.BASS_ChannelPlay(stream, false) )
            {
            	// playing...
            }
            else
            {
            	Console.WriteLine("Error = {0}", Bass.BASS_ErrorGetCode());
            }
            ...
            // when playback has ended and the pinned object is not needed anymore, 
            // we need to free the handle!
            // Note: calling this method to early will crash the application, 
            // since the buffer would be stolen from BASS while still playing!
            _hGCFile.Free();
            </code>
            <code lang="vbnet">
            Private _hGCFile As GCHandle
            ...
            ' open a file
            Dim fs As FileStream = File.OpenRead("test.mp3")
            ' get the legth of the file
            Dim length As Long = fs.Length
            ' create the buffer which will keep the file in memory
            Dim buffer(length - 1) As Byte
            ' read the file into the buffer
            fs.Read(buffer, 0, length)
            ' buffer is filled, file can be closed
            fs.Close()
            
            ' now create a pinned handle, so that the Garbage Collector will not move this object
            _hGCFile = GCHandle.Alloc(buffer, GCHandleType.Pinned)
            ' create the stream (AddrOfPinnedObject delivers the necessary IntPtr)
            Dim stream As Integer = Bass.BASS_StreamCreateFile(_hGCFile.AddrOfPinnedObject(),
                                         0L, length, BASSFlag.BASS_SAMPLE_FLOAT)
            
            If stream &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(stream, False) Then
              ' playing...
            Else
              Console.WriteLine("Error = {0}", Bass.BASS_ErrorGetCode())
            End If
            ...
            ' when playback has ended and the pinned object is not needed anymore, 
            ' we need to free the handle!
            ' Note: calling this method to early will crash the application, 
            ' since the buffer would be stolen from BASS while still playing!
            _hGCFile.Free()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateURLUnicode(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateURLAscii(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="url"></param>
            <param name="offset"></param>
            <param name="flags"></param>
            <param name="proc"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)">
            <summary>
            Creates a sample stream from an MP3, MP2, MP1, OGG, WAV, AIFF or plugin supported file on the internet, optionally receiving the downloaded data in a callback.
            </summary>
            <param name="url">URL of the file to stream. Should begin with "http://", "https://" or "ftp://", or another add-on supported protocol.
            The URL can be followed by custom HTTP request headers to be sent to the server; the URL and each header should be terminated with a carriage return and line feed ("\r\n").</param>
            <param name="offset">File position to start streaming from. This is ignored by some servers, specifically when the file length is unknown, for example a Shout/Icecast server.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the stream to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D streams must be mono. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. This flag is ignored when streaming in blocks (BASS_STREAM_BLOCK).</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream.</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>Restrict the download rate of the file to the rate required to sustain playback. If this flag is not used, then the file will be downloaded as quickly as the user's internet connection allows.</description></item>
            <item><term>BASS_STREAM_BLOCK</term><description>Download and play the file in smaller chunks, instead of downloading the entire file to memory. Uses a lot less memory than otherwise, but it is not possible to seek or loop the stream; once it has ended, the file must be opened again to play it again. This flag will automatically be applied when the file length is unknown, for example with Shout/Icecast streams. This flag also has the effect of restricting the download rate.</description></item>
            <item><term>BASS_STREAM_STATUS</term><description>Pass status info (HTTP/ICY tags) from the server to the <see cref="T:Un4seen.Bass.DOWNLOADPROC"/> callback during connection. This can be useful to determine the reason for a failure.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the stream when it ends. This allows you to stream a file and forget about it, as BASS will automatically free the stream's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. The BASS_SAMPLE_SOFTWARE, BASS_SAMPLE_3D, BASS_SAMPLE_FX, BASS_STREAM_AUTOFREE and SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>.</description></item>
            </list>
            </param>
            <param name="proc">Callback function to receive the file as it is downloaded... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new stream's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on the format (sample rate, resolution, channels) of the stream. The playback length of the stream can be retrieved using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>.</para>
            <para>When playing the stream, BASS will stall the playback if there is insufficient data to continue playing. Playback will automatically be resumed when sufficient data has been downloaded. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if the playback is stalled, and the progress of the file download can be checked with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>.</para>
            <para>When streaming in blocks (BASS_STREAM_BLOCK flag), be careful not to stop/pause the stream for too long, otherwise the connection may timeout due to there being no activity and the stream will end prematurely.</para>
            <para>When streaming from Shoutcast servers, metadata (track titles) may be sent by the server. The data can be retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>. A sync can also be set (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>) so that you are informed when metadata is received. A BASS_SYNC_OGG_CHANGE sync can be used to be informed of when a new logical bitstream begins in an Icecast/OGG stream.</para>
            <para>When using an <paramref name="offset"/>, the file length returned by <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check that it was successful by comparing it with the original file length. Another way to check is to inspect the HTTP headers retrieved with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</para>
            <para>Custom HTTP request headers may be ignored by some plugins, notably BASSWMA.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels (BASS_STREAM_DECODE) are allowed when using the "no sound" device. The BASS_STREAM_AUTOFREE flag is also unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_NONET</term><description>No internet connection could be opened. Can be caused by a bad <see cref="T:Un4seen.Bass.BASSConfig">proxy setting</see>.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="url"/> is not a valid URL.</description></item>
            <item><term>BASS_ERROR_TIMEOUT</term><description>The server did not respond to the request within the timeout period, as set with the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_NET_TIMEOUT</see> config option.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_CODEC</term><description>The file uses a codec that's not available/supported. This can apply to WAV and AIFF files, and also MP3 files when using the "MP3-free" BASS version.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>On Windows and Windows CE, ACM codecs are supported with compressed WAV files. Media Foundation codecs are also supported on Windows 7 and updated versions of Vista, including support for AAC and WMA. On iOS and OSX, CoreAudio codecs are supported, including support for AAC and ALAC. Media Foundation and CoreAudio codecs are only tried after the built-in decoders and any plugins have rejected the file. Built-in support for IMA and Microsoft ADPCM WAV files is provided on Linux/Android/Windows CE, while they are supported via ACM and CoreAudio codecs on Windows and OSX/iOS.</para>
            </remarks>
            <example>
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            int channel = Bass.BASS_StreamCreateURL("http://someurl.com:8000", 0, 
                               BASSFlag.BASS_DEFAULT, null, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            Dim channel As Integer = Bass.BASS_StreamCreateURL("http://someurl.com:8000", 0, 
                                          BASSFlag.BASS_DEFAULT, Nothing, IntPtr.Zero)
            Bass.BASS_ChannelPlay(channel, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)">
            <summary>
            Retrieves the decoding/download/end position of a file stream.
            </summary>
            <param name="handle">The stream's handle.</param>
            <param name="mode">The file position to retrieve. One of the following (<see cref="T:Un4seen.Bass.BASSStreamFilePosition"/>):
            <list type="table">
            <item><term>BASS_FILEPOS_ASYNCBUF</term><description>The amount of data in the asynchronous file reading buffer. This requires that the BASS_ASYNCFILE flag was used at the stream's creation.</description></item>
            <item><term>BASS_FILEPOS_CURRENT</term><description>Position that is to be decoded for playback next. This will be a bit ahead of the position actually being heard due to buffering.</description></item>
            <item><term>BASS_FILEPOS_END</term><description>End of the file, in other words the file length. When streaming in blocks, the file length is unknown, so the download buffer length is returned instead.</description></item>
            <item><term>BASS_FILEPOS_SIZE</term><description>Total size of the file.</description></item>
            <item><term>BASS_FILEPOS_START</term><description>Start of stream data in the file.</description></item>
            <item><term>BASS_FILEPOS_DOWNLOAD</term><description>Download progress of an internet file stream or "buffered" user file stream.</description></item>
            <item><term>BASS_FILEPOS_CONNECTED</term><description>Internet file stream or "buffered" user file stream is still connected? 0 = no, 1 = yes.</description></item>
            <item><term>BASS_FILEPOS_BUFFER</term><description>The amount of data in the buffer of an internet file stream or "buffered" user file stream. Unless streaming in blocks, this is the same as BASS_FILEPOS_DOWNLOAD.</description></item>
            <item><term>BASS_FILEPOS_BUFFERING</term><description>The percentage of buffering remaining before playback of an internet file stream or 'buffered' user file stream can resume.</description></item>
            </list>
            <i>Other modes may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If succesful, then the requested file position is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>ID3 tags (both v1 and v2) and WAVE headers, as well as any other rubbish at the start of the file, are excluded from the calculations of this function.</para>
            <para>This is useful for average bitrate calculations, but it means that the BASS_FILEPOS_CURRENT position may not be the actual file position - the BASS_FILEPOS_START position can be added to it to get the actual file position.</para>
            <para>When streaming a file from the internet or a "buffered" user file stream, the entire file is downloaded even if the audio data ends before that, in case there are tags to be read. This means that the BASS_FILEPOS_DOWNLOAD position may go beyond the BASS_FILEPOS_END position.</para>
            <para>It's unwise to use this function (with mode = BASS_FILEPOS_CURRENT) for syncing purposes because it returns the position that's being decoded, not the position that's being heard.
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> for syncing instead.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested file position/status is not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the percentage downloaded of an internet file stream, 
            or the buffering progress when streaming in blocks:
            <code>
            float progress;
            // file length
            int len = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END);
            // download progress
            int down = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_DOWNLOAD);
            // get channel info
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            // streaming in blocks?
            if (info.flags &amp; BASSFlag.BASS_STREAM_BLOCK != BASSFlag.BASS_DEFAULT)
            { 
              // decode position
              int dec = BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_CURRENT);
              // percentage of buffer used
              progress = (down-dec)*100f / len;
              if (progress &gt; 100)
                progress = 100; // restrict to 100 (can be higher)
            } 
            else
            {
              // percentage of file downloaded
              progress = down*100f / len;
            }
            </code>
            <code lang="vbnet">
            Dim progress As Single
            ' file length
            Dim len As Integer = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END)
            ' download progress
            Dim down As Integer = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_DOWNLOAD)
            ' get channel info
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            ' streaming in blocks?
            If info.flags And BASSFlag.BASS_STREAM_BLOCK &lt;&gt; BASSFlag.BASS_DEFAULT Then
              ' decode position
              Dim dec As Integer = BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_CURRENT)
              ' percentage of buffer used
              progress =(down - dec) * 100F / len
              If progress &gt; 100 Then
                progress = 100 ' restrict to 100 (can be higher)
              End If
            Else
              ' percentage of file downloaded
              progress = down * 100F / len
            End If
            </code>
            Get the average bitrate of a file:
            <code>
            // playback duration
            double time = Bass.BASS_ChannelBytes2Seconds(stream, Bass.BASS_ChannelGetLength(stream));
            // file length
            long len = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END);
            // bitrate (kbps)
            int bitrate = (int)(len/(125*time)+0.5d);
            </code>
            <code lang="vbnet">
            ' playback duration
            Dim time As Double = Bass.BASS_ChannelBytes2Seconds(stream, Bass.BASS_ChannelGetLength(stream))
            ' file length
            Dim len As Long = Bass.BASS_StreamGetFilePosition(stream, BASSStreamFilePosition.BASS_FILEPOS_END)
            ' bitrate (kbps)
            Dim bitrate As Integer = CInt(len /(125 * time) + 0.5)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)">
            <summary>
            Frees a sample stream's resources, including any SYNC/DSP/FX it has.
            </summary>
            <param name="handle"> The stream handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">Pointer to the sample data (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="length">The amount of data in bytes, optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance. The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (with restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (with pos = 0).</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of float sample data to provide (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance. The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (with restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (with pos = 0).</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of Int32 sample data to provide (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space; Caution: Int32=2xInt16, so this overload can e.g. be used to provide a stereo sample containing of two 16-bit values).</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance. The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (with restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (with pos = 0).</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of Int16 sample data to provide (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="length">The amount of data in bytes! (buffer.Length/2), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance. The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (with restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (with pos = 0).</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of byte sample data to provide (<see langword="null"/> = allocate space in the queue buffer so that there is at least length bytes of free space).</param>
            <param name="length">The amount of data in bytes, optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance. The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (with restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (with pos = 0).</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Creating a stream duplicate:
            <code>
            private DSPPROC _dupCallback;
            ...
            // create stream on device 1
            Bass.BASS_SetDevice(1);
            int orig = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP);
            Bass.BASS_ChannelPlay(orig, false);
            ...
            // create a clone on device 2
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
            Bass.BASS_SetDevice(2);
            int clone = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero);
            // pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream);
            int c = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, (int)BASSData.BASS_DATA_AVAILABLE);
            byte[] buf = new byte[c];
            Bass.BASS_ChannelGetData(stream, buf, c);
            Bass.BASS_StreamPutData(clone, buf, c);
            // set DSP to copy new data from source stream
            _dupCallback = new DSPPROC(DupDSP);
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, new IntPtr(clone), 0);
            Bass.BASS_ChannelPlay(orig, false); // resume source
            Bass.BASS_ChannelPlay(clone, false); // play clone
            ...
            private void DupDSP(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Private _dupCallback As DSPPROC
            ...
            ' create stream on device 1
            Bass.BASS_SetDevice(1)
            Dim orig As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_LOOP)
            Bass.BASS_ChannelPlay(orig, False)
            ...
            ' create a clone on device 2
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
            Bass.BASS_SetDevice(2)
            Dim clone As Integer = Bass.BASS_StreamCreatePush(info.freq, info.chans, info.flags, IntPtr.Zero)
            ' pause source stream to synchonise buffer contents
            Bass.BASS_ChannelPause(stream)
            Dim c As Integer = Bass.BASS_ChannelGetData(stream, IntPtr.Zero, CInt(BASSData.BASS_DATA_AVAILABLE))
            Dim buf(c) As Byte
            Bass.BASS_ChannelGetData(stream, buf, c)
            Bass.BASS_StreamPutData(clone, buf, c)
            ' set DSP to copy new data from source stream
            _dupCallback = New DSPPROC(DupDSP)
            Bass.BASS_ChannelSetDSP(orig, _dupCallback, New IntPtr(clone), 0)
            Bass.BASS_ChannelPlay(orig, False) ' resume source
            Bass.BASS_ChannelPlay(clone, False) ' play clone
            ...
            Private Sub DupDSP(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              Bass.BASS_StreamPutData(user.ToInt32(), buffer, length)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds sample data to a "push" stream.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>).</param>
            <param name="buffer">The array of byte sample data to provide.</param>
            <param name="startIdx">The start index within the <paramref name="buffer"/> to provide the data from.</param>
            <param name="length">The amount of data in bytes (starting at <paramref name="startIdx"/>), optionally using the <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> flag to signify the end of the stream. 0 can be used to just check how much data is queued.</param>
            <returns>If successful, the amount of queued data is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As much data as possible will be placed in the stream's playback buffer, and any remainder will be queued for when more space becomes available, ie. as the buffered data is played. 
            With a decoding channel, there is no playback buffer, so all data is queued in that case. There is no limit to the amount of data that can be queued, besides available memory.
            The queue buffer will be automatically enlarged as required to hold the data, but it can also be enlarged in advance. The queue buffer is freed when the stream ends or is reset, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> (with restart = TRUE) or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> (with pos = 0).</para>
            <para>DSP/FX are applied when the data reaches the playback buffer, or the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call in the case of a decoding channel.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, BASS will automatically stall playback of the stream, until more data is provided. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled. 
            A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the push system.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">Pointer to the file data.</param>
            <param name="length">The amount of data in bytes, or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of float values to provide to the file data.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of Int32 values to provide to the file data (Caution: Int32=2xInt16, so this overload can e.g. be used to provide a stereo sample containing of two 16-bit values).</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4), or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of Int16 values to provide to the file data.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/2), or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Adds data to a "push buffered" user file stream's buffer.
            </summary>
            <param name="handle">The stream handle (as created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFERPUSH system flag.).</param>
            <param name="buffer">The array of byte values to provide to the file data.</param>
            <param name="length">The amount of data in bytes, or <see cref="T:Un4seen.Bass.BASSStreamProc">BASS_STREAMPROC_END</see> to end the file.</param>
            <returns>If successful, the number of bytes read from buffer is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If there is not enough space in the stream's file buffer to receive all of the data, then only the amount that will fit is read from buffer. <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> can be used to check the amount of space in the buffer.</para>
            <para>File data should be provided at a rate sufficent to sustain playback. If there is insufficient file data, and the playback buffer is subsequently exhausted, BASS will automatically stall playback of the stream, until more data is available. A BASS_SYNC_STALL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The stream is not using the STREAMFILE_BUFFERPUSH file system.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The stream has ended.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoadUnicode(System.Boolean,System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Only used internally! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for details!
            </summary>
            <param name="mem">Needs to be set to <see langword="false"/></param>
            <param name="file">The filename to load.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            <para>This overload implements Unicode filenames. The BASS_UNICODE flag will be added automatically.</para>
            </summary>
            <param name="file">The file name from where to load the music.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_MUSIC_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the MOD music in mono (uses less CPU than stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the MOD music to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Enable 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D channels are mono, so BASS_SAMPLE_MONO is automatically applied. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the music.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the music.</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping (as used in FastTracker 2).</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping".</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Play .MOD file as FastTracker 2 would.</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Play .MOD file as ProTracker 1 would.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset bpm/etc when seeking.</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Apply XMPlay's surround sound to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Apply XMPlay's surround sound mode 2 to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_FT2PAN</term><description>Apply FastTracker 2 panning to XM files.</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</description></item>
            <item><term>BASS_MUSIC_PRESCAN</term><description>Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. In the case of musics that loop, the length until the loop occurs is calculated. Use BASS_ChannelGetLength to retrieve the length.</description></item>
            <item><term>BASS_MUSIC_NOSAMPLE</term><description>Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.</description></item>
            <item><term>BASS_MUSIC_AUTOFREE</term><description>Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. Note that some musics never actually end on their own (ie. without you stopping them).</description></item>
            <item><term>BASS_MUSIC_DECODE</term><description>Decode the music into sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. The BASS_SAMPLE_MONO flag is automatically applied when using a mono speaker assignment flag.</description></item>
            <item><term>BASS_UNICODE</term><description>file is a Unicode (16-bit characters) filename (not needed with this overload).</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>MO3s are treated and used in exactly the same way as normal MOD musics. The advantage of MO3s is that they can be a lot smaller with virtually identical quality. Playing a MO3 does not use any more CPU power than playing the original MOD version does. The only difference is a slightly longer load time as the samples are being decoded. MO3 files are created using the MO3 encoder available at the BASS website.</para>
            <para>DMO effects (the same as available with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker. This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy. Of course, the effects require some CPU, so should not be used carelessly if performance is key. DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.</para>
            <para>"Ramping" does not take a lot of extra processing and improves the sound quality by removing clicks, by ramping/smoothing volume and pan changes. The start of a sample may also be ramped-in. That is always the case with XM files (or MOD files in FT2 mode) when using normal ramping, and possibly with all formats when using sensitive ramping; senstitive ramping will only ramp-in when necessary to avoid a click. Generally, normal ramping is recommended for XM files, and sensitive ramping for the other formats, but some XM files may also sound better using sensitive ramping.</para>
            <para>When loading a MOD music from memory, BASS does not use the memory after it's loaded the MOD music. So you can do whatever you want with the memory after calling this function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_MUSIC_AUTOFREE flag is unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows. They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb. When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.</para>
            </remarks>
            <example>
            <code>
            int music = Bass.BASS_MusicLoad("test.mod", 0, 0, BASSFlag.BASS_DEFAULT, 0);
            </code>
            <code lang="vbnet">
            Dim music As Integer = Bass.BASS_MusicLoad("test.mod", 0, 0, BASSFlag.BASS_DEFAULT, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoadMemory(System.Boolean,System.IntPtr,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Only used internally! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for details!
            </summary>
            <param name="mem">Needs to be set to <see langword="true"/></param>
            <param name="memory">An IntPtr to the memory block.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Needs to be set to the length of the buffer data which should be played.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.IntPtr,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            <para>This overload implements loading from memory.</para>
            </summary>
            <param name="memory">An unmanaged pointer to the memory location as an IntPtr.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_MUSIC_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the MOD music in mono (uses less CPU than stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the MOD music to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Enable 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D channels are mono, so BASS_SAMPLE_MONO is automatically applied. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the music.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the music.</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping (as used in FastTracker 2).</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping".</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Play .MOD file as FastTracker 2 would.</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Play .MOD file as ProTracker 1 would.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset bpm/etc when seeking.</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Apply XMPlay's surround sound to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Apply XMPlay's surround sound mode 2 to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_FT2PAN</term><description>Apply FastTracker 2 panning to XM files.</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</description></item>
            <item><term>BASS_MUSIC_PRESCAN</term><description>Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. In the case of musics that loop, the length until the loop occurs is calculated. Use BASS_ChannelGetLength to retrieve the length.</description></item>
            <item><term>BASS_MUSIC_NOSAMPLE</term><description>Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.</description></item>
            <item><term>BASS_MUSIC_AUTOFREE</term><description>Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. Note that some musics never actually end on their own (ie. without you stopping them).</description></item>
            <item><term>BASS_MUSIC_DECODE</term><description>Decode the music into sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. The BASS_SAMPLE_MONO flag is automatically applied when using a mono speaker assignment flag.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>MO3s are treated and used in exactly the same way as normal MOD musics. The advantage of MO3s is that they can be a lot smaller with virtually identical quality. Playing a MO3 does not use any more CPU power than playing the original MOD version does. The only difference is a slightly longer load time as the samples are being decoded. MO3 files are created using the MO3 encoder available at the BASS website.</para>
            <para>DMO effects (the same as available with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker. This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy. Of course, the effects require some CPU, so should not be used carelessly if performance is key. DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.</para>
            <para>Ramping doesn't take a lot of extra processing and improves the sound quality by removing "clicks". Sensitive ramping leaves sharp attacked samples, while normal ramping can cause them to lose a-bit of their impact. Generally, normal ramping is recommended for XMs, and sensitive ramping for the other formats. But, some XMs may also sound better using sensitive ramping.</para>
            <para>When loading a MOD music from memory, BASS does not use the memory after it's loaded the MOD music. So you can do whatever you want with the memory after calling this function.
            This means there is no need to pin the memory buffer for this method.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_MUSIC_AUTOFREE flag is unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows. They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb. When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.</para>
            </remarks>
            <example>
            See <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>for examples on how to load data from memory.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoadMemory(System.Boolean,System.Byte[],System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Only used internally! See the file overload of <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> for details!
            </summary>
            <param name="mem">Needs to be set to <see langword="true"/></param>
            <param name="memory">An IntPtr to the memory block.</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Needs to be set to the length of the buffer data which should be played.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.Byte[],System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)">
            <summary>
            Loads a MOD music file - MO3 / IT / XM / S3M / MTM / MOD / UMX formats.
            <para>This overload implements loading from memory.</para>
            </summary>
            <param name="memory">A managed memory location as a byte[].</param>
            <param name="offset">File offset to load the MOD music from.</param>
            <param name="length">Data length... 0 = use all data up to the end of file. If length over-runs the end of the file, it'll automatically be lowered to the end of the file.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the sample data will be 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers or the BASS_MUSIC_DECODE flag are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more info.</description></item>
            <item><term>BASS_SAMPLE_MONO</term><description>Decode/play the MOD music in mono (uses less CPU than stereo). This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>Force the MOD music to not use hardware mixing.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>Enable 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 3D channels are mono, so BASS_SAMPLE_MONO is automatically applied. The SPEAKER flags can not be used together with this flag.</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>Requires DirectX 8 or above: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the music.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the music.</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping (as used in FastTracker 2).</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping".</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Play .MOD file as FastTracker 2 would.</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Play .MOD file as ProTracker 1 would.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset bpm/etc when seeking.</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Apply XMPlay's surround sound to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Apply XMPlay's surround sound mode 2 to the music (ignored in mono).</description></item>
            <item><term>BASS_MUSIC_FT2PAN</term><description>Apply FastTracker 2 panning to XM files.</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</description></item>
            <item><term>BASS_MUSIC_PRESCAN</term><description>Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. In the case of musics that loop, the length until the loop occurs is calculated. Use BASS_ChannelGetLength to retrieve the length.</description></item>
            <item><term>BASS_MUSIC_NOSAMPLE</term><description>Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.</description></item>
            <item><term>BASS_MUSIC_AUTOFREE</term><description>Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. Note that some musics never actually end on their own (ie. without you stopping them).</description></item>
            <item><term>BASS_MUSIC_DECODE</term><description>Decode the music into sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. The BASS_SAMPLE_MONO flag is automatically applied when using a mono speaker assignment flag.</description></item>
            </list>
            </param>
            <param name="freq">Sample rate to render/play the MOD music at... 0 = the rate specified in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</param>
            <returns>If successful, the loaded music's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>BASS uses the same code as XMPlay for it's MOD music support, giving the most accurate reproduction of MO3 / IT / XM / S3M / MTM / MOD / UMX files available from any sound system.</para>
            <para>MO3s are treated and used in exactly the same way as normal MOD musics. The advantage of MO3s is that they can be a lot smaller with virtually identical quality. Playing a MO3 does not use any more CPU power than playing the original MOD version does. The only difference is a slightly longer load time as the samples are being decoded. MO3 files are created using the MO3 encoder available at the BASS website.</para>
            <para>DMO effects (the same as available with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>) can be used in IT and XM files (and MO3 versions of them) created with Modplug Tracker. This allows effects to be added to a track without having to resort to an MP3 or OGG version, so it can remain small and still sound fancy. Of course, the effects require some CPU, so should not be used carelessly if performance is key. DirectX 8 (or above) is required for the effects to be heard - without that, the music can still be played, but the effects are disabled.</para>
            <para>Ramping doesn't take a lot of extra processing and improves the sound quality by removing "clicks". Sensitive ramping leaves sharp attacked samples, while normal ramping can cause them to lose a-bit of their impact. Generally, normal ramping is recommended for XMs, and sensitive ramping for the other formats. But, some XMs may also sound better using sensitive ramping.</para>
            <para>When loading a MOD music from memory, BASS does not use the memory after it's loaded the MOD music. So you can do whatever you want with the memory after calling this function.
            This means there is no need to pin the memory buffer for this method.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_MUSIC_AUTOFREE flag is unavailable to decoding channels.</description></item>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The file could not be opened.</description></item>
            <item><term>BASS_ERROR_FILEFORM</term><description>The file's format is not recognised/supported.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the stream is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_SPEAKER</term><description>The specified SPEAKER flags are invalid. The device/drivers do not support them, they are attempting to assign a stereo stream to a mono speaker or 3D functionality is enabled.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>Could not initialize 3D support.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Away from Windows, all mixing is done in software (by BASS), so the BASS_SAMPLE_SOFTWARE flag is unnecessary. The BASS_SAMPLE_FX flag is also ignored.</para>
            <para>DMO effects are not supported in MOD music on Windows CE, and DirectX 8 (or above) is required on Windows. They are always available on other platforms, except for the following: Compressor, Gargle, and I3DL2Reverb. When a DMO effect is unavailable, the MOD music can still be played, but the effect will be disabled.</para>
            </remarks>
            <example>
            The following example demontrates how to load music from memory:
            <code>
            // Init Bass
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            // open file
            FileStream fs = File.OpenRead( "test.mod" );
            // get the length of the file
            int length = (int)fs.Length;
            // create the buffer which will keep the file in memory
            byte[] buffer = new byte[length];
            // read the file into the buffer
            fs.Read(buffer, 0, length);
            // buffer is filled, file can be closed
            fs.Close();
            // load music from memory buffer
            int music = Bass.BASS_MusicLoad(buffer, 0, length, BASSFlag.BASS_DEFAULT, 0);
            if (music != 0 &amp;&amp; Bass.BASS_ChannelPlay(stream, false) )
            {
            	// playing...
            }
            else
            {
            	Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode());
            }
            </code>
            <code lang="vbnet">
            ' Init Bass
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            ' open file
            Dim fs As FileStream = File.OpenRead("test.mod")
            ' get the length of the file
            Dim length As Integer = CInt(fs.Length)
            ' create the buffer which will keep the file in memory
            Dim buffer(length - 1) As Byte
            ' read the file into the buffer
            fs.Read(buffer, 0, length)
            ' buffer is filled, file can be closed
            fs.Close()
            ' load music from memory buffer
            Dim music As Integer = Bass.BASS_MusicLoad(buffer, 0, length, BASSFlag.BASS_DEFAULT, 0)
            If music &lt;&gt; 0 AndAlso Bass.BASS_ChannelPlay(stream, False) Then
              ' playing...
            Else
              Console.WriteLine("Error={0}", Bass.BASS_ErrorGetCode())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_MusicFree(System.Int32)">
            <summary>
            Frees a MOD music's resources, including any sync/DSP/FX it has.
            </summary>
            <param name="handle">The MOD music handle (which has been created with <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>).</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)">
            <summary>
            Initializes a recording device.
            </summary>
            <param name="device">The device to use... -1 = default device, 0 = first. <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceCount"/> can be used to get the total number of devices.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use BASS_ErrorGetCode to get the error code.</returns>
            <remarks>
            This function must be successfully called before using the recording features.
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetDevice(System.Int32)"/> is used to switch the current recording device. When successful, <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> automatically sets the current thread's device to the one that was just initialized</para>
            <para>When using the default device (device = -1), <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDevice"/> can be used to find out which device it was mapped to. On Windows, it'll always be the first device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DX</term><description>A sufficient version of DirectX is not installed.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been initialized. <see cref="M:Un4seen.Bass.Bass.BASS_RecordFree"/> must be called before it can be initialized again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>There is no available device driver.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Recording support requires DirectX 5 (or above) on Windows. On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config; that could map directly to one of the other devices or it could use ALSA plugins.</para>
            </remarks>
            <example>
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _byteswritten = 0;
            private byte[] _recbuffer; // local recording buffer
            ...
            if ( Bass.BASS_RecordInit(-1) )
            {
              _myRecProc = new RECORDPROC(MyRecording);
              int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
              ...
              // start recording
              Bass.BASS_ChannelPlay(recHandle, false);
            }
            ...
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // increase the rec buffer as needed
                if (_recbuffer == null || _recbuffer.Length &lt; length)
                  _recbuffer = new byte[length];
                // copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length);
                _byteswritten += length;
                // write to file
                ...
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _byteswritten As Integer = 0
            Private _recbuffer() As Byte ' local recording buffer
            ...
            If Bass.BASS_RecordInit(-1) Then
              _myRecProc = New RECORDPROC(AddressOf MyRecording)
              Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
              ...
              ' start recording
              Bass.BASS_ChannelPlay(recHandle, False)
            End If
            ...
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Dim cont As Boolean = True
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' increase the rec buffer as needed
                If _recbuffer Is Nothing OrElse _recbuffer.Length &lt; length Then
                  _recbuffer = New Byte(length) {}
                End If
                ' copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length)
                _byteswritten += length
                ' write to file
                ...
                ' stop recording after a certain amout (just to demo)
                If _byteswritten &gt; 800000 Then
                  cont = False ' stop recording
                End If
              End If
              Return cont
            End Function
            </code>
            If you are into C# you might also use an unsafe codeblock with native pointer access 
            (which might be must faster than the above - depending on what you are doing with the data):
            <code>
            private unsafe bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // assuming 16-bit sample data here
                short *data = (short*)buffer;
                ...
            
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="freq">The sample rate to record at.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo, etc.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>)
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the recorded data is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more information.</description></item>
            <item><term>BASS_RECORD_PAUSE</term><description>Start the recording paused. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> together with the handle returned by this method to start it.</description></item>
            </list>
            </param>
            <param name="proc">The user defined function to receive the recorded sample data... can be <see langword="null"/> if you do not wish to use a callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else <see langword="false"/> is returned. Use BASS_ErrorGetCode to get the error code.</returns>
            <remarks>
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> to stop the recording, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/> to paused it. Recording can also be started in a paused state (via the BASS_RECORD_PAUSE flag), allowing DSP/FX to be set on it before any data reaches the callback function.
            <para>The sample data will generally arrive from the recording device in blocks rather than in a continuous stream, so when specifying a very short period between callbacks, some calls may be skipped due to there being no new data available since the last call.</para>
            <para>When not using a callback (proc = <see langword="null"/>), the recorded data is instead retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. To keep latency at a minimum, the amount of data in the recording buffer should be monitored (also done via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, with the BASS_DATA_AVAILABLE flag) to check that there is not too much data;
            freshly recorded data will only be retrieved after the older data in the buffer is.</para>
            <para>When freq and/or chans is set to 0 for the device's current values, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> can be used afterwards to find out what values are being used by the recording.</para>
            <para>A recording may end unexpectedly if the device fails, eg. if it is disconnected/disabled. A BASS_SYNC_DEV_FAIL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed if that happens. It will not be possible to resume the recording channel then; a new recording channel will need to be created when the device becomes available again.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_BUSY</term><description>The device is busy. An existing recording must be stopped before starting another one. Multiple simultaneous recordings can be made from the same device on Windows XP and Vista, but generally not on older Windows.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The recording device is not available. Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported. If using the BASS_SAMPLE_FLOAT flag, it could be that floating-point recording is not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Multiple simultaneous recordings can be made from the same device on Windows XP and later, but generally not on older Windows. Multiple simultaneous recordings are possible on iOS and OSX, but may not always be on Linux or Windows CE.
            On OSX and iOS, the device is instructed (when possible) to deliver data at the period set in the HIWORD of flags, even when a callback function is not used. On other platforms, it is up the the system when data arrives from the device.</para>
            </remarks>
            <example>
            Start recording at 44100hz 16-bit stereo:
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the Garbage Collector can not remove it
            ...
            Bass.BASS_RecordInit(-1);
            _myRecProc = new RECORDPROC(MyRecording);
            // start recording paused
            int recChannel = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
            ...
            // really start recording
            Bass.BASS_ChannelPlay(recChannel, false);
            ...
            // the recording callback
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC
            ...
            Bass.BASS_RecordInit(- 1)
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            ' start recording paused
            Dim recChannel As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
            ...
            ' really start recording
            Bass.BASS_ChannelPlay(recChannel, False)
            ...
            ' the recording callback
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            See <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> for a recording callback sample.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.Int32,Un4seen.Bass.RECORDPROC,System.IntPtr)">
            <summary>
            Starts recording.
            </summary>
            <param name="freq">The sample rate to record at.</param>
            <param name="chans">The number of channels... 1 = mono, 2 = stereo.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>)
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the recorded data is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>Use 32-bit floating-point sample data. WDM drivers are required to use this flag in Windows. See <a href="../Overview.html#FloatingPoint">Floating-point channels</a> for more information.</description></item>
            <item><term>BASS_RECORD_PAUSE</term><description>Start the recording paused. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> together with the handle returned by this method to start it.</description></item>
            </list>
            </param>
            <param name="period">Set the period (in milliseconds) between calls to the callback function (<see cref="T:Un4seen.Bass.RECORDPROC"/>). The minimum period is 5ms, the maximum the maximum is half the BASS_CONFIG_REC_BUFFER setting. If the period specified is outside this range, it is automatically capped. The default is 100ms.</param>
            <param name="proc">The user defined function to receive the recorded sample data... can be <see langword="null"/> if you do not wish to use a callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, the new recording's handle is returned, else <see langword="false"/> is returned. Use BASS_ErrorGetCode to get the error code.</returns>
            <remarks>
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> to stop the recording. Recording can also be paused with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/>.
            <para>The sample data will generally arrive from the recording device in blocks rather than in a continuous stream, so when specifying a very short period between callbacks, some calls may be skipped due to there being no new data available since the last call.</para>
            <para>When specifying a very short period between RECORDPROC calls, some calls may be skipped due to there being no new data available from the recording device since the last call. This is more likely to happen with drivers that do not have hardware support.</para>
            <para>Starting the recording paused (BASS_RECORD_PAUSE) allows DSP/FX to be set on the recording channel before any data reaches the RECORDPROC function.</para>
            <para>Not using a callback (proc = <see langword="null"/>) allows lower latency for full-duplex recording (ie. playing the data as it's being recorded), as you get the recorded data on demand via the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> function. To keep latency at a minimum, the amount of data in the recording buffer should be monitored (also done via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, with the BASS_DATA_AVAILABLE flag) to check that there's not too much data;
            freshly recorded data will only be retrieved after the older data in the buffer is.</para>
            <para>When freq and/or chans is set to 0 for the device's current values, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> can be used afterwards to find out what values are being used by the recording.</para>
            <para>A recording may end unexpectedly if the device fails, eg. if it is disconnected/disabled. A BASS_SYNC_DEV_FAIL sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be informed if that happens. It will not be possible to resume the recording channel then; a new recording channel will need to be created when the device becomes available again.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_BUSY</term><description>The device is busy. An existing recording must be stopped before starting another one. Multiple simultaneous recordings can be made from the same device on Windows XP and Vista, but generally not on older Windows.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The recording device is not available. Another application may already be recording with it, or it could be a half-duplex device and is currently being used for playback.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported. If using the BASS_SAMPLE_FLOAT flag, it could be that floating-point recording is not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Start recording at 44100hz 16-bit stereo with a 50ms recording period:
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the Garbage Collector can not remove it
            ...
            Bass.BASS_RecordInit(-1);
            _myRecProc = new RECORDPROC(MyRecording);
            // start recording paused
            int recChannel = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, 50, _myRecProc, IntPtr.Zero);
            ...
            // really start recording
            Bass.BASS_ChannelPlay(recChannel, false);
            ...
            // the recording callback
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC
            ...
            Bass.BASS_RecordInit(-1)
            _myRecProc = New RECORDPROC(AddressOf MyRecording)
            ' start recording paused
            Dim recChannel As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, 50, _myRecProc, IntPtr.Zero)
            ...
            ' really start recording
            Bass.BASS_ChannelPlay(recChannel, False)
            ...
            ' the recording callback
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            See <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> for a recording callback sample.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfoInternal(System.Int32,Un4seen.Bass.BASS_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available recording devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_DX</term><description>A sufficient version of DirectX is not installed.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Recording support requires DirectX 5 (or above) on Windows. On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config.</para>
            </remarks>
            <example>
            List all available recording devices:
            <code>
            BASS_DEVICEINFO info = new BASS_DEVICEINFO();
            for (int n=0; Bass.BASS_RecordGetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While (Bass.BASS_RecordGetDeviceInfo(n, info))
              Console.WriteLine(info.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a recording device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available recording devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            <item><term>BASS_ERROR_DX</term><description>A sufficient version of DirectX is not installed.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Recording support requires DirectX 5 (or above) on Windows. On Linux, a "Default" device is hardcoded to device number 0, which uses the default input set in the ALSA config.</para>
            </remarks>
            <example>Find the system default recording device:
            <code>
            int defDevice = -1;
            BASS_DEVICEINFO info;
            for (int n = 0; (info = Bass.BASS_RecordGetDeviceInfo(n)) != null; n++)
            {
              if (info.IsDefault)
              {
                defDevice = n;
                break;
              }
            }
            </code>
            <code lang="vbnet">
            Dim defDevice As Integer = -1
            Dim n As Integer = 0
            Dim info As New BASS_DEVICEINFO()
            While Not (info Is Nothing)
              info = Bass.BASS_RecordGetDeviceDescription(n)
              If Not (info Is Nothing) And info.IsDefault Then
                defDevice = n
                Exit While
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfos">
            <summary>
            Returns all available recording devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> elements representing the available recording devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceCount">
            <summary>
            Returns the total number of available recording devices.
            </summary>
            <returns>Number of real recording devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordSetDevice(System.Int32)">
            <summary>
            Sets the recording device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = first recording device.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The functions that use the recording device selection are the following: 
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordFree"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInfo(Un4seen.Bass.BASS_RECORDINFO)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.</para>
            <para>When one of the above functions (or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDevice"/>) is called, BASS will check the current thread's recording device setting, and if no device is selected (or the selected device is not initialized), BASS will automatically select the lowest device that is initialized. 
            This means that when using a single device, there is no need to use this function - BASS will automatically use the device that's initialized. 
            Even if you free the device, and initialize another, BASS will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetDevice">
            <summary>
            Retrieves the recording device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/>to get the error code.</returns>
            <remarks>See also <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInfo(Un4seen.Bass.BASS_RECORDINFO)">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> class to store the information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>There is no need to initialize any size member of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> structure as described in the C/C++ interface, since all marchalling is already handled by the API here.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_RECORDINFO info = new BASS_RECORDINFO();
            bool ok = Bass.BASS_RecordGetInfo(info);
            </code>
            <code lang="vbnet">
            Dim info As New BASS_RECORDINFO()
            Dim ok As Boolean = Bass.BASS_RecordGetInfo(info)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInfo">
            <summary>
            Retrieves information on the recording device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> class on success - else <see langword="null"/>.</returns>
            <remarks>There is no need to initialize any size member of the <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/> structure as described in the C/C++ interface, since all marchalling is already handled by the API here.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_RECORDINFO info = Bass.BASS_RecordGetInfo(info);
            if (info != null)
              Console.WriteLine(info.ToString());
            </code>
            <code lang="vbnet">
            Dim info As BASS_RECORDINFO = Bass.BASS_RecordGetInfo(info)
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputNamePtr(System.Int32)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)">
            <summary>
            Retrieves the text description of a recording input source.
            </summary>
            <param name="input">The input to get the description of... 0 = first, -1 = master.</param>
            <returns>If succesful, then the description is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>A master input is not available.</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The returned string is in ANSI or UTF-8 form on Windows, depending on the BASS_CONFIG_UNICODE setting. It is in UTF-16 form ("WCHAR" rather than "char") on Windows CE, and in UTF-8 form on other platforms.</para>
            <para>On OSX, there is no master input (-1).</para>
            </remarks>
            <example>
            Get the name of the first input:
            <code>
            string inputName = Bass.BASS_RecordGetInputName(0);
            </code>
            <code lang="vbnet">
            Dim inputName As String = Bass.BASS_RecordGetInputName(0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputNames">
            <summary>
            Returns all available recording input source names.
            </summary>
            <returns>An array of strings representing the available recording input source names.</returns>
            <remarks>Uses <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)"/> internally.
            <para>The index of the returned names equals the input-id, which might be used with <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)">
            <summary>
            Adjusts the settings of a recording input source.
            </summary>
            <param name="input">The input to adjust the settings of... 0 = first, -1 = master.</param>
            <param name="setting">The new setting... a combination of these flags (<see cref="T:Un4seen.Bass.BASSInput"/>):
            <list type="table">
            <item><term>BASS_INPUT_OFF</term><description>Disable the input. This flag can't be used when the device supports only one input at a time.</description></item>
            <item><term>BASS_INPUT_ON</term><description>Enable the input. If the device only allows one input at a time, then any previously enabled input will be disabled by this.</description></item>
            <item><term>BASS_INPUT_NONE</term><description>Don't change any setting. Use this flag, if you only want to set the volume.</description></item>
            </list>
            </param>
            <param name="volume">The volume level... 0 (silent) to 1 (max), less than 0 = leave current.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The actual volume level may not be exactly the same as requested, due to underlying precision differences. <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> can be used to confirm what the volume is.</para>
            <para>The volume curve used by this function is always linear, the BASS_CONFIG_CURVE_VOL config option setting has no effect on this.</para>
            <para>Changes made by this function are system-wide, ie. other software using the device will be affected by it.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> or <paramref name="volume"/> is invalid.</description></item>
            <item><term>BASS_NOTAVAIL</term><description>The soundcard/driver doesn't allow you to change the input or it's volume.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <example>
            <code>
            // Disable the master input without changing the volume:
            Bass.BASS_RecordSetInput(-1, BASSInput.BASS_INPUT_OFF, -1f );
            
            // Enable the first input and set the volume to 50%:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_ON, 0.5f );
            
            // Set the volume of the first input without changing the settings:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_NONE, 1f );
            </code>
            <code lang="vbnet">
            ' Disable the master input without changing the volume:
            Bass.BASS_RecordSetInput(-1, BASSInput.BASS_INPUT_OFF, -1F)
            
            ' Enable the first input and set the volume to 50%:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_ON, 0.5F)
            
            ' Set the volume of the first input without changing the settings:
            Bass.BASS_RecordSetInput(0, BASSInput.BASS_INPUT_NONE, 1F );
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)">
            <summary>
            Retrieves the settings of a recording input source.
            </summary>
            <param name="input">The input to get the settings of... 0 = first, -1 = master.</param>
            <param name="volume">Reference to a variable to receive the current volume.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            If successful, then the settings are returned. The BASS_INPUT_OFF flag will be set if the input is disabled, 
            otherwise the input is enabled. The type of input (see <see cref="T:Un4seen.Bass.BASSInputType"/>) is also indicated in the high 8-bits (use BASS_INPUT_TYPE_MASK to test) of the return value, 
            and can be one of the following. If the volume is requested but not available, volume will receive -1.
            <list type="table">
            <item><term>BASS_INPUT_TYPE_DIGITAL</term><description>Digital input source, for example, a DAT or audio CD.</description></item>
            <item><term>BASS_INPUT_TYPE_LINE</term><description>Line-in. On some devices, "Line-in" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input.</description></item>
            <item><term>BASS_INPUT_TYPE_MIC</term><description>Microphone.</description></item>
            <item><term>BASS_INPUT_TYPE_SYNTH</term><description>Internal MIDI synthesizer.</description></item>
            <item><term>BASS_INPUT_TYPE_CD</term><description>Analog audio CD.</description></item>
            <item><term>BASS_INPUT_TYPE_PHONE</term><description>Telephone.</description></item>
            <item><term>BASS_INPUT_TYPE_SPEAKER</term><description>PC speaker.</description></item>
            <item><term>BASS_INPUT_TYPE_WAVE</term><description>The device's WAVE/PCM output.</description></item>
            <item><term>BASS_INPUT_TYPE_AUX</term><description>Auxiliary. Like "Line-in", "Aux" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input on some devices.</description></item>
            <item><term>BASS_INPUT_TYPE_ANALOG</term><description>Analog, typically a mix of all analog sources.</description></item>
            <item><term>BASS_INPUT_TYPE_UNDEF</term><description>Anything that is not covered by the other types.</description></item>
            </list>
            </returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>A master input is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The input type information is only available on Windows. There is no "what you hear" type of input defined; if the device has one, it will typically come under BASS_INPUT_TYPE_ANALOG or BASS_INPUT_TYPE_UNDEF.</para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <example>
            List all available input sources, with their current status:
            <code>
            Bass.BASS_RecordInit(-1); // init the default device
            string name;
            for (int n = 0; (name = Bass.BASS_RecordGetInputName(n)) != null; n++)
            {
              float vol = 0f;
              int setting = Bass.BASS_RecordGetInput(n, ref vol);
              Console.WriteLine("{0} [{1} : {2}] - {3}", 
                                name, 
                                (BASSInputType)((int)BASSInputType.BASS_INPUT_TYPE_MASK &amp; setting), 
                                vol,
                                ((int)BASSInput.BASS_INPUT_OFF &amp; setting) != 0 ? "Off" : "On");
            }
            </code>
            <code lang="vbnet">
            Bass.BASS_RecordInit(-1) ' init the default device
            Dim n As Integer = 0
            Dim name As String = ""
            While Not (name Is Nothing)
              name = Bass.BASS_RecordGetInputName(n)
              n += 1
              If Not (name Is Nothing) Then
                Dim vol As Single = 0F
                Dim setting As Integer = Bass.BASS_RecordGetInput(n, vol)
                Console.WriteLine("{0} [{1} : {2}] - {3}", 
                                  name, 
                                  CType(CInt(BASSInputType.BASS_INPUT_TYPE_MASK) And setting, BASSInputType), 
                                  vol,
                                  CStr(IIf(CInt(BASSInput.BASS_INPUT_OFF) And setting &lt;&gt; 0, "Off", "On")))
              End If
            End While
            </code>
            Find a microphone input:
            <code>
            Bass.BASS_RecordInit(-1);
            int mic = -1;
            int n = 0;
            int settings = 0;
            float vol = 0f;
            while (settings != -1)
            {
              // get the settings of that input
              settings = Bass.BASS_RecordGetInput(n, ref vol);
              if ( (settings &amp; (int)BASSInputType.BASS_INPUT_TYPE_MASK) == (int)BASSInputType.BASS_INPUT_TYPE_MIC )
              { 
                // found the mic!
                mic = n;
                break;
              }
              n++;
            }
            if (mic != -1)
              Console.WriteLine( "Found a MIC at input {0}", mic );
            else
              Console.WriteLine( "No MIC found!" );
            </code>
            <code lang="vbnet">
            Bass.BASS_RecordInit(-1)
            Dim mic As Integer = -1
            Dim n As Integer = 0
            Dim settings As Integer = 0
            Dim vol As Single = 0F
            While settings &lt;&gt; -1
              ' get the settings of that input
              settings = Bass.BASS_RecordGetInput(n, vol)
              If (settings And CInt(BASSInputType.BASS_INPUT_TYPE_MASK)) = CInt(BASSInputType.BASS_INPUT_TYPE_MIC) Then
                ' found the mic!
                mic = n
                Exit While
              End If
              n += 1
            End While
            If mic &lt;&gt; -1 Then
              Console.WriteLine("Found a MIC at input {0}", mic)
            Else
              Console.WriteLine("No MIC found!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32)">
            <summary>
            Retrieves the setting of a recording input source.
            </summary>
            <param name="input">The input to get the settings of... 0 = first, -1 = master.</param>
            <returns>One of the <see cref="T:Un4seen.Bass.BASSInput"/> values (BASS_INPUT_NONE on error).</returns>
            <remarks><see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> returns both, the <see cref="T:Un4seen.Bass.BASSInputType"/> (in the high-word) 
            as well as the <see cref="T:Un4seen.Bass.BASSInput"/> (in the low-word).
            Use this overload to only retrieve the <see cref="T:Un4seen.Bass.BASSInput"/> without the <see cref="T:Un4seen.Bass.BASSInputType"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>A master input is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The input type information is only available on Windows. There is no "what you hear" type of input defined; if the device has one, it will typically come under BASS_INPUT_TYPE_ANALOG or BASS_INPUT_TYPE_UNDEF.</para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputPtr(System.Int32,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="input"></param>
            <param name="vol"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordGetInputType(System.Int32)">
            <summary>
            Retrieves the type of input of a recording input source.
            </summary>
            <param name="input">The input to get the settings of... 0 = first, -1 = master.</param>
            <returns>One of the <see cref="T:Un4seen.Bass.BASSInputType"/> values (BASS_INPUT_TYPE_ERROR on error).</returns>
            <remarks><see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> returns both, the <see cref="T:Un4seen.Bass.BASSInputType"/> (in the high-word) 
            as well as the <see cref="T:Un4seen.Bass.BASSInput"/> (in the low-word).
            Use this overload to only retrieve the <see cref="T:Un4seen.Bass.BASSInput"/> without the <see cref="T:Un4seen.Bass.BASSInputType"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="input"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>The input type information is only available on Windows. There is no "what you hear" type of input defined; if the device has one, it will typically come under BASS_INPUT_TYPE_ANALOG or BASS_INPUT_TYPE_UNDEF.</para>
            <para>On OSX, there is no master input (-1), and only the currently enabled input has its volume setting available (if it has a volume control).</para>
            </remarks>
            <example>
            Find a microphone input:
            <code>
            Bass.BASS_RecordInit(-1); // init the default device
            int mic = -1;
            BASSInputType flags;
            for (int n=0; (flags=Bass.BASS_RecordGetInputType(n)) != BASSInputType.BASS_INPUT_TYPE_ERROR; n++)
            {
              if ( (flags &amp; BASSInputType.BASS_INPUT_TYPE_MASK) == BASSInputType.BASS_INPUT_TYPE_MIC )
              { 
                // found the mic!
                mic = n;
                break;
              }
            }
            if (mic != -1)
              Console.WriteLine( "Found a MIC at input {0}", mic );
            else
              Console.WriteLine( "No MIC found!" );
            </code>
            <code lang="vbnet">
            Bass.BASS_RecordInit(- 1)
            Dim mic As Integer = -1
            Dim n As Integer = 0
            Dim flags As BASSInputType = BASSInputType.BASS_INPUT_TYPE_UNDEF
            While flags &lt;&gt; BASSInputType.BASS_INPUT_TYPE_ERROR
              ' get the settings of that input
              flags = Bass.BASS_RecordGetInputType(n)
              If (flags And BASSInputType.BASS_INPUT_TYPE_MASK) = BASSInputType.BASS_INPUT_TYPE_MIC) Then
                ' found the mic!
                mic = n
                Exit While
              End If
              n += 1
            End While
            If mic &lt;&gt; -1 Then
              Console.WriteLine("Found a MIC at input {0}", mic)
            Else
              Console.WriteLine("No MIC found!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_RecordFree">
            <summary>
            Frees all resources used by the recording device.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function should be called for all initialized recording devices before your program exits.</para>
            <para>When using multiple recording devices, the current thread's device setting (as set with <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has not been successfully called - there are no initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="info"><see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> instance where to store the channel information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the channel info:
            <code>
            BASS_CHANNELINFO info = new BASS_CHANNELINFO();
            Bass.BASS_ChannelGetInfo(_stream, info);
            Console.WriteLine( info.ToString() );
            </code>
            <code lang="vbnet">
            Dim info As New BASS_CHANNELINFO()
            Bass.BASS_ChannelGetInfo(_stream, info)
            Console.WriteLine(info.ToString())
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32)">
            <summary>
            Retrieves information on a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>An instance of the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> class on success - else <see langword="null"/>.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the channel info:
            <code>
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(_stream);
            Console.WriteLine( info.ToString() );
            </code>
            <code lang="vbnet">
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(_stream)
            Console.WriteLine(info.ToString())
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)">
            <summary>
            Starts (or resumes) playback of a sample, stream, MOD music, or recording.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD handle.</param>
            <param name="restart">Restart playback from the beginning? If handle is a user stream, it's current buffer contents are flushed. If it's a MOD music, it's BPM/etc are automatically reset to their initial values.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When streaming in blocks (BASS_STREAM_BLOCK), the restart parameter is ignored as it's not possible to go back to the start. The <paramref name="restart"/> parameter is also of no consequence with recording channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_START</term><description>The output is paused/stopped, use <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> to start it.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The channel is not playable, it's a "decoding channel".</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_ERROR_NOHW</term><description>No hardware voices are available (HCHANNEL only). This only occurs if the sample was loaded/created with the BASS_SAMPLE_VAM flag, and BASS_VAM_HARDWARE is set in the sample's VAM mode, and there are no hardware voices available to play it.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            // create the stream
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            ' create the stream
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Bass.BASS_StreamFree(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)">
            <summary>
            Sets up a user DSP function on a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="proc">The callback function (see <see cref="T:Un4seen.Bass.DSPPROC"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="priority">The priority of the new DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <returns>If succesful, then the new DSP's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            <para>Equally, you can also remove them at any time. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/> to remove a DSP function.</para>
            <para>Multiple DSP functions may be used per channel, in which case the order that the functions are called is determined by their priorities. Any DSPs that have the same priority are called in the order that they were added.</para>
            <para>DSP functions can be applied to MOD musics and streams, but not samples. If you want to apply a DSP function to a sample, then you should stream the sample.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example shows a little gain amplifier, assuming you are processing 32-bit BASS_SAMPLE_FLOAT!
            <code>
            private float _gainDB = 0f;
            private int _stream = 0;
            private DSPPROC _myDSPProc; // make it global, so that the GC can not remove it
            ...
            _gainDB = 6f; // amplify by +6dB
            _stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                           BASSFlag.BASS_STREAM_AUTOFREE | BASSFlag.BASS_SAMPLE_FLOAT);
            // set a DSP user callback method
            _myDSPProc = new DSPPROC(MyDSPGain);
            // set the user DSP callback
            Bass.BASS_ChannelSetDSP(_stream, _myDSPProc, IntPtr.Zero, 0);
            ...
            // this is the actual processing method
            private void MyDSPGain(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // the global variable _gainDB contains the amplification value in dB!
              if (_gainDB == 0f || length == 0 || buffer == IntPtr.Zero)
                return;
            
              // convert the _gainDB value to a float
              float _gainAmplification = (float)Math.Pow(10d, _gainDB / 20d);
              // number of bytes in 32-bit floats, since length is in bytes
              int l4 = length/4;
              float[] data = new float[l4];
              // copy from managed to unmanaged memory
              Marshal.Copy(buffer, data, 0, l4);
              // apply gain, assumeing using 32-bit floats (no clipping here ;-)
              for (int a=0; a&lt;l4; a++)
                data[a] = data[a] * _gainAmplification;
              // copy back from unmanaged to managed memory
              Marshal.Copy(data, 0, buffer, l4);
            }
            </code>
            <code lang="vbnet">
            Private _gainDB As Single = 0F
            Private _stream As Integer = 0
            Private _myDSPProc As DSPPROC ' make it global, so that the GC can not remove it
            ...
            _gainDB = 6f; // amplify by +6dB
            _stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                           BASSFlag.BASS_STREAM_AUTOFREE Or BASSFlag.BASS_SAMPLE_FLOAT)
            ' set a DSP user callback method
            _myDSPProc = New DSPPROC(AddressOf MyDSPGain)
            ' set the user DSP callback
            Bass.BASS_ChannelSetDSP(_stream, _myDSPProc, IntPtr.Zero, 0)
            ...
            ' this is the actual processing method
            Private Sub MyDSPGain(handle As Integer, channel As Integer, 
                                  buffer As IntPtr, length As Integer, user As IntPtr)
              ' the global variable _gainDB contains the amplification value in dB!
              If _gainDB = 0F OrElse length = 0 OrElse buffer = IntPtr.Zero Then
                Return
              End If 
              ' convert the _gainDB value to a float
              Dim _gainAmplification As Single = CSng(Math.Pow(10.0, _gainDB / 20.0))
              ' number of bytes in 32-bit floats, since length is in bytes
              Dim l4 As Integer = length / 4
              Dim data(l4 - 1) As Single
              ' copy from managed to unmanaged memory
              Marshal.Copy(buffer, data, 0, l4)
              ' apply gain, assumeing using 32-bit floats (no clipping here ;-)
              Dim a As Integer
              For a = 0 To l4 - 1
                data(a) = data(a) * _gainAmplification
              Next a
              ' copy back from unmanaged to managed memory
              Marshal.Copy(data, 0, buffer, l4)
            End Sub
            </code>
            This example is type safe but 'slow', since two copy operations are involved. 
            One from unmanaged BASS to managed .NET and when processing has been done locally from .NET back to BASS.
            However, for VB.Net users this is almost the only way to do it.
            <para>C# user can be a little more lucky, since C# supports unsafe code blocks and native pointer access - 
            which will be shown in the following example:</para>
            <code>
            private unsafe void MyDSPGain(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (_gainDB == 1f || length == 0 || buffer == IntPtr.Zero)
                return;
            
              // convert the _gainDB value to a float
              float _gainAmplification = (float)Math.Pow(10d, _gainDB / 20d);
              // length is in bytes, so the number of floats to process is length/4 
              int l4 = length / 4;
              // cast the given buffer IntPtr to a native pointer to float values
              float *data = (float*)buffer;
              for (int a=0; a&lt;l4; a++)
              {
                data[a] = data[a] * _gainAmplification;
                // alternatively you can also use:
                // *data = *data * _gainAmplification;
                // data++;
              }
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            This overload uses an IntPtr to reference the buffer data.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">Location to write the data as an IntPtr (can be <see cref="F:System.IntPtr.Zero"/> when handle is a recording channel (HRECORD), to discard the requested amount of data from the recording buffer).
            <para>Use "Marshal.AllocCoTaskMem" to allocate a memory buffer, use "Marshal.Copy" to copy the buffer data from unmanaged BASS to your managed code and use "Marshal.FreeCoTaskMem" to free the memory buffer when not needed anymore.</para>
            <para>Or make use of a "GCHandle" to receive data to a pinned managed object.</para>
            </param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FIXED</term><description>Return 8.24 fixed-point data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT16384</term><description>16384 sample FFT (returns 8192 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Perform a separate FFT for each channel, rather than a single combined FFT. The size of the data returned (as listed above) is multiplied by the number of channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>Prevent a Hann window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_FFT_REMOVEDC</term><description>Remove any DC bias from the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_FFT_COMPLEX</term><description>Return the complex FFT result rather than the magnitudes. This increases the amount of data returned (as listed above) fourfold, as it returns real and imaginary parts and the full FFT result (not only the first half). The real and imaginary parts are interleaved in the returned data.</description></item>
            <item><term>BASS_DATA_FFT_NYQUIST</term><description>Return an extra value for the Nyquist frequency magnitude. The Nyquist frequency is always included in a complex FFT result.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT or BASS_DATA_FIXED flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a decoding channel, data is decoded directly from the channel's source (no playback buffer) and as much data as the channel has available can be decoded at a time.</para>
            <para>When retrieving sample data, 8-bit samples are unsigned (0 to 255) , 16-bit samples are signed (-32768 to 32767), 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range). That is unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point if it is not already, or if the BASS_DATA_FIXED flag is used, in which case the data will be coverted to 8.24 fixed-point.</para>
            <para>Unless complex data is requested via the BASS_DATA_FFT_COMPLEX flag, the magnitudes of the first half of an FFT result are returned.
            For example, with a 2048 sample FFT, there will be 1024 floating-point values returned.  If the BASS_DATA_FIXED flag is used, then the FFT values will be in 8.24 fixed-point form rather than floating-point. Each value, or "bin", ranges from 0 to 1 (can actually go higher if the sample data is floating-point and not clipped). The 1st bin contains the DC component, the 2nd contains the amplitude at 1/2048 of the channel's sample rate, followed by the amplitude at 2/2048, 3/2048, etc.
            A Hann window is applied to the sample data to reduce leakage, unless the BASS_DATA_FFT_NOWINDOW flag is used. When a window is applied, it causes the DC component to leak into the next bin, but that can be removed (reduced to 0) by using the BASS_DATA_FFT_REMOVEDC flag.
            Doing so slightly increases the processing required though, so it should only be done when needed, which is when a window is applied and the 2nd bin value is important.</para>
            <para>Channels that have 2 or more sample channels (ie. stereo or above) may have FFT performed on each individual channel, using the BASS_DATA_FFT_INDIVIDUAL flag. Without this flag, all of the channels are combined, and a single mono FFT is performed. Performing the extra individual FFTs of course increases the amount of processing required. The return values are interleaved in the same order as the channel's sample data, eg. stereo = left,right,left,etc.</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>FFT processing hint 1: DC stands for direct current (same as what a flashlight cell gives out) and is represents a 0 Hz sound, which cannot exist in real life. A sound sample should not have any DC component but probably will due to inaccuracies in the recording equipment. You won't hear it (except a click when playing and stopping the sample).
            The DC component is basically the average of all the samples that the FFT was applied to, and is pretty useless.
            You'll have to halve the DC component that BASS returns to get the actual DC component, as BASS doubles all the bin values.
            </para>
            <para>FFT processing hint 2: How to read out the amplitude of a single frequency/a frequency band?
            FFT[0] maps to amplitude at 0 Hz, FFT[length-1] maps to amplitude at Nyquist's frequency. So the index to FFT data at an arbitrary band is:
            <code lang="none">
            idx = length*freq/Nyquist
            where:
            length : length of the returned FFT buffer (in samples)
            freq : required frequency (Hz)
            Nyquist : Nyquist's frequency of the signal (half the sampling rate) (in Hz)
            </code>
            Example: If the stream is 44100Hz, then 16500Hz will be around bin 191 of a 512 sample FFT (512*16500/44100).
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 a tone at 540Hz will be at: 540*4096/44100 = 50.15, so a bit of the energy will be in fft[51], but mostly in fft[50].
            Note: With a sample rate of 44100 the Nyquist frequency is 22050Hz, which is the max. frequency. This is also why BASS_DATA_FFT4096 only returns 2048 values - fft[2048] would represent 22050Hz.
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            <para><b>Platform-specific:</b></para>
            <para>The BASS_DATA_FIXED flag is only available on Android and Windows CE.</para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_SAMPLE_FLOAT flag.
            So the buffer will contain 32-bit values between -1 and 1...as an array of float:
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be held
            // only length/4 elements needed, since length is in byte and a float uses 4 bytes
            float[] data = new float[length/4];
            
            // create a pinned handle to a managed object
            GCHandle hGC = GCHandle.Alloc(data, GCHandleType.Pinned);
            
            // get the data
            length = Bass.BASS_ChannelGetData(channel, hGC.AddrOfPinnedObject(), length);
            
            // free the pinned handle
            hGC.Free();
            </code>
            <code lang="vbnet">
            ' a 30ms window in bytes to be filled with sample data
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            
            ' first we need a mananged object where the sample data should be held
            ' only length/4 elements needed, since length is in byte and a float uses 4 bytes
            Dim data(length/4 - 1) As Single
            
            ' create a pinned handle to a managed object
            Dim hGC As GCHandle = GCHandle.Alloc(data, GCHandleType.Pinned)
            
            ' get the data
            length = Bass.BASS_ChannelGetData(channel, hGC.AddrOfPinnedObject(), length)
            
            ' free the pinned handle
            hGC.Free()
            </code>
            A more simple way is to use the other overloads where you simply pass the array itself 
            (those overloads pass the buffer array as a reference type by value with automatic pinning,
            which is as fast as the following example).
            <para>If you are into C# you might even use native pointers in an unsafe code block:</para>
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be held
            // only length/4 elements needed, since length is in byte and a float uses 4 bytes
            float[] data = new float[length/4];
            
            // start an unsafe code block allowing you to use native pointers
            unsafe
            {
              // pointers to managed objects need to be fixed
              fixed (float* buffer = data)    // equivalent to buffer = &amp;data[0]
              {
                length = Bass.BASS_ChannelGetData(channel, (IntPtr)buffer, length);
              }
            }
            </code>
            This is by far the fastest way to use BASS_ChannelGetData, but unfortunately not availabe with VB.Net.
            However, the other overloads do automatically pin the buffer as needed and are as fast as this.
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of a sample channel, stream, MOD music, or recording channel.
            This overload uses a managed float[] to reference the buffer data as 32-bit!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_FLOAT!
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (float[]) to receive the data, use BASS_SAMPLE_FLOAT when creating the channel stream!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT16384</term><description>16384 sample FFT (returns 8192 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Perform a separate FFT for each channel, rather than a single combined FFT. The size of the data returned (as listed above) is multiplied by the number of channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>Prevent a Hann window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_FFT_REMOVEDC</term><description>Remove any DC bias from the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_FFT_COMPLEX</term><description>Return the complex FFT result rather than the magnitudes. This increases the amount of data returned (as listed above) fourfold, as it returns real and imaginary parts and the full FFT result (not only the first half). The real and imaginary parts are interleaved in the returned data.</description></item>
            <item><term>BASS_DATA_FFT_NYQUIST</term><description>Return an extra value for the Nyquist frequency magnitude. The Nyquist frequency is always included in a complex FFT result.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the channel (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a decoding channel, data is decoded directly from the channel's source (no playback buffer) and as much data as the channel has available can be decoded at a time.</para>
            <para>When retrieving sample data, 8-bit samples are unsigned (0 to 255) , 16-bit samples are signed (-32768 to 32767), 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range). That is unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point if it is not already.</para>
            <para>Unless complex data is requested via the BASS_DATA_FFT_COMPLEX flag, the magnitudes of the first half of an FFT result are returned.
            For example, with a 2048 sample FFT, there will be 1024 floating-point values returned. Each value, or "bin", ranges from 0 to 1 (can actually go higher if the sample data is floating-point and not clipped). The 1st bin contains the DC component, the 2nd contains the amplitude at 1/2048 of the channel's sample rate, followed by the amplitude at 2/2048, 3/2048, etc.
            A Hann window is applied to the sample data to reduce leakage, unless the BASS_DATA_FFT_NOWINDOW flag is used. When a window is applied, it causes the DC component to leak into the next bin, but that can be removed (reduced to 0) by using the BASS_DATA_FFT_REMOVEDC flag.
            Doing so slightly increases the processing required though, so it should only be done when needed, which is when a window is applied and the 2nd bin value is important.</para>
            <para>Channels that have 2 or more sample channels (ie. stereo or above) may have FFT performed on each individual channel, using the BASS_DATA_FFT_INDIVIDUAL flag. Without this flag, all of the channels are combined, and a single mono FFT is performed. Performing the extra individual FFTs of course increases the amount of processing required. The return values are interleaved in the same order as the channel's sample data, eg. stereo = left,right,left,etc.</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>FFT processing hint 1: DC stands for direct current (same as what a flashlight cell gives out) and is represents a 0 Hz sound, which cannot exist in real life. A sound sample should not have any DC component but probably will due to inaccuracies in the recording equipment. You won't hear it (except a click when playing and stopping the sample).
            The DC component is basically the average of all the samples that the FFT was applied to, and is pretty useless.
            You'll have to halve the DC component that BASS returns to get the actual DC component, as BASS doubles all the bin values.
            </para>
            <para>FFT processing hint 2: How to read out the amplitude of a single frequency/a frequency band?
            FFT[0] maps to amplitude at 0 Hz, FFT[length-1] maps to amplitude at Nyquist's frequency. So the index to FFT data at an arbitrary band is:
            <code lang="none">
            idx = length*freq/Nyquist
            where:
            length : length of the returned FFT buffer (in samples)
            freq : required frequency (Hz)
            Nyquist : Nyquist's frequency of the signal (half the sampling rate) (in Hz)
            </code>
            Example: If the stream is 44100Hz, then 16500Hz will be around bin 191 of a 512 sample FFT (512*16500/44100).
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 a tone at 540Hz will be at: 540*4096/44100 = 50.15, so a bit of the energy will be in fft[51], but mostly in fft[50].
            Note: With a sample rate of 44100 the Nyquist frequency is 22050Hz, which is the max. frequency. This is also why BASS_DATA_FFT4096 only returns 2048 values - fft[2048] would represent 22050Hz.
            </para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_SAMPLE_FLOAT flag.
            So the buffer will contain 32-bit values between -1 and 1...as an array of float:
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be placed
            // length is in bytes, so the number of floats to process is length/4 
            float[] data = new float[length/4];
            
            // get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length);
            </code>
            <code lang="vbnet">
            ' a 30ms window in bytes to be filled with sample data
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            
            ' first we need a mananged object where the sample data should be placed
            ' length is in bytes, so the number of floats to process is length/4 
            Dim data(length/4 - 1) As Single
            
            ' get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length)
            </code>
            The next example will gather the immediate FFT data from a channel:
            <code>
            float[] fft = new float[2048];
            Bass.BASS_ChannelGetData(channel, fft, (int)BASSData.BASS_DATA_FFT4096)
            // assuming the channel's samplerate is 44.1kHz,
            // this will return the frequency represented by bucket 51
            int hz = Utils.FFTIndex2Frequency(51, 4096, 44100);
            </code>
            <code lang="vbnet">
            Dim fft(2048 - 1) As Single
            Bass.BASS_ChannelGetData(channel, fft, CInt(BASSData.BASS_DATA_FFT4096))
            ' assuming the channel's samplerate is 44.1kHz,
            ' this will return the frequency represented by bucket 51
            Dim hz As Integer = Utils.FFTIndex2Frequency(51, 4096, 44100)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Int16[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a sample channel, stream, MOD music, or recording channel.
            This overload uses a managed short[] to reference the buffer data as 16-bit values - each element will represent one channel in this case!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (short[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_DEFAULT flag.
            So the buffer will contain 16-bit values...as an array of short values.
            <code>
            // a 30ms window in bytes to be filled with sample data
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            
            // first we need a mananged object where the sample data should be placed
            // length is in bytes, so the number of shorts to process is length/2
            short[] data = new short[length/2];
            
            // get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length);
            </code>
            <code lang="vbnet">
            ' a 30ms window in bytes to be filled with sample data
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            
            ' first we need a mananged object where the sample data should be placed
            ' length is in bytes, so the number of floats to process is length/2
            Dim data(length/2 -1) As Short
            
            ' get the sample data
            length = Bass.BASS_ChannelGetData(channel, data, length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Int32[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a sample channel, stream, MOD music, or recording channel.
            This overload uses a managed int[] to reference the buffer data (Note: an int is 32-bit meaning if we expect to receive 16-bit data stereo a single int value will contain 2 x 16-bit, so a full stereo pair of data)!
            SHOULD ONLY BE USED, if the stream was created WITHOUT BASS_SAMPLE_FLOAT or BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (int[]) to receive the data, e.g. when creating the channel stream with default setting, meaning 16-bit samples, an int value contains 2 channels (left and right)!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_DEFAULT flag.
            So the buffer will contain 16-bit values...as an array of int - meaning one int (32bit) value will represent a stereo pair (left and right channel).
            <code>
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03); // 30ms window
            int[] data = new int[length/4]; // 2 x 16-bit and length in is bytes
            length = Bass.BASS_ChannelGetData(channel, data, length);
            // further processing of length/4 array elements...where each int value represents a stereo pair
            </code>
            <code lang="vbnet">
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            Dim data(length/4 - 1) As Integer  ' 2 x 16-bit and length in is bytes
            length = Bass.BASS_ChannelGetData(channel, data, length)
            ' further processing of length/4 array elements...where each int value represents a stereo pair
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Retrieves the immediate sample data of a sample channel, stream, MOD music, or recording channel.
            This overload uses a managed byte[] to reference the buffer data!
            SHOULD ONLY BE USED, if the stream was created with BASS_SAMPLE_8BITS!
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="buffer">The array (byte[]) to receive the data, e.g. when creating the channel with BASS_SAMPLE_8BITS!</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the channel has buffered. This flag is primarily of use when recording, and can't be used with decoding channels as they do not have playback buffers. buffer can be <see langword="null"/> when using this flag.</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the channel's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function can only return as much data as has been written to the channel's buffer, so it may not always be possible to get the amount of data requested, especially if you request large amounts. If you really do need large amounts, then increase the buffer lengths (BASS_CONFIG_BUFFER).
            The BASS_DATA_AVAILABLE flag can be used to check how much data a channel's buffer contains at any time, including when stopped or stalled.</para>
            <para>When requesting data from a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), there are no intermediate buffers involved, so as much data as is available can be decoded in one go.</para>
            <para>When retrieving sample data, the returned data is in the standard Windows PCM format: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range). That's unless the BASS_DATA_FLOAT flag is used, in which case, the sample data will be converted to 32-bit floating-point (if it isn't already).</para>
            <para>This function is most useful if you wish to visualize (eg. spectrum analyze) the sound.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has reached the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_DATA_AVAILABLE flag was used with a decoding channel.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            The following example assumes that you have created the stream with the BASS_SAMPLE_8BITS flag.
            So the buffer will contain 8-bit values...as an array of byte.
            <code>
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03); // 30ms window
            byte[] data = new byte[length]; // 8-bit are bytes
            length = Bass.BASS_ChannelGetData(channel, data, length);
            </code>
            <code lang="vbnet">
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            Dim data(length - 1) As Byte
            length = Bass.BASS_ChannelGetData(channel, data, length)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSeconds2Bytes(System.Int32,System.Double)">
            <summary>
            Translates a time (seconds) position into bytes, based on a channel's format.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="pos">The position to translate (in seconds, e.g. 0.03 = 30ms).</param>
            <returns>If successful, then the translated length in BYTES is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The translation is based on the channel's initial sample rate, when it was created.</para>
            <para>The return value is rounded down to the position of the nearest sample.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>Get the length of a 30ms window:
            <code>
            int length = (int)Bass.BASS_ChannelSeconds2Bytes(channel, 0.03);
            </code>
            <code lang="vbnet">
            Dim length As Integer = CInt(Bass.BASS_ChannelSeconds2Bytes(channel, 0.03))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)">
            <summary>
            Translates a byte position into time (seconds), based on a channel's format.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <param name="pos">The position in BYTES to translate.</param>
            <returns>If successful, then the translated length in seconds is returned, else a negative value is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The translation is based on the channel's initial sample rate, when it was created.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>Getting the elapsed and remaining time:
            <code>
            // length in bytes
            long len = Bass.BASS_ChannelGetLength(channel);
            // position in bytes
            long pos = Bass.BASS_ChannelGetPosition(channel);
            // the total time length
            double totaltime = Bass.BASS_ChannelBytes2Seconds(channel, len);
            // the elapsed time length
            double elapsedtime = Bass.BASS_ChannelBytes2Seconds(channel, pos);
            double remainingtime = totaltime - elapsedtime;
            </code>
            <code lang="vbnet">
            ' length in bytes
            Dim len As Long = Bass.BASS_ChannelGetLength(channel)
            ' position in bytes
            Dim pos As Long = Bass.BASS_ChannelGetPosition(channel)
            ' the total time length
            Dim totaltime As Double = Bass.BASS_ChannelBytes2Seconds(channel, len)
            ' the elapsed time length
            Dim elapsedtime As Double = Bass.BASS_ChannelBytes2Seconds(channel, pos)
            Dim remainingtime As Double = totaltime - elapsedtime
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)">
            <summary>
            Checks if a sample, stream, or MOD music is active (playing) or stalled. Can also check if a recording is in progress.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.Bass.BASSActive"/>):
            <list type="table">
            <item><term>BASS_ACTIVE_STOPPED</term><description>The channel is not active, or handle is not a valid channel.</description></item>
            <item><term>BASS_ACTIVE_PLAYING</term><description>The channel is playing (or recording).</description></item>
            <item><term>BASS_ACTIVE_PAUSED</term><description>The channel is paused.</description></item>
            <item><term>BASS_ACTIVE_PAUSED_DEVICE</term><description>The channel's device is paused.</description></item>
            <item><term>BASS_ACTIVE_STALLED</term><description>Playback of the stream has been stalled due to there not being enough sample data to continue playing. The playback will automatically resume once there's sufficient data to do so.</description></item>
            </list>
            </returns>
            <remarks>
            <para>When using this function with a decoding channel, BASS_ACTIVE_PLAYING will be returned while there is still data to decode. 
            Once the end has been reached, BASS_ACTIVE_STOPPED will be returned. 
            BASS_ACTIVE_STALLED is never returned for decoding channels; you can tell a decoding channel is stalled if <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> returns less data than requested, and this function still returns BASS_ACTIVE_PLAYING.</para>
            <para>The BASS_ACTIVE_PAUSED_DEVICE state can be the result of a <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/> call or of the device stopping unexpectedly (eg. a USB soundcard being disconnected). In either case, playback will be resumed by <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> can be used to differentiate a stopped channel from an invalid channel. The error code will be BASS_OK if the channel is valid and stopped.
            Syncs can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> to be notified when a channel reaches the end(BASS_SYNC_END sync) or stalls/resumes(BASS_SYNC_STALL sync) or pauses due to device failure(BASS_SYNC_DEV_FAIL sync).</para>
            </remarks>
            <example>
            <code>
            BASSActive status = BASS_ChannelIsActive(stream);
            if (status == BASSActive.BASS_ACTIVE_PLAYING)
            {
              // the stream is still playing
              ...
            }
            </code>
            <code lang="vbnet">
            Dim status As BASSActive = BASS_ChannelIsActive(stream)
            If status = BASSActive.BASS_ACTIVE_PLAYING Then
              ' the stream is still playing
              ...
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelLock(System.Int32,System.Boolean)">
            <summary>
            Locks a stream, MOD music or recording channel to the current thread.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM or HRECORD handle.</param>
            <param name="state">If <see langword="false"/>, unlock the channel, else lock it.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Locking a channel prevents other threads from performing most functions on it, including buffer updates. 
            Other threads wanting to access a locked channel will block until it is unlocked, so a channel should only be locked very briefly. 
            A channel must be unlocked in the same thread that it was locked.
            </remarks>
            <example>
            Lock a channel to ensure that 2 DSP functions start together:
            <code>
            Bass.BASS_ChannelLock(channel, true); // lock channel
            Bass.BASS_ChannelSetDSP(channel, DspProc1, null, 0); // set 1st DSP
            Bass.BASS_ChannelSetDSP(channel, DspProc2, null, 0); // set 2nd DSP
            Bass.BASS_ChannelLock(channel, false); // unlock channel
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelLock(channel, True); // lock channel
            Bass.BASS_ChannelSetDSP(channel, DspProc1, Nothing, 0); // set 1st DSP
            Bass.BASS_ChannelSetDSP(channel, DspProc2, Nothing, 0); // set 2nd DSP
            Bass.BASS_ChannelLock(channel, False); // unlock channel
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)">
            <summary>
            Retrieves the playback length of a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM. HSAMPLE handles may also be used.</param>
            <param name="mode">How to retrieve the length (one of the <see cref="T:Un4seen.Bass.BASSMode"/> flags):
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>Get the length in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDERS</term><description>Get the length in orders. (HMUSIC only).</description></item>
            <item><term>BASS_POS_OGG</term><description>Get the number of bitstreams in an OGG file.</description></item>
            </list>
            <i>Other modes may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If succesful, then the channel's length is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The exact length of a stream will be returned once the whole file has been streamed, but until then it is not always possible to 100% accurately estimate the length.
            The length is always exact for MP3/MP2/MP1 files when the BASS_STREAM_PRESCAN flag is used in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call, otherwise it is an (usually accurate) estimation based on the file size.
            The length returned for OGG files will usually be exact (assuming the file is not corrupt), but when streaming from the internet (or "buffered" user file), it can be a very rough estimation until the whole file has been downloaded.
            It will also be an estimate for chained OGG files that are not pre-scanned.</para>
            <para>Unless an OGG file contains a single bitstream, the number of bitstreams it contains will only be available if it was pre-scanned at the stream's creation.</para>
            <para>Retrieving the length of a MOD music requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The length is not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the duration (in seconds) of a channel:
            <code>
            // length in bytes
            long len = Bass.BASS_ChannelGetLength(channel, BASSMode.BASS_POS_BYTE);
            // the time length
            double time = Bass.BASS_ChannelBytes2Seconds(channel, len);
            </code>
            <code lang="vbnet">
            ' length in bytes
            Dim len As Long = Bass.BASS_ChannelGetLength(channel, BASSMode.BASS_POS_BYTE)
            ' the time length
            Dim time As Double = Bass.BASS_ChannelBytes2Seconds(channel, len)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32)">
            <summary>
            Retrieves the playback length in bytes of a channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM. HSAMPLE handles may also be used.</param>
            <returns>If succesful, then the channel's length is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The exact length of a stream will be returned once the whole file has been streamed, but until then it is not always possible to 100% accurately estimate the length.
            The length is always exact for MP3/MP2/MP1 files when the BASS_STREAM_PRESCAN flag is used in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call, otherwise it is an (usually accurate) estimation based on the file size.
            The length returned for OGG files will usually be exact (assuming the file is not corrupt), but when streaming from the internet (or "buffered" user file), it can be a very rough estimation until the whole file has been downloaded.
            It will also be an estimate for chained OGG files that are not pre-scanned.</para>
            <para>Unless an OGG file contains a single bitstream, the number of bitstreams it contains will only be available if it was pre-scanned at the stream's creation.</para>
            <para>Retrieving the length of a MOD music requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The length is not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the duration (in seconds) of a channel:
            <code>
            // length in bytes
            long len = Bass.BASS_ChannelGetLength(channel);
            // the time length
            double time = Bass.BASS_ChannelBytes2Seconds(channel, len);
            </code>
            <code lang="vbnet">
            ' length in bytes
            Dim len As Long = Bass.BASS_ChannelGetLength(channel)
            ' the time length
            Dim time As Double = Bass.BASS_ChannelBytes2Seconds(channel, len)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">
            <summary>
            Sets up a synchronizer on a MOD music, stream or recording channel.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="type">The type of sync (see the table below or <see cref="T:Un4seen.Bass.BASSSync"/>), you may also use these flags:
            <list type="table">
            <item><term>BASS_SYNC_ONETIME</term><description>Call the sync only once, and then remove it from the channel.</description></item>
            <item><term>BASS_SYNC_MIXTIME</term><description>Call the sync function when the sync occurs during decoding/mixing, instead of delaying the call until the sync is actually heard. This is automatically applied with decoding channels, as they can not be played/heard.</description></item>
            </list>
            </param>
            <param name="param">The sync parameters, depends on the sync type... see the table below.</param>
            <param name="proc">The callback function which should be invoked with the sync.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then the new synchronizer's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Sync types, with param and <see cref="T:Un4seen.Bass.SYNCPROC"/> data definitions:
            <list type="table">
            <item><term>BASS_SYNC_DEV_FAIL<para><i>(mixtime only)</i></para></term><description>Sync when the channel's device stops unexpectedly (eg. if it is disconnected/disabled). When this happens, it will not be possible to resume a recording but it may be possible to resume playback via <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> once the device becomes available again.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_DEV_FORMAT<para><i>(mixtime only)</i></para></term><description>Sync when the sample format (sample rate and/or channel count) of the channel's device changes. The new format is available from <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/>.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_DOWNLOAD<para><i>(mixtime only)</i></para></term><description>Sync when downloading of an internet (or "buffered" user file) stream is done.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_END</term><description>Sync when a channel reaches the end. Note that some MOD musics never reach the end, they may jump to another position first. If the BASS_MUSIC_STOPBACK flag is used with a MOD music (through <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>), then this sync will also be called when a backward jump effect is played.
            <para>param : not used.</para>
            <para>data : 1 = the sync is triggered by a backward jump in a MOD music, otherwise not used</para>
            </description></item>
            <item><term>BASS_SYNC_FREE<para><i>(mixtime only)</i></para></term><description>Sync when a channel is freed. This can be useful when you need to release some resources associated with the channel. Note that you will not be able to use any BASS functions with the channel in the callback (the channel will no longer exist).
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_META<para><i>(mixtime only)</i></para></term><description>Sync when metadata is received in a Shoutcast stream. This sync is also triggered when a new logical-bitstream begins in a chained OGG stream (multiple streams are strung one-after-another), in which case the metadata is the updated OGG tags. (see example below)
            <para>param : not used.</para>
            <para>data : not used - the updated metadata is available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_META)</para>
            </description></item>
            <item><term>BASS_SYNC_MUSICFX</term><description>Sync when the sync effect is used in a MOD music. The sync effect is E8x or Wxx for the XM/MTM/MOD formats, and S2x for the IT/S3M formats (where x = any value).
            <para>param : 0 = the position is passed to the callback (data : LOWORD = order, HIWORD = row),</para>
            <para>param : 1 = the value of x is passed to the callback (data : x value).</para>
            </description></item>
            <item><term>BASS_SYNC_MUSICINST</term><description>Sync when an instrument (sample for the MOD/S3M/MTM formats) is played in a MOD music (not including retrigs).
            <para>param : LOWORD = instrument (1=first), HIWORD = note (0=c0...119=b9, -1=all).</para>
            <para>data : LOWORD = note, HIWORD = volume (0-64).</para>
            </description></item>
            <item><term>BASS_SYNC_MUSICPOS</term><description>Sync when a MOD music reaches an order:row position.
            <para>param : LOWORD = order (0=first, -1=all), HIWORD = row (0=first, -1=all).</para>
            <para>data : LOWORD = order, HIWORD = row.</para>
            </description></item>
            <item><term>BASS_SYNC_OGG_CHANGE</term><description>Sync when a new logical bitstream begins in a chained OGG stream. Updated tags are available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_POS</term><description>Sync when a channel reaches a position.
            <para>param : position in bytes (automatically rounded down to nearest sample).</para>
            <para>data : not used.</para>
            </description></item>
            <item><term>BASS_SYNC_SETPOS</term><description>Sync when a channel's position is set, including when looping/restarting.
            <para>param : not used.</para>
            <para>data : 0 = playback buffer is not flushed, 1 = playback buffer is flushed.</para>
            </description></item>
            <item><term>BASS_SYNC_SLIDE<para><i>(mixtime only)</i></para></term><description>Sync when an attribute slide has completed.
            <para>param : not used.</para>
            <para>data : the type of slide completed (one of the BASS_SLIDE_xxx values).</para>
            </description></item>
            <item><term>BASS_SYNC_STALL<para><i>(mixtime only)</i></para></term><description>Sync when playback of the channel is stalled/resumed.
            <para>param : not used.</para>
            <para>data : 0 = stalled, 1 = resumed.</para>
            </description></item>
            </list>
            <i>Other sync types may be supported by add-ons, see the documentation.</i>
            <para> </para>
            <para>Multiple synchronizers may be used per channel, and they can be set before and while playing. Equally, synchronizers can also be removed at any time, using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveSync(System.Int32,System.Int32)"/>. If the BASS_SYNC_ONETIME flag is used, then the sync is automatically removed after its first occurrence.</para>
            <para>The BASS_SYNC_MIXTIME flag can be used with BASS_SYNC_END or BASS_SYNC_POS/MUSICPOS syncs to implement custom looping, by using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> in the callback.
            A MIXTIME sync can also be used to add or remove DSP/FX at specific points, or change a HMUSIC channel's flags or attributes (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>).
            The BASS_SYNC_MIXTIME flag can also be useful with a BASS_SYNC_SETPOS sync, to reset DSP states after seeking.</para>
            <para>Several of the sync types are triggered in the process of rendering the channel's sample data; for example, BASS_SYNC_POS and BASS_SYNC_END syncs, when the rendering reaches the sync position or the end, respectively. Those sync types should be set before starting playback or pre-buffering (ie. before any rendering), to avoid missing any early sync events.</para>
            <para>With recording channels, BASS_SYNC_POS syncs are triggered just before the <see cref="T:Un4seen.Bass.RECORDPROC"/> receives the block of data containing the sync position.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal <paramref name="param"/> was specified.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set a sync to get notified when the channel reaches the end:
            <code>
            private SYNCPROC _mySync;
            ...
            _mySync = new SYNCPROC(EndSync);
            Bass.BASS_ChannelSetSync(_stream, BASSSync.BASS_SYNC_END | BASSSync.BASS_SYNC_MIXTIME, 
                                     0, _mySync, IntPtr.Zero);
            ...
            private void EndSync(int handle, int channel, int data, IntPtr user)
            {
              // the 'channel' has ended - jump to the beginning
              Bass.BASS_ChannelSetPosition(channel, 0L);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            ...
            _mySync = New SYNCPROC(AddressOf EndSync)
            Bass.BASS_ChannelSetSync(_stream, BASSSync.BASS_SYNC_END Or BASSSync.BASS_SYNC_MIXTIME, 
                                     0, _mySync, IntPtr.Zero)
            ...
            Private Sub EndSync(ByVal handle As Integer, ByVal channel As Integer, 
                                ByVal data As Integer, ByVal user As IntPtr)
              ' the 'channel' has ended - jump to the beginning
              Bass.BASS_ChannelSetPosition(channel, 0L)
            End Sub
            </code>
            Process metadata received from an internet stream:
            <code>
            private SYNCPROC _mySync;
            ...
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, null, 0);
            // set a sync to get notified on stream title updates
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered
              string[] tags = Bass.BASS_ChannelGetTagsMETA(channel);
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            ...
            Dim stream As Integer =  Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, Nothing, 0) 
            ' set a sync to get notified on stream title updates
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MetaSync(ByVal handle As Integer, ByVal channel As Integer, 
                                 ByVal data As Integer, ByVal user As IntPtr)
              ' BASS_SYNC_META is triggered
              Dim tags() As String = Bass.BASS_ChannelGetTagsMETA(channel) 
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)">
            <summary>
            Sets an effect on a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="type">One of the following types of effect (see <see cref="T:Un4seen.Bass.BASSFXType"/>):
            <list type="table">
            <item><term>BASS_FX_DX8_CHORUS</term><description>DX8 Chorus. Use <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_COMPRESSOR</term><description>DX8 Compression. Use <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_DISTORTION</term><description>DX8 Distortion. Use <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_ECHO</term><description>DX8 Echo. Use <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_FLANGER</term><description>DX8 Flanger. Use <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_GARGLE</term><description>DX8 Gargle. Use <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_I3DL2REVERB</term><description>DX8 I3DL2 (Interactive 3D Audio Level 2) reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_PARAMEQ</term><description>DX8 Parametric equalizer. Use <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_DX8_REVERB</term><description>DX8 Reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_VOLUME</term><description>Volume level adjustment. Use <see cref="T:Un4seen.Bass.BASS_FX_VOLUME_PARAM"/> structure to set/get parameters.</description></item>
            </list>
            <i>Other effects may be supported by add-ons, e.g. <see cref="N:Un4seen.Bass.AddOn.Fx">BASS_FX</see>:</i>
            <list type="table">
            <item><term>BASS_FX_BFX_MIX</term><description>BASS_FX Channel Swap/Remap/Downmix. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_ROTATE</term><description>BASS_FX Channel Rotate. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_VOLUME</term><description>BASS_FX Volume. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_PEAKEQ</term><description>BASS_FX Peaking Equalizer. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_DAMP</term><description>BASS_FX Dynamic Amplification. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_AUTOWAH</term><description>BASS_FX Auto Wah. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_PHASER</term><description>BASS_FX Phaser. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_ECHO4</term><description>BASS_FX Echo 3. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_CHORUS</term><description>BASS_FX Chorus. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_BQF</term><description>BASS_FX BiQuad Filter. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_DISTORTION</term><description>BASS_FX Distortion. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_COMPRESSOR2</term><description>BASS_FX Compressor. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2"/> structure to set/get parameters.</description></item>
            <item><term>BASS_FX_BFX_VOLUME_ENV</term><description>BASS_FX volume envelope effect. Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV"/> structure to set/get parameters.</description></item>
            </list>
            </param>
            <param name="priority">The priority of the new FX, which determines it's position in the DSP chain - DSP/FX with higher priority are applied before those with lower. This parameter has no effect with DX8 effects when the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> is used.</param>
            <returns>If succesful, then the new effect's handle is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Multiple effects may be used per channel. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)"/> to remove an effect. Use <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to set an effect's parameters.</para>
            <para>Effects can be applied to MOD musics and streams, but not samples. If you want to apply an effect to a sample, you could use a stream instead.</para>
            <para>Depending on the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> being used by the channel, the channel may have to be stopped before adding or removing DX8 effects on it. 
            If necessary, that is done automatically and the channel is resumed afterwards.</para>
            <para><b>Platform-specific</b></para>
            <para>DX8 effects are a Windows feature requiring DirectX 8, or DirectX 9 for floating-point support. On other platforms, they are emulated by BASS, except for the following which are currently unsupported: COMPRESSOR, GARGLE, and I3DL2REVERB.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description>An illegal <paramref name="type"/> was specified.</description></item>
            <item><term>BASS_ERROR_NOFX</term><description>DX8 effects are unavailable.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The channel's format is not supported by the effect. It may be floating-point (without DX9) or more than stereo.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>DX8 effects are a Windows feature requiring DirectX 8, or DirectX 9 for floating-point support. On other platforms, they are emulated by BASS, except for the following which are currently unsupported: COMPRESSOR, GARGLE, and I3DL2REVERB. On Windows CE, only PARAMEQ is supported.</para>
            </remarks>
            <example>
            <code>
            BASS_DX8_ECHO echo = new BASS_DX8_ECHO(90f, 50f, 500f, 500f, true);
            int channel = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            int fxEchoHandle = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_ECHO, 1);
            ...
            // changing the echo effect, dry/wet mix...
            echo.fWetDryMix = 50f;
            Bass.BASS_FXSetParameters(fxEchoHandle, echo);
            </code>
            <code lang="vbnet">
            Dim echo As New BASS_DX8_ECHO(90F, 50F, 500F, 500F, True)
            Dim channel As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim fxEchoHandle As Integer = Bass.BASS_ChannelSetFX(channel, BASSFXType.BASS_FX_ECHO, 1)
            ...
            ' changing the echo effect, dry/wet mix...
            echo.fWetDryMix = 50F
            Bass.BASS_FXSetParameters(fxEchoHandle, echo)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetDevice(System.Int32)">
            <summary>
            Retrieves the device that the channel is using.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD. HSAMPLE handles may also be used.</param>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Recording devices are indicated by the HIWORD of the return value being 1, when this function is called with a HRECORD channel.
            <para>The return value may be BASS_NODEVICE (0x20000), if the channel is not associated with a device.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>Check, if a device number is a recording device:
            <code>
            bool isRecordingDevice = false;
            int device = Bass.BASS_ChannelGetDevice(stream);
            if (device != -1 &amp;&amp; Utils.HighWord(device) == 1)
              isRecordingDevice = true;
            </code>
            <code lang="vbnet">
            Dim isRecordingDevice As Boolean = False
            Dim device As Integer = Bass.BASS_ChannelGetDevice(stream)
            If device &lt;&gt; - 1 AndAlso Utils.HighWord(device) = 1 Then
              isRecordingDevice = True
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetDevice(System.Int32,System.Int32)">
            <summary>
            Changes the device that a stream, MOD music or sample is using.
            </summary>
            <param name="handle">The channel or sample handle... only HMUSIC, HSTREAM or HSAMPLE are supported.</param>
            <param name="device">The device to use...0 = no sound, 1 = first real output device, BASS_NODEVICE (0x20000) = no device.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>All of the channel's current settings are carried over to the new device, but if the channel is using the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a>, 
            the internal state (eg. buffers) of the DX8 effects will be reset. Using the "without FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a>, the state of the DX8 effects is preserved.
            <para>When changing a sample's device, all the sample's existing channels (HCHANNELs) are freed. It's not possible to change the device of an individual sample channel.</para>
            <para>The BASS_NODEVICE (0x20000) option can be used to disassociate a decoding channel from a device, so that it does not get freed when <see cref="M:Un4seen.Bass.Bass.BASS_Free"/> is called.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The requested device has not been initialized.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The channel is already using the requested device.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Only decoding channels are allowed to use the "no sound" device.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The sample format is not supported by the device/drivers. If the channel is more than stereo or the BASS_SAMPLE_FLOAT flag is used, it could be that they are not supported.</description></item>
            <item><term>BASS_ERROR_MEM</term><description>There is insufficient memory.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            // now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            // now device 2 is the current one
            ...
            // create the stream on device 1
            Bass.BASS_SetDevice(1);
            // now device 1 is the current one
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            // move the channel to device 2
            Bass.BASS_ChannelSetDevice(stream, 2);
            </code>
            <code lang="vbnet">
            ' init device 1 and 2
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            ' now device 1 is the current one
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            ' now device 2 is the current one
            ' create the stream on device 1
            Bass.BASS_SetDevice(1)
            ' now device 1 is the current one
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            ' move the channel to device 2
            Bass.BASS_ChannelSetDevice(stream, 2)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)">
            <summary>
            Stops a sample, stream, MOD music, or recording.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Stopping a user stream (created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>) will clear its buffer contents, and stopping a sample channel (HCHANNEL) will result in it being freed.
            Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/> instead if you wish to stop a user stream and then resume it from the same point.</para>
            <para>When used with a "decoding channel" (BASS_STREAM_DECODE or BASS_MUSIC_DECODE was used at creation), this function will end the channel at its current position, 
            so that it's not possible to decode any more data from it. Any BASS_SYNC_END syncs that have been set on the channel will not be triggered by this, they are only triggered when reaching the natural end. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be used to reset the channel and start decoding again.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)">
            <summary>
            Pauses a sample, stream, MOD music, or recording.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL / HMUSIC / HSTREAM / HRECORD handle.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> to resume a paused channel. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> can be used to stop a paused channel.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOPLAY</term><description>The channel is not playing (or <paramref name="handle"/> is not a valid channel).</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>The channel is not playable, it's a "decoding channel".</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The channel is already paused.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)">
            <summary>
            Sets the value of an attribute of a sample, stream or MOD music.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="attrib">The attribute to set the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_FREQ</term><description>The sample rate, 100 (min) to 100000 (max), 0 = original rate (when the channel was created).</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>The panning/balance position, -1 (full left) to +1 (full right), 0 = centre.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>The volume level, 0 (silent) to 1 (full) or above.</description></item>
            <item><term>BASS_ATTRIB_SRC</term><description>Sample rate conversion quality.</description></item>
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix, 0 (full dry) to 1 (full wet), -1 = automatically calculate the mix based on the distance (the default).</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>The amplification level, 0 (min) to 100 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>The BPM, 1 (min) to 255 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>The Pan separation level, 0 (min) to 100 (max), 50 = linear rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>The Position scaler, 1 (min) to 256 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>The Speed, 0 (min) to 255 (max) rounded down to a whole number. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level, 0 (silent) to 1 (full). (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level, 0 (min) to 64 (max, 128 for IT format) rounded down to a whole number. (HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, e.g. <see cref="N:Un4seen.Bass.AddOn.Fx">BASS_FX</see>:</i>
            <list type="table">
            <item><term>BASS_ATTRIB_TEMPO</term><description>The tempo of a channel, [-95%...0...+5000%] percents.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_PITCH</term><description>The pitch of a channel, [-60...0...+60] semitones.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_FREQ</term><description>The sample rate of a channel in Hz, but calculates by the same % as BASS_ATTRIB_TEMPO.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER</term><description>Use the AA Filter for a tempo channel (<see langword="true"/>=1, <see langword="false"/>=0).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH</term><description>Sets the AA Filter length in taps (between 8 and 128).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</term><description>Use the tempo quick algorithm for a tempo channel (<see langword="true"/>=1, <see langword="false"/>=0).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS</term><description>Sets the tempo sequence in ms. of a tempo channel (default = 82).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS</term><description>Sets the tempo seek window in ms. of a tempo channel (default = 82).</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS</term><description>Sets the tempo overlap in ms. of a tempo channel (default = 12).</description></item>
            <item><term>BASS_ATTRIB_REVERSE_DIR</term><description>Sets the playback direction of a reverse channel (-1=reverse, 1=forward, or use one of the <see cref="T:Un4seen.Bass.AddOn.Fx.BASSFXReverse"/> flags).</description></item>
            </list>
            </param>
            <param name="value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            The actual attribute value may not be exactly the same as requested, due to precision differences. For example, an attribute might only allow whole number values. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/> can be used to confirm what the value is.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="value"/> is not valid. See the attribute's documentation for the valid range of values.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation</i>
            </para>
            </remarks>
            <example>Change the volume of a channel to 50%:
            <code>
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            Bass.BASS_ChannelSetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, 0.5f);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Bass.BASS_ChannelSetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, 0.5F)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.IntPtr,System.Int32)">
            <summary>
            Sets the value of a channel's attribute.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="attrib">The attribute to set the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_SCANINFO</term><description>Scanned info. (HSTREAM only).</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <param name="value">The pointer to the new attribute data.</param>
            <param name="size">The size of the attribute data.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="value"/> content or <paramref name="size"/> is not valid.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation</i>
            </para>
            </remarks>
            <example>Transfer scanned info from one stream to another stream of the same file:
            <code>
            // get the size
            int size = Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, IntPtr.Zero, 0);
            IntPtr hglobal = Marshal.AllocHGlobal(size);
            // get the data
            Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size);
            // apply it to the other stream
            Bass.BASS_ChannelSetAttribute(stream2, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size);
            Marshal.FreeHGlobal(hglobal);
            </code>
            <code lang="vbnet">
            ' get the size
            Dim size As Integer = Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, IntPtr.Zero, 0)
            Dim hglobal As IntPtr = Marshal.AllocHGlobal(size)
            ' get the data
            Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size)
            ' apply it to the other stream
            Bass.BASS_ChannelSetAttribute(stream2, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size)
            Marshal.FreeHGlobal(hglobal)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)">
            <summary>
            Retrieves the value of an attribute of a sample, stream or MOD music. Can also get the sample rate of a recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="attrib">The attribute to set the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix.</description></item>
            <item><term>BASS_ATTRIB_CPU</term><description>CPU usage. (HMUSIC/HSTREAM)</description></item>
            <item><term>BASS_ATTRIB_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_ATTRIB_MUSIC_ACTIVE</term><description>Active channel count. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>Amplification level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>BPM. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>Pan separation level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>Position scaler. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>Speed. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_NOBUFFER</term><description>Non-Windows only: Playback buffering switch. (HMUSIC/HSTREAM)</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>Panning/balance position.</description></item>
            <item><term>BASS_ATTRIB_SRC</term><description>Sample rate conversion quality.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>Volume level.</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, e.g. <see cref="N:Un4seen.Bass.AddOn.Fx">BASS_FX</see>:</i>
            <list type="table">
            <item><term>BASS_ATTRIB_TEMPO</term><description>The tempo of a channel in percent.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_PITCH</term><description>The pitch of a channel in semitones.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_FREQ</term><description>The sample rate of a channel in Hz.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER</term><description>AA Filter used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH</term><description>The AA Filter length in taps.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO</term><description>Tempo quick algorithm used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS</term><description>The tempo sequence in ms. used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS</term><description>The tempo seek window in ms. used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS</term><description>The tempo overlap in ms. used on a tempo channel.</description></item>
            <item><term>BASS_ATTRIB_REVERSE_DIR</term><description>The current playback direction of a reverse stream.</description></item>
            </list>
            </param>
            <param name="value">Pointer to a variable to receive the attribute value.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation</i>
            </para>
            </remarks>
            <example>Get the current volume of a channel:
            <code>
            float vol = 0f;
            if (Bass.BASS_ChannelGetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, ref vol))
              Console.WriteLine("Volume={0}", vol);
            </code>
            <code lang="vbnet">
            Dim vol As Single = 0F
            If Bass.BASS_ChannelGetAttribute(stream, BASSAttribute.BASS_ATTRIB_VOL, vol) Then
              Console.WriteLine("Volume={0}", vol)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.IntPtr,System.Int32)">
            <summary>
            Retrieves the value of a channel's attribute. 
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM  or HRECORD.</param>
            <param name="attrib">The attribute to get the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_SCANINFO</term><description>Scanned info. (HSTREAM only).</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <param name="value">Pointer to a buffer to receive the attribute data.</param>
            <param name="size">The size of the attribute data... 0 = get the size of the attribute without getting the data.</param>
            <returns>If successful, the size of the attribute data is returned, else 0 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function also supports the floating-point attributes supported by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The <paramref name="attrib"/> is not available.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="value"/> content or <paramref name="size"/> is not valid.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation</i>
            </para>
            </remarks>
            <example>Transfer scanned info from one stream to another stream of the same file:
            <code>
            // get the size
            int size = Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, IntPtr.Zero, 0);
            IntPtr hglobal = Marshal.AllocHGlobal(size);
            // get the data
            Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size);
            // apply it to the other stream
            Bass.BASS_ChannelSetAttribute(stream2, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size);
            Marshal.FreeHGlobal(hglobal);
            </code>
            <code lang="vbnet">
            ' get the size
            Dim size As Integer = Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, IntPtr.Zero, 0)
            Dim hglobal As IntPtr = Marshal.AllocHGlobal(size)
            ' get the data
            Bass.BASS_ChannelGetAttribute(stream1, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size)
            ' apply it to the other stream
            Bass.BASS_ChannelSetAttribute(stream2, BASSAttribute.BASS_ATTRIB_SCANINFO, scaninfo, size)
            Marshal.FreeHGlobal(hglobal)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)">
            <summary>
            Modifies and retrieves a channel's flags.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="flags">A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_LOOP</term><description>Loop the channel.</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>Automatically free the channel when playback ends. Note that the BASS_MUSIC_AUTOFREE flag is identical to this flag. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>Restrict the download rate. (HSTREAM)</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>Use "normal" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>Use "sensitive" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>Use surround sound. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>Use surround sound mode 2. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>Use non-interpolated mixing. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SINCINTER</term><description>Use sinc interpolated sample mixing. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>Use FastTracker 2 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>Use ProTracker 1 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Stop all notes when seeking. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Stop all notes and reset BPM/etc when seeking. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>Stop when a backward jump effect is played. (HMUSIC)</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a href="../Overview.html#SpeakerAssignement">Speaker assignment</a> flags. (HSTREAM/HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <param name="mask">The flags (as above) to modify. Flags that are not included in this are left as they are, so it can be set to 0 in order to just retrieve the current flags. To modify the speaker flags, any of the BASS_SPEAKER_xxx flags can be used in the mask (no need to include all of them).</param>
            <returns>If successful, the channel's updated flags are returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Some flags may not be adjustable in some circumstances, so the return value should be checked to confirm any changes. 
            The flags listed above are just the flags that can be modified, and there may be additional flags present in the return value. 
            See the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> documentation for a full list of flags.</para>
            <para>Streams that are created by add-ons may have additional flags available. There is a limited number of possible flag values though, so some add-ons may use the same flag value for different things. 
            This means that when using add-on specific flags with a stream created via the plugin system, it is a good idea to first confirm that the add-on is handling the stream, by checking its ctype via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>.</para>
            <para>During playback, the effects of flag changes are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Toggle looping on a channel:
            <code>
            if ((Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_DEFAULT) &amp; BASSFlag.BASS_SAMPLE_LOOP) == BASSFlag.BASS_SAMPLE_LOOP)
            {
              // loop flag was set, so remove it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_SAMPLE_LOOP);
            }
            else
            {
              // loop flag was not set, so set it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_SAMPLE_LOOP, BASSFlag.BASS_SAMPLE_LOOP);
            }
            </code>
            <code lang="vbnet">
            If (Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_DEFAULT) And BASSFlag.BASS_SAMPLE_LOOP) = BASSFlag.BASS_SAMPLE_LOOP Then
              ' loop flag was set, so remove it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_DEFAULT, BASSFlag.BASS_SAMPLE_LOOP)
            Else
              ' loop flag was not set, so set it
              Bass.BASS_ChannelFlags(channel, BASSFlag.BASS_SAMPLE_LOOP, BASSFlag.BASS_SAMPLE_LOOP)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)">
            <summary>
            Updates the playback buffer of a stream or MOD music.
            </summary>
            <param name="handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="length">The amount to render, in milliseconds... 0 = default (2 x <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/>). This is capped at the space available in the buffer.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When starting playback of a stream or MOD music, after creating it or changing its position, there will be a slight delay while the initial data is decoded for playback. 
            Usually the delay is not noticeable or important, but if you need playback to start instantly when you call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>, then use this function first. 
            The length parameter should be at least equal to the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/>.</para>
            <para>It may not always be possible to render the requested amount of data, in which case this function will still succeed. 
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check how much data a channel has buffered for playback.</para>
            <para>When automatic updating is disabled (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/> = 0 or <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATETHREADS"/> = 0), this function could be used instead of <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> to implement different update periods for different channels, 
            instead of a single update period for all. Unlike <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/>, this function can also be used while automatic updating is enabled.</para>
            <para>The CPU usage of this function is not included in the <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/> reading.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Decoding channels do not have playback buffers.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The channel has ended.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>Pre-buffer to enable instant playback:
            <code>
            int stream = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_STREAM_PRESCAN);
            // pre-buffer
            Bass.BASS_ChannelUpdate(stream, 0);
            // start playback
            Bass.BASS_ChannelPlay(stream, false);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("afile.mp3", 0, 0, BASSFlag.BASS_STREAM_PRESCAN)
            ' pre-buffer
            Bass.BASS_ChannelUpdate(stream, 0)
            ' start playback
            Bass.BASS_ChannelPlay(stream, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelIsSliding(System.Int32,Un4seen.Bass.BASSAttribute)">
            <summary>
            Checks if an attribute (or any attribute) of a sample, stream, or MOD music is sliding.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM or HRECORD.</param>
            <param name="attrib">The attribute to check for sliding (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/> or 0 for any attribute):
            <list type="table">
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix.</description></item>
            <item><term>BASS_ATTRIB_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>Panning/balance position.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>Volume level.</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>Amplification level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>BPM. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>Pan separation level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>Position scaler. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>Speed. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level. (HMUSIC)</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <returns>If the attribute (or any) is sliding, then <see langword="true"/> is returned, else <see langword="false"/> is returned.</returns>
            <example>
            Wait until a volume slideing has finished:
            <code>
            while (Bass.BASS_ChannelIsSliding(channel, BASSAttribute.BASS_ATTRIB_VOL))
            {
              Thread.Sleep(20); // wait 20ms
            }
            </code>
            <code lang="vbnet">
            While Bass.BASS_ChannelIsSliding(channel, BASSAttribute.BASS_ATTRIB_VOL)
              Thread.Sleep(20) ' wait 20ms
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)">
            <summary>
            Slides a channel's attribute from its current value to a new value.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HSTREAM or HMUSIC, or HRECORD.</param>
            <param name="attrib">The attribute to slide the value of (one of the following, see <see cref="T:Un4seen.Bass.BASSAttribute"/>):
            <list type="table">
            <item><term>BASS_ATTRIB_FREQ</term><description>Sample rate.</description></item>
            <item><term>BASS_ATTRIB_PAN</term><description>Panning/balance position.</description></item>
            <item><term>BASS_ATTRIB_VOL</term><description>Volume level.</description></item>
            <item><term>BASS_ATTRIB_EAXMIX</term><description>EAX wet/dry mix.</description></item>
            <item><term>BASS_ATTRIB_MUSIC_AMPLIFY</term><description>Amplification level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_BPM</term><description>BPM. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PANSEP</term><description>Pan separation level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_PSCALER</term><description>Position scaler. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_SPEED</term><description>Speed. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_CHAN</term><description>A channel volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_GLOBAL</term><description>Global volume level. (HMUSIC)</description></item>
            <item><term>BASS_ATTRIB_MUSIC_VOL_INST</term><description>An instrument/sample volume level. (HMUSIC)</description></item>
            <item><term>BASS_SLIDE_LOG</term><description>Flag: Slide the attribute's value logarthmically rather than linearly. This cannot be used when going from positive to negative or vice versa. An exception is when using a negative value with BASS_ATTRIB_VOL to fade-out and stop.</description></item>
            </list>
            <i>Other attributes may be supported by add-ons, see the documentation</i>
            </param>
            <param name="value">The new attribute value. See the attribute's documentation for details on the possible values.</param>
            <param name="time">The length of time (in milliseconds) that it should take for the attribute to reach the <paramref name="value"/>.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function is similar to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, except that the attribute is ramped to the value over the specified period of time. 
            Another difference is that the value is not pre-checked. If it is invalid, the slide will simply end early.</para>
            <para>If an attribute is already sliding, then the old slide is stopped and replaced by the new one.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsSliding(System.Int32,Un4seen.Bass.BASSAttribute)"/> can be used to check if an attribute is currently sliding. A BASS_SYNC_SLIDE sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered at the end of a slide. 
            The sync will not be triggered in the case of an existing slide being replaced by a new one.</para>
            <para>Attribute slides are unaffected by whether the channel is playing, paused or stopped. They carry on regardless.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ILLTYPE</term><description><paramref name="attrib"/> is not valid.</description></item>
            </list>
            <i>Some attributes may have additional error codes, see the documentation.</i>
            </para>
            </remarks>
            <example>
            Fadeout a channel's volume over a period of 1 second:
            <code>
            Bass.BASS_ChannelSlideAttribute(channel, BASSAttribute.BASS_ATTRIB_VOL, 0f, 1000);
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSlideAttribute(channel, BASSAttribute.BASS_ATTRIB_VOL, 0F, 1000)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="mode">The 3D processing mode... one of these flags, -1 = leave current (see <see cref="T:Un4seen.Bass.BASS3DMode"/>):
            <list type="table">
            <item><term>BASS_3DMODE_NORMAL</term><description>Normal 3D processing.</description></item>
            <item><term>BASS_3DMODE_RELATIVE</term><description>The channel's 3D position (position/velocity/orientation) is relative to the listener. When the listener's position/velocity/orientation is changed with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, the channel's position relative to the listener does not change.</description></item>
            <item><term>BASS_3DMODE_OFF</term><description>Turn off 3D processing on the channel, the sound will be played in the centre.</description></item>
            </list>
            </param>
            <param name="min">The minimum distance. The channel's volume is at maximum when the listener is within this distance... less than 0.0 = leave current.</param>
            <param name="max">The maximum distance. The channel's volume stops decreasing when the listener is beyond this distance... less than 0.0 = leave current.</param>
            <param name="iangle">The angle of the inside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="oangle">The angle of the outside projection cone in degrees... 0 (no cone) - 360 (sphere), -1 = leave current.</param>
            <param name="outvol">The delta-volume outside the outer projection cone... 0 (silent) - 100 (same as inside the cone), -1 = leave current.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The iangle and oangle parameters must both be set in a single call to this function (ie. you can't set one without the other). 
            The iangle and oangle angles decide how wide the sound is projected around the orientation angle. Within the inside angle the volume level is the channel volume, as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>. 
            Outside the outer angle, the volume changes according to the outvol value. Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels. 
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.</para>
            <para>As with all 3D functions, use <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes made.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the attribute values is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode@,System.Single@,System.Single@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieves the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="mode">The 3D processing mode (see <see cref="T:Un4seen.Bass.BASS3DMode"/>).</param>
            <param name="min">The minimum distance.</param>
            <param name="max">The maximum distance.</param>
            <param name="iangle">The angle of the inside projection cone.</param>
            <param name="oangle">The angle of the outside projection cone.</param>
            <param name="outvol">The delta-volume outside the outer projection cone.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The iangle and oangle parameters must both be retrieved in a single call to this function (ie. you can't retrieve one without the other). See <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> for an explanation of the parameters.
            <para>This overload uses reference types, so you need to specify all parameters here and therefore can only get the parameters all together. See the other overloads which allows you to retrieve only certain values.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS3DMode mode = BASS3DMode.BASS_3DMODE_NORMAL;
            float min = 0f;
            float max = 0f;
            int iangle = 0;
            int oangle = 0;
            int outvol = 0;
            bool ok = Bass.BASS_ChannelGet3DAttributes(handle, ref mode, ref min, ref max, ref iangle, ref oangle, ref outvol);
            </code>
            <code lang="vbnet">
            Dim mode As BASS3DMode = BASS3DMode.BASS_3DMODE_NORMAL
            Dim min As Single = 0F
            Dim max As Single = 0F
            Dim iangle As Integer = 0
            Dim oangle As Integer = 0
            Dim outvol As Integer = 0
            Dim ok As Boolean = Bass.BASS_ChannelGet3DAttributes(handle, mode, min, max, iangle, oangle, outvol)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGet3DAttributes(System.Int32,System.Object,System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Retrieves the 3D attributes of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="mode">The 3D processing mode (see <see cref="T:Un4seen.Bass.BASS3DMode"/>)... <see langword="null"/> = don't retrieve it. (int)</param>
            <param name="min">The minimum distance... <see langword="null"/> = don't retrieve it. (float)</param>
            <param name="max">The maximum distance... <see langword="null"/> = don't retrieve it. (float)</param>
            <param name="iangle">The angle of the inside projection cone... <see langword="null"/> = don't retrieve it. (int)</param>
            <param name="oangle">The angle of the outside projection cone... <see langword="null"/> = don't retrieve it. (int)</param>
            <param name="outvol">The delta-volume outside the outer projection cone... <see langword="null"/> = don't retrieve it. (int)</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>The iangle and oangle parameters must both be retrieved in a single call to this function (ie. you can't retrieve one without the other). See <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> for an explanation of the parameters.
            <para>This overload uses native object, so you can specify <see langword="null"/> for some or all parameters in order to not retrieve them. However, the return values of these parameters must be casted back to it's original type.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Only get the delta-volume outside the outer projection cone:
            <code>
            object outvol = 0;
            bool ok = Bass.BASS_ChannelGet3DAttributes(handle, null, null, null, null, null, outvol);
            // cast the outvol back it it's normal value type (int)
            int deltaVol = (int)outvol;
            </code>
            <code lang="vbnet">
            Dim outvol As BASobject = 0
            Dim ok As Boolean = Bass.BASS_ChannelGet3DAttributes(handle, Nothing, Nothing, Nothing, Nothing, Nothing, outvol)
            ' cast the outvol back it it's normal value type (int)
            Dim deltaVol As Integer = CInt(outvol)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Sets the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="pos">Position of the sound... <see langword="null"/> = leave current.</param>
            <param name="orient">Orientation of the sound... <see langword="null"/> = leave current.</param>
            <param name="vel">Velocity of the sound... <see langword="null"/> = leave current. This is only used to calculate the doppler effect, and has no effect on the sound's position.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>As with all 3D functions, <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> must be called to apply the changes made.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)">
            <summary>
            Retrieves the 3D position of a sample, stream, or MOD music channel with 3D functionality.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM.</param>
            <param name="pos">Position of the sound... <see langword="null"/> = don't retrieve it.</param>
            <param name="orient">Orientation of the sound... <see langword="null"/> = don't retrieve it.</param>
            <param name="vel">Velocity of the sound... <see langword="null"/> = don't retrieve it.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NO3D</term><description>The channel does not have 3D functionality.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_3DVECTOR pos = new BASS_3DVECTOR();
            BASS_3DVECTOR orient = new BASS_3DVECTOR();
            BASS_3DVECTOR vel = new BASS_3DVECTOR();
            if (Bass.BASS_ChannelGet3DPosition(stream, pos, orient, vel))
            {
              Console.WriteLine("{0} : {1} : {2}", pos, orient, vel);
            }
            </code>
            <code lang="vbnet">
            Dim pos As New BASS_3DVECTOR()
            Dim orient As New BASS_3DVECTOR()
            Dim vel As New BASS_3DVECTOR()
            If Bass.BASS_ChannelGet3DPosition(stream, pos, orient, vel) Then
              Console.WriteLine("{0} : {1} : {2}", pos, orient, vel)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)">
            <summary>
            Sets the playback position of a sample, MOD music, or stream.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HSTREAM or HMUSIC.</param>
            <param name="pos">The position, in units determined by the <paramref name="mode"/>.</param>
            <param name="mode">How to set the position. One of the following (see <see cref="T:Un4seen.Bass.BASSMode"/>), with optional flags:
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>The position is in bytes, which will be rounded down to the nearest sample boundary.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>The position is in orders and rows... use <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/>. (HMUSIC only).</description></item>
            <item><term>BASS_POS_OGG</term><description>The position is a bitstream number in an OGG file... 0 = first.</description></item>
            <item><term>BASS_POS_DECODETO</term><description>Flag: Decode/render up to the position rather than seeking to it. This is useful for streams that are unseekable or that have inexact seeking, but it is generally slower than normal seeking and the requested position cannot be behind the current decoding position. This flag can only be used with the BASS_POS_BYTE mode.</description></item>
            <item><term>BASS_POS_INEXACT</term><description>Flag: Allow inexact seeking. For speed, seeking may stop at the beginning of a block rather than partially processing the block to reach the requested position.</description></item>
            <item><term>BASS_POS_RELATIVE</term><description>Flag: The requested position is relative to the current position. pos is treated as signed in this case and can be negative.</description></item>
            <item><term>BASS_POS_RESET</term><description>Flag: Reset user file buffers. This allows a user file stream with the BASS_STREAM_BLOCK flag set to be reset, so that it is ready to process new data. This flag can only be used with the BASS_POS_BYTE mode, and pos must be 0.</description></item>
            <item><term>BASS_POS_RELATIVE</term><description>Flag: Allow inexact seeking. For speed, seeking may stop at the beginning of a block rather than partially processing the block to reach the requested position.</description></item>
            <item><term>BASS_POS_RESET</term><description>Flag: Reset user file buffers. This allows a user file stream with the BASS_STREAM_BLOCK flag set to be reset, so that it is ready to process new data. This flag can only be used with the BASS_POS_BYTE mode, and pos must be 0.</description></item>
            <item><term>BASS_POS_SCAN</term><description>Flag: Scan the file to build a seek table up to the position, if it has not already been scanned. Scanning will continue from where it left off previously rather than restarting from the beginning of the file each time. This flag only applies to MP3/MP2/MP1 files and will be ignored with other file formats.</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>Flag: Stop all notes. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>Flag: Stop all notes and reset bpm/etc. This flag is applied automatically if it has been set on the channel, eg. via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>. (HMUSIC).</description></item>
            </list>
            <i>Other modes and flags may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Setting the position of a MOD music in bytes (other than 0) requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call. When setting the position in orders/rows, the channel's byte position (as reported by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>) is reset to 0. 
            This is because it's not possible to get the byte position of an order/row position - it's possible that a position may never be played in the normal cause of events, or it may be played multiple times.</para>
            <para>When changing the position of a MOD music, and the BASS_MUSIC_POSRESET flag is active on the channel, all notes that were playing before the position changed will be stopped. Otherwise, the notes will continue playing until they are stopped in the MOD music. 
            When setting the position in bytes, the BPM, "speed" and "global volume" are updated to what they would normally be at the new position. Otherwise they are left as they were prior to the postion change, unless the seek position is 0 (the start), in which case they are also reset to the starting values (when using the BASS_MUSIC_POSRESET flag). 
            When the BASS_MUSIC_POSRESETEX flag is active, the BPM, speed and global volume are reset with every seek.</para>
            <para>For MP3/MP2/MP1 streams, unless the file is scanned via the BASS_POS_SCAN flag or the BASS_STREAM_PRESCAN flag at stream creation, seeking will be approximate but generally still quite accurate. 
            Besides scanning, exact seeking can also be achieved with the BASS_POS_DECODETO flag.</para>
            <para>Seeking in internet file (and "buffered" user file) streams is possible once the download has reached the requested position, so long as the file is not being streamed in blocks (BASS_STREAM_BLOCK flag).</para>
            <para>The BASS_POS_RESET flag can be used to reset/flush a buffered user file stream, so that new data can be processed, but it may not be supported by some decoders. When it is not supported, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> can be used again instead to create a new stream for the new data.</para>
            <para>User streams (created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>) are not seekable, but it is possible to reset a user stream (including its buffer contents) by setting its position to byte 0.</para>
            <para>The BASS_POS_DECODETO flag can be used to seek forwards in streams that are not normally seekable, like custom streams or internet streams that are using the BASS_STREAM_BLOCK flag, but it will only go as far as what is currently available; it will not wait for more data to be downloaded, for example. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> can be used to confirm what the new position actually is.</para>
            <para>In some cases, particularly when the BASS_POS_INEXACT flag is used, the new position may not be what was requested. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> can be used to confirm what the new position actually is.</para>
            <para>The BASS_POS_SCAN flag works the same way as the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> BASS_STREAM_PRESCAN flag, and can be used to delay the scanning until after the stream has been created. When a position beyond the end is requested, the call will fail (BASS_ERROR_POSITION error code) but the seek table and exact length will have been scanned. 
            When a file has been scanned, all seeking (even without the BASS_POS_SCAN flag) within the scanned part of it will use the scanned infomation.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the position of a stream channel to 10sec. and 200ms:
            <code>
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20), BASSMode.BASS_POS_BYTE);
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20), BASSMode.BASS_POS_BYTE)
            </code>
            Set the position of a MOD music to row 20 of order 10:
            <code>
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(10,20), BASSMode.BASS_POS_MUSIC_ORDER );
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(10,20), BASSMode.BASS_POS_MUSIC_ORDER )
            </code>
            Start playback of a MOD music from the beginning of the last order:
            <code>
            // get number of orders
            int len = (int)Bass.BASS_ChannelGetLength(music, BASSMode.BASS_POS_MUSIC_ORDER);
            // seek to last order
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(len-1, 0), BASSMode.BASS_POS_MUSIC_ORDER);
            Bass.BASS_ChannelPlay(music, false); // play
            </code>
            <code lang="vbnet">
            ' get number of orders
            Dim len As Integer = CInt(Bass.BASS_ChannelGetLength(music, BASSMode.BASS_POS_MUSIC_ORDER))
            ' seek to last order
            Bass.BASS_ChannelSetPosition(music, Utils.MakeMusicPos(len-1, 0), BASSMode.BASS_POS_MUSIC_ORDER)
            Bass.BASS_ChannelPlay(music, False) ' play
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64)">
            <summary>
            Sets the playback position in bytes of a sample, MOD music, or stream.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HSTREAM or HMUSIC.</param>
            <param name="pos">The position, in bytes.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Setting the position of a MOD music in bytes requires that the BASS_MUSIC_PRESCAN flag was used in the <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> call. When setting the position in orders/rows, the channel's byte position (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>) is reset to 0. 
            This is because it's not possible to get the byte position of an order/row position - it's possible that a position may never be played in the normal cause of events, or it may be played multiple times.</para>
            <para>When changing the position of a MOD music, and the BASS_MUSIC_POSRESET flag is active on the channel, all notes that were playing before the position changed will be stopped. Otherwise, the notes will continue playing until they are stopped in the MOD music. 
            When setting the position in bytes, the BPM, "speed" and "global volume" are updated to what they would normally be at the new position. Otherwise they are left as they were prior to the postion change, unless the seek position is 0 (the start), in which case they are also reset to the starting values (when using the BASS_MUSIC_POSRESET flag). 
            When the BASS_MUSIC_POSRESETEX flag is active, the BPM, speed and global volume are reset with every seek.</para>
            <para>When setting the position of a file stream, the position is automatically rounded down to the nearest sample. For MP3/MP2/MP1 streams, if the BASS_STREAM_PRESCAN flag was used when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> was called to create the stream, then the seeking will be accurate to the exact requested byte. 
            Otherwise it will be an approximation, which is generally still very accurate.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.
            </para>
            <para>Seeking in internet file (and "buffered" user file) streams is possible once the download has reached the requested position, so long as the file is not being streamed in blocks (BASS_STREAM_BLOCK flag).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the position of a stream channel to 10sec. and 200ms:
            <code>
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20));
            </code>
            <code lang="vbnet">
            Bass.BASS_ChannelSetPosition(stream, Bass.BASS_ChannelSeconds2Bytes(stream, 10.20))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Double)">
            <summary>
            Sets the playback position of a sample or stream to the given seconds value.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL or HSTREAM.</param>
            <param name="seconds">The seconds value to set the position to (milliseconds are represented in the fraction part).</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This is just an overload which uses <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSeconds2Bytes(System.Int32,System.Double)"/> internally.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the playback position in order.row of a MOD music.
            </summary>
            <param name="handle">The channel handle... HMUSIC.</param>
            <param name="order">The order position.</param>
            <param name="row">The row position.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This is just an overload which uses <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)"/> internally.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTFILE</term><description>The stream is not a file stream.</description></item>
            <item><term>BASS_ERROR_POSITION</term><description>The requested position is invalid, eg. beyond the end.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The download has not yet reached the requested position.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)">
            <summary>
            Retrieves the playback position of a sample, stream, or MOD music. Can also be used with a recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="mode">How to retrieve the position. One of the following (see <see cref="T:Un4seen.Bass.BASSMode"/>):
            <list type="table">
            <item><term>BASS_POS_BYTE</term><description>Get the position in bytes.</description></item>
            <item><term>BASS_POS_MUSIC_ORDER</term><description>Get the position in orders and rows... LoWord = order, HiWord = row * scaler (<see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER"/>). (HMUSIC only).</description></item>
            <item><term>BASS_POS_DECODE</term><description>Flag: Get the decoding/rendering position, which may be ahead of the playback position due to buffering. This flag is unnecessary with decoding channels because the decoding position will always be given for them anyway, as they do not have playback buffers.</description></item>
            </list>
            <i>Other modes may be supported by add-ons, see the documentation.</i>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the position is returned.</returns>
            <remarks>With MOD music you might use the <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/> and <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/> methods to retrieve the order resp. the row values.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested position is not available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            long pos = Bass.BASS_ChannelGetPosition(stream, BASSMode.BASS_POS_BYTE);
            </code>
            <code lang="vbnet">
            Dim pos As Long = Bass.BASS_ChannelGetPosition(stream, BASSMode.BASS_POS_BYTE)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32)">
            <summary>
            Retrieves the playback position in bytes of a sample, stream, or MOD music. Can also be used with a recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. If successful, the position in bytes is returned.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            long pos = Bass.BASS_ChannelGetPosition(stream);
            </code>
            <code lang="vbnet">
            Dim pos As Long = Bass.BASS_ChannelGetPosition(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the level of the left channel is returned in the low word (low 16-bits, use <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/>), and the level of the right channel is returned in the high word (high 16-bits, use <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/>). If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.</para>
            </returns>
            <remarks>
            <para>This function measures the level of the channel's sample data, not the level of the channel in the final output mix, 
            so the channel's volume and panning/balance (as set with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>, BASS_ATTRIB_VOL or BASS_ATTRIB_PAN) does not affect it.
            The effect of any DSP/FX set on the channel is present in the measurement, except for DX8 effects when using the "With FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a>.</para>
            <para>For channels that are more than stereo, the left level will include all left channels (eg. front-left, rear-left, center), and the right will include all right (front-right, rear-right, LFE).
            If there are an odd number of channels then the left and right levels will include all channels. If the level of each individual channel is required, that is available from the other overload(s).</para>
            <para>20ms of data is inspected to calculate the level. When used with a decoding channel, that means 20ms of data needs to be decoded from the channel in order to calculate the level, and that data is then gone, eg. it is not available to a subsequent <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> call.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The channel is not playing.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The decoding channel has reached the end.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the left and right levels of a stereo channel:
            <code>
            int level = Bass.BASS_ChannelGetLevel(channel);
            int left = Utils.LowWord32(level); // the left level
            int right = Utils.HighWord32(level); // the right level
            </code>
            <code lang="vbnet">
            Dim level As Integer = Bass.BASS_ChannelGetLevel(channel)
            Dim left As Integer = Utils.LowWord32(level) ' the left level
            Dim right As Integer = Utils.HighWord32(level) ' the right level
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32,System.Single[],System.Single,Un4seen.Bass.BASSLevel)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="levels">The array in which the levels are to be returned.</param>
            <param name="length">How much data (in seconds) to look at to get the level (limited to 1 second).</param>
            <param name="flags">What levels to retrieve. One of the following (see <see cref="T:Un4seen.Bass.BASSLevel"/>):
            <list type="table">
            <item><term>BASS_LEVEL_ALL</term><description>Retrieves a separate level for each channel.</description></item>
            <item><term>BASS_LEVEL_MONO</term><description>Retrieve a single mono level.</description></item>
            <item><term>BASS_LEVEL_STEREO</term><description>Get a stereo level. The left level will be from the even channels, and the right level will be from the odd channels. If there are an odd number of channels then the left and right levels will both include all channels.</description></item>
            <item><term>BASS_LEVEL_RMS</term><description>Flag: Get the RMS level. Otherwise the peak level.</description></item>
            <item><term>BASS_LEVEL_VOLPAN</term><description>Apply the current BASS_ATTRIB_VOL and BASS_ATTRIB_PAN values to the level reading.</description></item>
            </list>
            </param>
            <returns>On success <see langword="true"/> is returned - else <see langword="false"/>, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the requested levels are returned in the <paramref name="levels"/> array.</para>
            </returns>
            <remarks>
            This function operates in the same way as <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> but has greater flexibility on how the level is measured. 
            The levels are not clipped, so may exceed +/-1.0 on floating-point channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The channel is not playing.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The decoding channel has reached the end.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetLevels(System.Int32,System.Single,Un4seen.Bass.BASSLevel)">
            <summary>
            Retrieves the level (peak amplitude) of a sample, stream, MOD music or recording channel.
            </summary>
            <param name="handle">The channel handle... a HCHANNEL, HMUSIC, HSTREAM, or HRECORD.</param>
            <param name="length">How much data (in seconds) to look at to get the level (limited to 1 second).</param>
            <param name="flags">What levels to retrieve. One of the following (see <see cref="T:Un4seen.Bass.BASSLevel"/>):
            <list type="table">
            <item><term>BASS_LEVEL_ALL</term><description>Retrieves a separate level for each channel.</description></item>
            <item><term>BASS_LEVEL_MONO</term><description>Retrieve a single mono level.</description></item>
            <item><term>BASS_LEVEL_STEREO</term><description>Get a stereo level. The left level will be from the even channels, and the right level will be from the odd channels. If there are an odd number of channels then the left and right levels will both include all channels.</description></item>
            <item><term>BASS_LEVEL_RMS</term><description>Flag: Get the RMS level. Otherwise the peak level.</description></item>
            <item><term>BASS_LEVEL_VOLPAN</term><description>Apply the current BASS_ATTRIB_VOL and BASS_ATTRIB_PAN values to the level reading.</description></item>
            </list>
            </param>
            <returns>On success the array of levels is returned - else <see langword="null"/> is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            </returns>
            <remarks>
            This function operates in the same way as <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> but has greater flexibility on how the level is measured. 
            The levels are not clipped, so may exceed +/-1.0 on floating-point channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_NOPLAY</term><description>The channel is not playing.</description></item>
            <item><term>BASS_ERROR_ENDED</term><description>The decoding channel has reached the end.</description></item>
            <item><term>BASS_ERROR_BUFLOST</term><description>Should not happen... check that a valid window handle was used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveSync(System.Int32,System.Int32)">
            <summary>
            Removes a synchronizer from a MOD music or stream channel.
            </summary>
            <param name="handle">The channel handle... a HMUSIC, HSTREAM or HRECORD.</param>
            <param name="sync">Handle of the synchronizer to remove (return value of a previous <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> call).</param>
            <returns>If succesful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="sync"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)">
            <summary>
            Removes a DSP function from a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="dsp">Handle of the DSP function to remove from the channel (return value of a previous <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> call).</param>
            <returns>If succesful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="dsp"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)">
            <summary>
            Removes an effect on a stream, MOD music, or recording channel.
            </summary>
            <param name="handle">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <param name="fx">Handle of the effect to remove from the channel (return value of a previous <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> call).</param>
            <returns>If succesful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Depending on the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> being used by the channel, the channel may have to be stopped before removing a DX8 effect on it.
            If necessary, that is done automatically and the channel is resumed afterwards.
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/> can also be used to remove effects.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="fx"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelSetLink(System.Int32,System.Int32)">
            <summary>
            Links two MOD music or stream channels together.
            </summary>
            <param name="handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="chan">The handle of the channel to have linked with it... a HMUSIC or HSTREAM.</param>
            <returns>If succesful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Linked channels are started/stopped/paused/resumed together. Links are one-way, for example, channel <paramref name="chan"/> will be started by channel <paramref name="handle"/>, but not vice versa unless another link has been set in that direction.</para>
            <para>If a linked channel has reached the end, it will not be restarted when a channel it is linked to is started. If you want a linked channel to be restarted, you need to have resetted it's position using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> beforehand.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description>At least one of <paramref name="handle"/> and <paramref name="chan"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_DECODE</term><description>At least one of <paramref name="handle"/> and <paramref name="chan"/> is a "decoding channel", so can't be linked.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description><paramref name="chan"/> is already linked to <paramref name="handle"/>.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            <para><b>Platform-specific</b></para>
            <para>Except for on Windows, linked channels on the same device are guaranteed to start playing simultaneously. On Windows, it is possible for there to be a slight gap between them, but it will generally be shorter (and never longer) than starting them individually.</para>
            </remarks>
            <example>
            Link 2 streams and play them together:
            <code>
            // link stream2 to stream1
            Bass.BASS_ChannelSetLink(stream1, stream2);
            // start both streams together
            Bass.BASS_ChannelPlay(stream1, false);
            </code>
            <code lang="vbnet">
            ' link stream2 to stream1
            Bass.BASS_ChannelSetLink(stream1, stream2)
            ' start both streams together
            Bass.BASS_ChannelPlay(stream1, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelRemoveLink(System.Int32,System.Int32)">
            <summary>
            Removes a links between two MOD music or stream channels.
            </summary>
            <param name="handle">The channel handle... a HMUSIC or HSTREAM.</param>
            <param name="chan">The handle of the channel to have unlinked with it... a HMUSIC or HSTREAM.</param>
            <returns>If succesful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not a valid channel.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>Either <paramref name="chan"/> is not a valid channel, or it is already not linked to <paramref name="handle"/>.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)">
            <summary>
            Retrieves the requested tags/headers from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="tags">The tags/headers wanted... one of the following (see <see cref="T:Un4seen.Bass.BASSTag"/>):
            <list type="table">
            <item><term>BASS_TAG_ID3</term><description>ID3v1 tags. A pointer to a 128 byte block is returned. See <a href="http://www.id3.org/id3v1.html">www.id3.org</a> for details of the block's structure.</description></item>
            <item><term>BASS_TAG_ID3V2</term><description>ID3v2 tags. A pointer to a variable length block is returned. See <a href="http://www.id3.org">www.id3.org</a> for details of the block's structure. ID3v2 tags are supported at both the start and end of the file.</description></item>
            <item><term>BASS_TAG_LYRICS3</term><description>Lyrics3v2 tag. A single string is returned, containing the Lyrics3v2 information. See <a href="http://www.id3.org/Lyrics3v2">www.id3.org/Lyrics3v2</a> for details of its format.</description></item>
            <item><term>BASS_TAG_APE</term><description>APE (v1 or v2) tags. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null. Each string is in the form of "key=value", or "key=value1/value2/..." if there are multiple values.</description></item>
            <item><term>BASS_TAG_APE_BINARY</term><description>+ tag number (0=first). APEv2 binary tag. A pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_APE_BINARY"/> structure is returned.</description></item>
            <item><term>BASS_TAG_OGG</term><description>OGG comments, only available when streaming an OGG file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_MP4</term><description>MP4/iTunes metadata. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_MF</term><description>Media Foundation metadata. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_VENDOR</term><description>OGG encoder. A single UTF-8 string is returned.</description></item>
            <item><term>BASS_TAG_HTTP</term><description>HTTP headers, only available when streaming from a HTTP server. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_ICY</term><description>ICY (Shoutcast) tags. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_META</term><description>Shoutcast metadata. A single null-terminated string containing the current stream title and url (usually omitted). The format of the string is: StreamTitle='xxx';StreamUrl='xxx';</description></item>
            <item><term>BASS_TAG_RIFF_INFO</term><description>RIFF/WAVE 'INFO' tags. A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null. The tags are in the form of 'XXXX=text', where 'XXXX' is the chunk ID.</description></item>
            <item><term>BASS_TAG_RIFF_DISP</term><description>RIFF/WAVE 'DISP' chunk text (CF_TEXT) tag. A single string is returned.</description></item>
            <item><term>BASS_TAG_RIFF_BEXT</term><description>RIFF/BWF "bext" chunk tags. A pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_BEXT"/> structure is returned.</description></item>
            <item><term>BASS_TAG_RIFF_CART</term><description>RIFF/BWF "cart" chunk tags. A pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_CART"/> structure is returned.</description></item>
            <item><term>BASS_TAG_RIFF_CUE</term><description>RIFF/CUE "cue" chunk tags. A pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/> structure is returned.</description></item>
            <item><term>BASS_TAG_RIFF_SMPL</term><description>RIFF/SMPL "smpl" chunk tags. A pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_SMPL"/> structure is returned.</description></item>
            <item><term>BASS_TAG_WAVEFORMAT</term><description>WAVE "fmt" chunk contents. A pointer to a WAVEFORMATEX structure is returned. As well as WAVE files, this is also provided by Media Foundation codecs.</description></item>
            <item><term>BASS_TAG_CA_CODEC</term><description>CoreAudio codec information. A pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_CACODEC"/> structure is returned.</description></item>
            <item><term>BASS_TAG_MUSIC_NAME</term><description>MOD music title (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_MESSAGE</term><description>MOD message text (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_INST</term><description>+ instrument number (0=first). MOD instrument name (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_SAMPLE</term><description>+ sample number (0=first). MOD sample name (a single null-terminated ANSI String).</description></item>
            <item><term>BASS_TAG_MUSIC_ORDERS</term><description>MOD music order list. A pointer to a byte array is returned, with each byte being the pattern number played at that order position. Pattern number 254 is "+++" (skip order) and 255 is "---" (end song).</description></item>
            </list>
            Other tags may be supported by Add-Ons, see the documentation.
            </param>
            <returns>If succesful, a pointer to the data of the tags/headers is returned, else <see cref="F:System.IntPtr.Zero"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Some tags (eg. ID3v1) are located at the end of the file, so when streaming a file from the internet, the tags will not be available until the download is complete. A BASS_SYNC_DOWNLOAD sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be informed of when the download is complete. 
            A BASS_SYNC_META sync can be used to be informed of new Shoutcast metadata, and a BASS_SYNC_OGG_CHANGE sync for when a new logical bitstream begins in a chained OGG stream, which generally brings new OGG tags.
            <para>In a chained OGG file containing multiple bitstreams, each bitstream will have its own tags. To get the tags from a particular one, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be first used to seek to it.</para>
            <para>When a Media Foundation codec is in use, the BASS_TAG_WAVEFORMAT tag can be used to find out what the source format is, eg. via the WAVEFORMATEX structure's wFormatTag member. Some typical wFormatTag examples are: 0x0161 = WMA, 0x0162 = WMA pro, 0x0163 = WMA lossless, 0x1610 = AAC.</para>
            <para>You might also use one of these overloads to directly get specific tags:
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsBWF(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsCA(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V1(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V2(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPE(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPEBinary(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPEPictures(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsWMA(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMP4(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMF(System.Int32)"/>,
            <see cref="!:BASS_ChannelGetTagsWAVEFORMAT"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsFLACPictures(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsFLACCuesheet(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsOGG(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsDSDArtist(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsDSDTitle(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsDSDComments(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsHTTP(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsICY(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsRIFF(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMETA(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagLyrics3v2(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicName(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicSample(System.Int32,System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicInstrument(System.Int32,System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicMessage(System.Int32)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)"/>.
            </para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Getting OGG Tags:
            <code>
            int channel = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT);
            IntPtr tag = Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_OGG);
            string[] tags = Utils.IntPtrToArrayNullTermUtf8(tag);
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.Writeln("Tag: {0}\n", tag);
            }
            </code>
            <code lang="vbnet">
            Dim channel As Integer = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT)
            Dim tag As IntPtr = Bass.BASS_ChannelGetTags(channel, BASSTag.BASS_TAG_OGG)
            Dim tags As String() = Utils.IntPtrToArrayNullTermUtf8(tag)
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In  tags
                Console.Writeln("Tag: {0}" + ControlChars.Lf, tag)
              Next tag
            End If
            </code>
            Getting MOD Music Instruments:
            <code>
            IntPtr p = BASS_ChannelGetTags(handle, (BASSTag)(BASSTag.BASS_TAG_MUSIC_INST + instrument));
            if (p != IntPtr.Zero)
              string instr = Utils.IntPtrAsStringAnsi(p);
            </code>
            <code lang="vbnet">
            Dim p As IntPtr = BASS_ChannelGetTags(handle, CType(BASSTag.BASS_TAG_MUSIC_INST + instrument, BASSTag))
            If p &lt;&gt; IntPtr.Zero Then
              Dim instr As String = Utils.IntPtrAsStringAnsi(p)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsArrayNullTermAnsi(System.Int32,Un4seen.Bass.BASSTag)">
            <summary>
            Retrieves the header tags from a channel, if they are available.
            <para>NOTE: This method evaluates the header as a series/array of null-terminated Ansi strings.</para>
            <para>Might be used e.g. with: RIFF_INFO, ICY and HTTP.</para>
            </summary>
            <param name="handle">The stream's handle.</param>
            <param name="format">The type of tags/headers wanted... one of the following (see <see cref="T:Un4seen.Bass.BASSTag"/>):
            <list type="table">
            <item><term>BASS_TAG_HTTP</term><description>HTTP headers, only available when streaming from a HTTP server. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_ICY</term><description>ICY (Shoutcast) tags. A pointer to a series of null-terminated strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_RIFF_INFO</term><description>RIFF/WAVE 'INFO' tags. A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null. The tags are in the form of 'XXXX=text', where 'XXXX' is the chunk ID.</description></item>
            </list>
            Other tags may be supported by Add-Ons, see the documentation (ASNI only).
            </param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag, e.g. "TITLE=this is a title"
            </returns>
            <remarks>
            Only available when streaming a file containing tags/headers which are defined as a series of null-terminated ASNI strings! So make sure to use this method only with appropriate formats!
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsArrayNullTermUtf8(System.Int32,Un4seen.Bass.BASSTag)">
            <summary>
            Retrieves the header tags from a channel, if they are available.
            <para>NOTE: This method evaluates the header as a series/array of null-terminated UTF-8 strings.</para>
            <para>Might be used e.g. with: APE, MP4, OGG and WMA - if UTF-8!</para>
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="format">The type of tags/headers wanted... one of the following (see <see cref="T:Un4seen.Bass.BASSTag"/>):
            <list type="table">
            <item><term>BASS_TAG_OGG</term><description>OGG tags, only available when streaming an OGG file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_VENDOR</term><description>Vendor encoder tag. A single UTF-8 string is returned.</description></item>
            <item><term>BASS_TAG_WMA</term><description>WMA tags : array of null-terminated UTF-8 strings.</description></item>
            <item><term>BASS_TAG_WMA_META</term><description>WMA mid-stream tag : A single UTF-8 string is returned.</description></item>
            <item><term>BASS_TAG_WMA_CODEC</term><description>WMA codec tag : Two UTF-8 strings are returned.</description></item>
            <item><term>BASS_TAG_APE</term><description>APE tags. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null. Each string is in the form of "key=value", or "key=value1/value2/..." if there are multiple values.</description></item>
            <item><term>BASS_TAG_MP4</term><description>MP4 tags. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            <item><term>BASS_TAG_MF</term><description>Media Foundation metadata. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.</description></item>
            </list>
            Other tags may be supported by Add-Ons, see the documentation - only UTF-8!
            </param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag, e.g. "TITLE=this is a title"</returns>
            <remarks>
            Only available when streaming a file containing tags/headers which are defined as a series of null-terminated UNICODE strings! So make sure to use this method only with appropriate formats!
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V1(System.Int32)">
            <summary>
            Retrieves the ID3v1 tags from a channel, if they are available.
            <para>This special helper method already evaluates the 128-byte ID3v3 data block.</para>
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns><see langword="null"/> or an array of strings with exactly 7 elements:
            <para>string[0] = 'song title' (max. 30 chars)</para>
            <para>string[1] = 'artist' (max. 30 chars)</para>
            <para>string[2] = 'album' (max. 30 chars)</para>
            <para>string[3] = 'year' (yyyy)</para>
            <para>string[4] = 'comment' (max. 28 chars)</para>
            <para>string[5] = 'genre-id'</para>
            <para>string[6] = 'track' (0-255)</para>
            </returns>
            <remarks>
            ID3v1 tags are located at the end of the file, so when streaming an MPEG file with ID3v1 tags from the internet, the tags will not be available until the download is complete. 
            A BASS_SYNC_DOWNLOAD sync can be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be informed of when the download is complete.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsID3V1(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsID3V1(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsBWF(System.Int32)">
            <summary>
            Retrieves the Broadcast Audio Extension (BEXT) tags from a channel, if they are available.
            <para>This special helper method already evaluates the BEXT data block.</para>
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns><see langword="null"/> or an array of strings with exactly 9 elements:
            <para>string[0] = Description/Title (max. 256 chars)</para>
            <para>string[1] = Originator/Artist (max. 32 chars)</para>
            <para>string[2] = OriginatorReference/EncodedBy (max. 32 chars)</para>
            <para>string[3] = OriginationDate (in format 'yyyy-mm-dd')</para>
            <para>string[4] = OriginationTime (in format 'hh:mm:ss')</para>
            <para>string[5] = TimeReference (in samples since midnight)</para>
            <para>string[6] = Version (BWF version is typically 0 or 1)</para>
            <para>string[7] = UMID/Copyright (max. 64 chars)</para>
            <para>string[8] = CodingHistory/Comment</para>
            </returns>
            <remarks>
            More info about the BWF/RF64 tags (Broadcast Audio Extension) can be found here: <a href="http://www.ebu.ch/CMSimages/en/tec_doc_t3285_tcm6-10544.pdf">EBU specification</a>.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsCA(System.Int32)">
            <summary>
            Retrieves the CoreAudio codec information structure from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns><see langword="null"/> or an instance of the array of strings with exactly 9 elements:
            <para>string[0] = Description/Title (max. 256 chars)</para>
            <para>string[1] = Originator/Artist (max. 32 chars)</para>
            <para>string[2] = OriginatorReference/EncodedBy (max. 32 chars)</para>
            <para>string[3] = OriginationDate (in format 'yyyy-mm-dd')</para>
            <para>string[4] = OriginationTime (in format 'hh:mm:ss')</para>
            <para>string[5] = TimeReference (in samples since midnight)</para>
            <para>string[6] = Version (BWF version is typically 0 or 1)</para>
            <para>string[7] = UMID/Copyright (max. 64 chars)</para>
            <para>string[8] = CodingHistory/Comment</para>
            </returns>
            <remarks>
            More info about the BWF/RF64 tags (Broadcast Audio Extension) can be found here: <a href="http://www.ebu.ch/CMSimages/en/tec_doc_t3285_tcm6-10544.pdf">EBU specification</a>.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsDSDArtist(System.Int32)">
            <summary>
            Gets a DSDIFF Artist tags.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns>The DSDIFF Artist string or <see langword="null"/>.</returns>
            <remarks>
            Only available when streaming a file containing DSDIFF tags.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsDSDTitle(System.Int32)">
            <summary>
            Gets a DSDIFF Title tags.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns>The DSDIFF Title string or <see langword="null"/>.</returns>
            <remarks>
            Only available when streaming a file containing DSDIFF tags.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsDSDComments(System.Int32)">
            <summary>
            Gets all available DSDIFF comment tags.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns><see langword="null"/> or an array of <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> instances.</returns>
            <remarks>
            Only available when streaming a file containing DSDIFF tags.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsID3V2(System.Int32)">
            <summary>
            Retrieves the ID3v2 header tags from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'FrameId=Value' (e.g. "TIT2=This is a Title").</returns>
            <remarks>Only tag values containing strings are returned (e.g. Txxx, Wxxx or COMM tags).
            <para>ID3v2 tags are supported at both the start and end of the file.</para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <exception cref="T:System.NotSupportedException">Invalid/Unsupported ID3v2 version detected.</exception>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsID3V2(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsID3V2(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPE(System.Int32)">
            <summary>
            Retrieves the APE (v1 or v2) header tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file containing APE tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("bass_ape.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.ape", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsAPE(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("bass_ape.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.ape", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsAPE(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPEBinary(System.Int32)">
            <summary>
            Retrieves all APE binary tags from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of <see cref="T:Un4seen.Bass.BASS_TAG_APE_BINARY"/> instances.</returns>
            <remarks>
            Only available when streaming a file containing APE tags.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("basswv.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.wv", 0, 0, BASSFlag.BASS_DEFAULT);
            BASS_TAG_APE_BINARY[] binTags = Bass.BASS_ChannelGetTagsAPEBinary(stream);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("basswv.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wv", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim binTags As BASS_TAG_APE_BINARY() = Bass.BASS_ChannelGetTagsAPEBinary(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsAPEPictures(System.Int32)">
            <summary>
            Retrieves all APEv2 picture tags from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE"/> instances.</returns>
            <remarks>
            Only available when streaming a file containing APE tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("basswv.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.wv", 0, 0, BASSFlag.BASS_DEFAULT);
            AddOn.Tags.TagPicture[] pics = Bass.BASS_ChannelGetTagsAPEPictures(stream);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("basswv.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wv", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim pics As AddOn.Tags.TagPicture() = Bass.BASS_ChannelGetTagsAPEPictures(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsWMA(System.Int32)">
            <summary>
            Retrieves the WMA header tags or mid-stream tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'AttribName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file containing WMA tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("basswma.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.wma", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsWMA(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("basswma.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wma", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsWMA(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMP4(System.Int32)">
            <summary>
            Retrieves the MP4 header tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file containing MP4 tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("bass_aac.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.m4a", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsMP4(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("bass_aac.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.m4a", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsMP4(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMF(System.Int32)">
            <summary>
            Retrieves the Media Foundation tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming a file using a Media Foundation codec (available on Windows7 and updated Vista only).
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            ...
            int stream = Bass.BASS_StreamCreateFile("test.m4a", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsMF(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.m4a", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsMF(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsFLACPictures(System.Int32)">
            <summary>
            Retrieves all FLAC picture tags from a channel, if they are available.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE"/> instances.</returns>
            <remarks>
            Only available when streaming a file containing FLAC tags.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("bassflac.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.flac", 0, 0, BASSFlag.BASS_DEFAULT);
            BASS_TAG_FLAC_PICTURE[] pics = Bass.BASS_ChannelGetTagsFLACPictures(stream);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("bassflac.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.flac", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim pics As BASS_TAG_FLAC_PICTURE() = Bass.BASS_ChannelGetTagsFLACPictures(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsFLACCuesheet(System.Int32)">
            <summary>
            Retrieves a FLAC cuesheet tags from a channel, if available.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE"/>.</returns>
            <remarks>
            Only available when streaming a file containing FLAC tags.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            Bass.BASS_PlugInLoad("bassflac.dll");
            ...
            int stream = Bass.BASS_StreamCreateFile("test.flac", 0, 0, BASSFlag.BASS_DEFAULT);
            BASS_TAG_FLAC_CUE cuesheet = Bass.BASS_ChannelGetTagsFLACCuesheet(stream);
            </code>
            <code lang="vbnet">
            Bass.BASS_PlugInLoad("bassflac.dll")
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.flac", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim cuesheet As BASS_TAG_FLAC_CUE = Bass.BASS_ChannelGetTagsFLACCuesheet(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsHTTP(System.Int32)">
            <summary>
            Retrieves the HTTP header tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one header entry, e.g. "Server: Icecast 2.2.0"
            </returns>
            <remarks>
            Only available when streaming from a HTTP source.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                              BASSFlag.BASS_STREAM_STATUS, null, IntPtr.Zero);
            string[] tags = Bass.BASS_ChannelGetTagsICY(stream);
            if (tags == null)
            {
              // try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream);
            }
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                                         BASSFlag.BASS_STREAM_STATUS, Nothing, IntPtr.Zero)
            Dim tags As String() = Bass.BASS_ChannelGetTagsICY(stream)
            If tags Is Nothing Then
              ' try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream)
            End If
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsICY(System.Int32)">
            <summary>
            Retrieves the ICY (Shoutcast) tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one ICY entry, e.g. "icy-name: name of the stream"
            </returns>
            <remarks>
            Only available when streaming from Shoutcast.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                              BASSFlag.BASS_STREAM_STATUS, null, IntPtr.Zero);
            string[] tags = Bass.BASS_ChannelGetTagsICY(stream);
            if (tags == null)
            {
              // try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream);
            }
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                                         BASSFlag.BASS_STREAM_STATUS, Nothing, IntPtr.Zero)
            Dim tags As String() = Bass.BASS_ChannelGetTagsICY(stream)
            If tags Is Nothing Then
              ' try http...
              tags = Bass.BASS_ChannelGetTagsHTTP(stream)
            End If
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsOGG(System.Int32)">
            <summary>
            Retrieves the OGG tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using UTF-8 strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'TagName=Value' (e.g. "TITLE=This is a Title").</returns>
            <remarks>
            Only available when streaming an OGG file.
            <para>In a chained OGG file containing multiple bitstreams, each bitstream will have its own tags. To get the tags from a particular one, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be first used to seek to it.</para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsOGG(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.ogg", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsOGG(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsRIFF(System.Int32)">
            <summary>
            Retrieves the RIFF/WAVE Info tags from a channel, if they are available.
            <para>This special helper method already evaluates the null-terminated and variable length data block using ANSI strings.</para>
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'ID=Value' (e.g. "IART =This is the Artist").</returns>
            <remarks>
            Only available for RIFF/WAVE files.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_DEFAULT);
            string[] tags = Bass.BASS_ChannelGetTagsRIFF(stream);
            foreach (string tag in tags)
              Console.WriteLine(tag);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim tags As String() = Bass.BASS_ChannelGetTagsRIFF(stream)
            Dim tag As String
            For Each tag In tags
              Console.WriteLine(tag)
            Next tag
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsRIFFCUE(System.Int32)">
            <summary>
            Gets an available RIFF "cue " tags.
            </summary>
            <param name="handle">The channel handle...a HSTREAM.</param>
            <returns><see langword="null"/> or an instance of <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/>.</returns>
            <remarks>
            Only available when streaming a file containing RIFF_CUE tags.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsMETA(System.Int32)">
            <summary>
            Retrieves metadata tags from a channel (Shoutcast or Icecast), if they are available.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one tag in the format 'Name=Value' (e.g. "StreamTitle='xyz'").</returns>
            <remarks>
            Only available when streaming from Shoutcast.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                              BASSFlag.BASS_STREAM_STATUS, null, IntPtr.Zero);
            string[] tags = Bass.BASS_ChannelGetTagsMETA(stream);
            if (tags != null)
            {
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.radio42.com/playHiFi.pls", 0, 
                                         BASSFlag.BASS_STREAM_STATUS, Nothing, IntPtr.Zero)
            Dim tags As String() = Bass.BASS_ChannelGetTagsMETA(stream)
            If Not (tags Is Nothing) Then
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
              Next tag
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetTagLyrics3v2(System.Int32)">
            <summary>
            Retrieves a Lyrics3v2 tag.
            </summary>
            <param name="handle">The channel handle.</param>
            <returns> A single string is returned, containing the Lyrics3v2 information - or <see langword="null"/>, if not available. 
            <para>See <a href="http://www.id3.org/Lyrics3v2">www.id3.org/Lyrics3v2</a> for details of its format.</para>
            </returns>
            <remarks>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicName(System.Int32)">
            <summary>
            Retrieves the MOD music title from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <returns><see langword="null"/> or a single string representing the MOD music title.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicMessage(System.Int32)">
            <summary>
            Retrieves the MOD message text from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <returns><see langword="null"/> or a single string representing the MOD message text.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicInstrument(System.Int32,System.Int32)">
            <summary>
            Retrieves a specific MOD instrument name from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <param name="instrument">The instrument number (0=first).</param>
            <returns><see langword="null"/> or a single string representing the MOD instrument name.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMusicSample(System.Int32,System.Int32)">
            <summary>
            Retrieves a specific MOD sample name from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a HMUSIC.</param>
            <param name="sample">The sample number (0=first).</param>
            <returns><see langword="null"/> or a single string representing the MOD sample name.</returns>
            <remarks>
            Only available for MOD music channels.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all MOD music's samples:
            <code>
            string name = String.Empty;
            int i = 0;
            while ( true )
            {
              name = Bass.BASS_ChannelGetMusicSample( mod, i );
              if ( name != null )
                Console.Writeln( String.Format( "Sample {0}={1}", i, name ) );
              else
                break;
              i++;
            }
            </code>
            <code lang="vbnet">
            Dim name As String = [String].Empty
            Dim i As Integer = 0
            While True
              name = Bass.BASS_ChannelGetMusicSample([mod], i)
              If Not (name Is Nothing) Then
                Console.Writeln([String].Format("Sample {0}={1}", i, name))
              Else
                Exit While
              End If
              i += 1
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_ChannelGetMidiTrackText(System.Int32,System.Int32)">
            <summary>
            Retrieves a specific MIDI track text from a channel, if it is available.
            </summary>
            <param name="handle">The channel handle...a MIDI HSTREAM.</param>
            <param name="track">The MIDI track number (0=first), use -1 to get the text for all tracks.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one text of the MIDI track.</returns>
            <remarks>
            The texts of each track in the MIDI file are available via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK"/>+track tag, where track=0 is the first track. 
            The first text in the first track is generally the title of the MIDI file. 
            <para>RIFF MIDI tags are also available via the standard <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO"/> tag.</para>
            <para>In addition you might also use the <see cref="T:Un4seen.Bass.AddOn.Tags.BassTags"/> class, which provides extended TAG reading support.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The requested tags are not available.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParametersExt(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.
            <para><i>Additional effect parameter structures might be implemented by add-ons.</i></para>
            </param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
             The structure used depends on the effect type.
            <para>For DX8 effects you might use: <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/>, <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/>, <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/>, <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/>, <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/>, <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/>, <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/>, <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/>, <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/>.</para>
            <para>For BASS_FX DSP effetcs you might use: <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV"/>.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add an effect DSP to a channel at anay time and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)"/> to remove an effect from the channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>One or more of the parameters are invalid, make sure all the values are within the valid ranges.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT);
            BASS_DX8_ECHO echo = new BASS_DX8_ECHO();
            // add the effect to the DSP chain
            int fxHandle = Bass.BASS_ChannelSetFX(stream, BASSFXType.BASS_FX_ECHO, 0);
            echo.Preset_Long();
            // apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo);
            // play the channel
            Bass.BASS_ChannelPlay(stream, false);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_DEFAULT)
            Dim echo As New BASS_DX8_ECHO()
            ' add the effect to the DSP chain
            Dim fxHandle As Integer = Bass.BASS_ChannelSetFX(stream, BASSFXType.BASS_FX_ECHO, 0)
            echo.Preset_Long()
            ' apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo)
            ' play the channel
            Bass.BASS_ChannelPlay(stream, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_FX_VOLUME_PARAM)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_CHORUS)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_COMPRESSOR)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_DISTORTION)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_ECHO)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_FLANGER)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_GARGLE)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_I3DL2REVERB)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_PARAMEQ)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.BASS_DX8_REVERB)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4)">
            <summary>
            Sets the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParametersExt(System.Int32,System.Single[])">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParametersExt(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="handle"></param>
            <param name="par"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.
            <para><i>Additional effect parameter structures might be implemented by add-ons.</i></para>
            </param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
             The structure used depends on the effect type.
            <para>For DX8 effects you might use: <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/>, <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/>, <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/>, <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/>, <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/>, <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/>, <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/>, <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/>, <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/>.</para>
            <para>For BASS_FX DSP effetcs you might use: <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX"/>, <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV"/>.</para>
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add an effect DSP to a channel at anay time and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveFX(System.Int32,System.Int32)"/> to remove an effect from the channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_DX8_ECHO echo = new BASS_DX8_ECHO();
            Bass.BASS_FXGetParameters(_fxEchoHandle, echo);
            Console.WriteLine( "Panning={0}", echo.lPanDelay );
            </code>
            <code lang="vbnet">
            Dim echo As New BASS_DX8_ECHO()
            Bass.BASS_FXGetParameters(_fxEchoHandle, echo)
            Console.WriteLine("Panning={0}", echo.lPanDelay)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_FX_VOLUME_PARAM)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_CHORUS)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_COMPRESSOR)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_DISTORTION)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_ECHO)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_FLANGER)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_GARGLE)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_I3DL2REVERB)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_PARAMEQ)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.BASS_DX8_REVERB)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4)">
            <summary>
            Retrieves the parameters of an effect.
            </summary>
            <param name="handle">The effect handle.</param>
            <param name="par">An instance of an effect parameter structures which should be filled.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            See <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> for details.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXReset(System.Int32)">
            <summary>
            Resets the state of an effect or all effects on a channel.
            </summary>
            <param name="handle">The effect or channel handle... a HFX, HSTREAM, HMUSIC, or HRECORD.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Call this function e.g. after changing the position or when you pause a channel or when a stream stalls to avoid clicks when resuming.
            <para>This function flushes the internal buffers of the effect(s). Effects are automatically reset by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>, except when called from a "mixtime" <see cref="T:Un4seen.Bass.SYNCPROC"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Bass.BASS_FXSetPriority(System.Int32,System.Int32)">
            <summary>
            Changes the priority of an DSP/FX effect.
            </summary>
            <param name="handle">The effect handle... a HDSP or HFX.</param>
            <param name="priority">The priority of the new DSP/FX, which determines it's position in the DSP chain - DSP/FX with higher priority are applied before those with lower. 
            This parameter has no effect with DX8 effects when the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> is used.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Bass.SupportedStreamExtensions">
            <summary>
            Supported stream file extensions of the bass.dll.
            </summary>
            <remarks>
            Note: This list reports a set of file extensions which might be supported by BASS.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Bass.SupportedStreamName">
            <summary>
            Supported file format name of the bass.dll.
            </summary>
            <remarks>
            Note: This list reports a set of file formats which might be supported by BASS.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Bass.SupportedMusicExtensions">
            <summary>
            Supported music file extensions of the bass.dll.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass._configUTF8">
            <summary>
            Was the BASS_CONFIG_UNICODE option set?
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.BASSVERSION">
            <summary>
            Current BASS version (without minor revision).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.FALSE">
            <summary>
            The BASS way to say <see langword="false"/> = 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.TRUE">
            <summary>
            The BASS way to say <see langword="true"/> = 1.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Bass.ERROR">
            <summary>
            The BASS way to say ERROR = -1.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSError">
            <summary>
            BASS error codes as returned e.g. by <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> (int)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_OK">
            <summary>
            All is OK
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_MEM">
            <summary>
            Memory error
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FILEOPEN">
            <summary>
            Can't open the file
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DRIVER">
            <summary>
            Can't find a free/valid driver
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_BUFLOST">
            <summary>
            The sample buffer was lost
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_HANDLE">
            <summary>
            Invalid handle
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FORMAT">
            <summary>
            Unsupported sample format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_POSITION">
            <summary>
            Invalid playback position
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_INIT">
            <summary>
            BASS_Init has not been successfully called
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_START">
            <summary>
            BASS_Start has not been successfully called
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOCD">
            <summary>
            No CD in drive
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CDTRACK">
            <summary>
            Invalid track number
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ALREADY">
            <summary>
            Already initialized/paused/whatever
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOPAUSE">
            <summary>
            Not paused
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOTAUDIO">
            <summary>
            Not an audio track
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOCHAN">
            <summary>
            Can't get a free channel
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ILLTYPE">
            <summary>
            An illegal type was specified
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ILLPARAM">
            <summary>
            An illegal parameter was specified
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NO3D">
            <summary>
            No 3D support
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOEAX">
            <summary>
            No EAX support
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DEVICE">
            <summary>
            Illegal device number
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOPLAY">
            <summary>
            Not playing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FREQ">
            <summary>
            Illegal sample rate
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOTFILE">
            <summary>
            The stream is not a file stream
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOHW">
            <summary>
            No hardware voices available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_EMPTY">
            <summary>
            The MOD music has no sequence data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NONET">
            <summary>
            No internet connection could be opened
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CREATE">
            <summary>
            Couldn't create the file
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOFX">
            <summary>
            Effects are not available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_PLAYING">
            <summary>
            The channel is playing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_NOTAVAIL">
            <summary>
            Requested data is not available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DECODE">
            <summary>
            The channel is a 'decoding channel'
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_DX">
            <summary>
            A sufficient DirectX version is not installed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_TIMEOUT">
            <summary>
            Connection timedout
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_FILEFORM">
            <summary>
            Unsupported file format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_SPEAKER">
            <summary>
            Unavailable speaker
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_VERSION">
            <summary>
            Invalid BASS version (used by add-ons)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CODEC">
            <summary>
            Codec is not available/supported
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ENDED">
            <summary>
            The channel/file has ended
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_BUSY">
            <summary>
            The device is busy (eg. in "exclusive" use by another process)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_UNKNOWN">
            <summary>
            Some other mystery error
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_LICENSE">
            <summary>
            BassWma: the file is protected
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_WM9">
            <summary>
            BassWma: WM9 is required
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_DENIED">
            <summary>
            BassWma: access denied (user/pass is invalid)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_CODEC">
            <summary>
            BassWma: no appropriate codec is installed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WMA_INDIVIDUAL">
            <summary>
            BassWma: individualization is needed
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_ACM_CANCEL">
            <summary>
            BassEnc: ACM codec selection cancelled
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_CAST_DENIED">
            <summary>
            BassEnc: Access denied (invalid password)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_VST_ERROR_NOINPUTS">
            <summary>
            BassVst: the given effect has no inputs and is probably a VST instrument and no effect
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_VST_ERROR_NOOUTPUTS">
            <summary>
            BassVst:  the given effect has no outputs
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_VST_ERROR_NOREALTIME">
            <summary>
            BassVst: the given effect does not support realtime processing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WASAPI">
            <summary>
            BASSWASAPI: no WASAPI available
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WASAPI_BUFFER">
            <summary>
            BASSWASAPI: buffer size is invalid
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WASAPI_CATEGORY">
            <summary>
            BASSWASAPI: can't set category
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_MP4_NOSTREAM">
            <summary>
            BASS_AAC: non-streamable due to MP4 atom order ('mdat' before 'moov')
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WEBM_NOTAUDIO">
            <summary>
            BASSWEBM: non-streamable WebM audio
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSError.BASS_ERROR_WEBM_TRACK">
            <summary>
            BASSWEBM: invalid track number
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInit">
            <summary>
            Initialization flags to be used with <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_DEFAULT">
            <summary>
            0 = 16 bit, stereo, no 3D, no Latency calc, no Speaker Assignments
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_8BITS">
            <summary>
            Use 8 bit resolution, else 16 bit.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_MONO">
            <summary>
            Use mono, else stereo.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_3D">
            <summary>
            Enable 3D functionality.
            <para>Note: If the BASS_DEVICE_3D flag is not specified when initilizing BASS,
            then the 3D flags (BASS_SAMPLE_3D and BASS_MUSIC_3D) are ignored when
            loading/creating a sample/stream/music.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_LATENCY">
            <summary>
            Calculate device latency (BASS_INFO struct).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_CPSPEAKERS">
            <summary>
            Use the Windows control panel setting to detect the number of speakers.
            <para>Only use this option if BASS doesn't detect the correct number of supported speakers automatically and you want to force BASS to use the number of speakers as configured in the windows control panel.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_SPEAKERS">
            <summary>
            Force enabling of <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> (always 8 speakers will be used regardless if the soundcard supports them).
            <para>Only use this option if BASS doesn't detect the correct number of supported speakers automatically and you want to force BASS to use 8 speakers.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_NOSPEAKER">
            <summary>
            ignore speaker arrangement
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVIDE_DMIX">
            <summary>
            Linux-only: Initialize the device using the ALSA "dmix" plugin, else initialize the device for exclusive access.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_FREQ">
            <summary>
            Set the device's output rate to freq, otherwise leave it as it is.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_STEREO">
            <summary>
            Limits the output to stereo (only really affects Linux; it's ignored on Windows and OSX).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_HOG">
            <summary>
            Use hog/exclusive mode.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInit.BASS_DEVICE_DSOUND">
            <summary>
            use DirectSound output
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSDirectSound">
            <summary>
            Direct Sound interface flags for use with <see cref="!:Bass.BASS_GetDSoundObject"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDirectSound.BASS_OBJECT_DS">
            <summary>
            Retrieve the IDirectSound interface.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDirectSound.BASS_OBJECT_DS3DL">
            <summary>
            Retrieve the IDirectSound3DListener interface.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSConfig">
            <summary>
            Configuration options to be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SetConfigPtr(Un4seen.Bass.BASSConfig,System.IntPtr)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_GetConfigPtr(Un4seen.Bass.BASSConfig)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER">
            <summary>
            Playback buffer length.
            <para>length (int): The buffer length in milliseconds. The minimum length is 1ms above the update period (see <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD"/>), the maximum is 5000 milliseconds. If the length specified is outside this range, it is automatically capped.</para>
            <para>The default buffer length is 500 milliseconds. Increasing the length, decreases the chance of the sound possibly breaking-up on slower computers, but also increases the latency for DSP/FX.</para>
            <para>Small buffer lengths are only required if the sound is going to be changing in real-time, for example, in a soft-synth. If you need to use a small buffer, then the minbuf member of BASS_INFO should be used to get the recommended minimum buffer length supported by the device and it's drivers. Even at this default length, it's still possible that the sound could break up on some systems, it's also possible that smaller buffers may be fine. So when using small buffers, you should have an option in your software for the user to finetune the length used, for optimal performance.</para>
            <para>Using this config option only affects the HMUSIC/HSTREAM channels that you create afterwards, not the ones that have already been created. So you can have channels with differing buffer lengths by using this config option each time before creating them.</para>
            <para>If automatic updating is disabled, make sure you call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> frequently enough to keep the buffers updated.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATEPERIOD">
            <summary>
            The update period of HSTREAM and HMUSIC channel playback buffers.
            <para>period (int): The update period in milliseconds... 0 = disable automatic updating. The minimum period is 5ms, the maximum is 100ms. If the period specified is outside this range, it is automatically capped.</para>
            <para>The update period is the amount of time between updates of the playback buffers of HSTREAM/HMUSIC channels. Shorter update periods allow smaller buffers to be set with the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> option, but as the rate of updates increases, so the overhead of setting up the updates becomes a greater part of the CPU usage. 
            The update period only affects HSTREAM and HMUSIC channels, it does not affect samples. Nor does it have any effect on decoding channels, as they are not played.</para>
            <para>BASS creates one or more threads (determined by <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATETHREADS"/>) specifically to perform the updating, except when automatic updating is disabled (period=0) - then you must regularly call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/>instead. This allows you to synchronize BASS's CPU usage with your program's. For example, in a game loop you could call <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> once per frame, which keeps all the processing in sync so that the frame rate is as smooth as possible. BASS_Update should be called at least around 8 times per second, even more often if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> option is used to set smaller buffers.</para>
            <para>The update period can be altered at any time, including during playback. The default period is 100ms.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_GVOL_SAMPLE">
            <summary>
            Global sample volume.
            <para>volume (int): Sample global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the samples, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_GVOL_STREAM">
            <summary>
            Global stream volume.
            <para>volume (int): Stream global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all streams, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_GVOL_MUSIC">
            <summary>
            Global music volume.
            <para>volume (int): MOD music global volume level... 0 (silent) - 10000 (full).</para>
            <para>This config option allows you to have control over the volume levels of all the MOD musics, which is useful for setup options (eg. separate music and fx volume controls).</para>
            <para>A channel's final volume = channel volume * global volume / max volume. So, for example, if a stream channel's volume is 0.5 and the global stream volume is 8000, then effectively the stream's volume level is 0.4 (0.5 * 8000 / 10000 = 0.4).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_VOL">
            <summary>
            Volume translation curve.
            <para>logvol (bool): Volume curve... <see langword="false"/> = linear, <see langword="true"/> = logarithmic.</para>
            <para>DirectSound uses logarithmic volume and panning curves, which can be awkward to work with. 
            For example, with a logarithmic curve, the audible difference between 10000 and 9000, is not the same as between 9000 and 8000. 
            With a linear "curve" the audible difference is spread equally across the whole range of values, so in the previous example the audible difference between 10000 and 9000, and between 9000 and 8000 would be identical.</para>
            <para>When using the linear curve, the volume range is from 0% (silent) to 100% (full). 
            When using the logarithmic curve, the volume range is from -100 dB (effectively silent) to 0 dB (full). For example, a volume level of 0.5 is 50% linear or -50 dB logarithmic.</para>
            <para>The linear curve is used by default.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_PAN">
            <summary>
            Panning translation curve.
            <para>logpan (bool): Panning curve... <see langword="false"/> = linear, <see langword="true"/> = logarithmic.</para>
            <para>The panning curve affects panning in exactly the same way as the volume curve (BASS_CONFIG_CURVE_VOL) affects the volume.</para>
            <para>The linear curve is used by default.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP">
            <summary>
            Pass 32-bit floating-point sample data to all DSP functions?
            <para>floatdsp (bool): If <see langword="true"/>, 32-bit floating-point sample data is passed to all <see cref="T:Un4seen.Bass.DSPPROC"/> callback functions.</para>
            <para>Normally DSP functions receive sample data in whatever format the channel is using, ie. it can be 8, 16 or 32-bit. But using this config option, BASS will convert 8/16-bit sample data to 32-bit floating-point before passing it to DSP functions, and then convert it back after all the DSP functions are done. As well as simplifying the DSP code (no need for 8/16-bit processing), this also means that there is no degradation of quality as sample data passes through a chain of DSP.</para>
            <para>This config option also applies to effects set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>, except for DX8 effects when using the "With FX flag" <a href="../Overview.html#DX8DMO">DX8 effect implementation</a>.</para>
            <para>Changing the setting while there are DSP or FX set could cause problems, so should be avoided.</para>
            <para><b>Platform-specific:</b> On Android and Windows CE, 8.24 bit fixed-point is used instead of floating-point. Floating-point DX8 effect processing requires DirectX 9 (or above) on Windows.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_3DALGORITHM">
            <summary>
            The 3D algorithm for software mixed 3D channels.
            <para>algo (int): Use one of the <see cref="T:Un4seen.Bass.BASS3DAlgorithm"/> flags.</para>
            <para>These algorithms only affect 3D channels that are being mixed in software. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> can be used to check whether a channel is being software mixed.</para>
            <para>Changing the algorithm only affects subsequently created or loaded samples, musics, or streams; it does not affect any that already exist.</para>
            <para>On Windows, DirectX 7 or above is required for this option to have effect. On other platforms, only the BASS_3DALG_DEFAULT and BASS_3DALG_OFF options are available.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_TIMEOUT">
            <summary>
            Time to wait for a server to respond to a connection request.
            <para>timeout (int): The time to wait, in milliseconds.</para>
            <para>The default timeout is 5 seconds (5000 milliseconds).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_BUFFER">
            <summary>
            The internet download buffer length.
            <para>length (int): The buffer length, in milliseconds.</para>
            <para>Increasing the buffer length decreases the chance of the stream stalling, but also increases the time taken by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> to create the stream, as it has to pre-buffer more data (adjustable via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PREBUF"/> option). Aside from the pre-buffering, this setting has no effect on streams without either the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_BLOCK"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_RESTRATE"/> flags.</para>
            <para>When streaming in blocks, this option determines the download buffer length. The effective buffer length can actually be a bit more than that specified, including data that has been read from the buffer by the decoder but not yet decoded.</para>
            <para>This config option also determines the buffering used by "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            <para>The default buffer length is 5 seconds (5000 milliseconds). The net buffer length should be larger than the length of the playback buffer (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/>), otherwise the stream is likely to briefly stall soon after starting playback.</para>
            <para>Using this config option only affects streams created afterwards, not any that have already been created.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_PAUSE_NOPLAY">
            <summary>
            Prevent channels being played when the output is paused?
            <para>noplay (bool): If <see langword="true"/>, channels can't be played while the output is paused.</para>
            <para>When the output is paused using <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, and this config option is enabled, channels can't be played until the output is resumed using <see cref="M:Un4seen.Bass.Bass.BASS_Start"/>. Attempts to play a channel will give a <see cref="F:Un4seen.Bass.BASSError.BASS_ERROR_START"/> error.</para>
            <para>By default, this config option is enabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PREBUF">
            <summary>
            Amount to pre-buffer when opening internet streams.
            <para>prebuf (int): Amount (percentage) to pre-buffer.</para>
            <para>This setting determines what percentage of the buffer length (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_BUFFER"/>) should be filled by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. The default is 75%. Setting this lower (eg. 0) is useful if you want to display a "buffering progress" (using <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>) when opening internet streams, but note that this setting is just a minimum - BASS will always pre-download a certain amount to verify the stream.</para>
            <para>The pre-buffering can be done by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> or asynchronously, depending on the BASS_CONFIG_NET_PREBUF_WAIT setting.</para>
            <para>As well as internet streams, this config setting also applies to "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_AGENT">
            <summary>
            The "User-Agent" request header sent to servers.
            <para>agent (string pointer): The "User-Agent" header.</para>
            <para>BASS makes a copy of the provided string, so it does not need to persist beyond the call. Changes take effect from the next internet stream creation call.</para>
            <para>On Windows and Windows CE, the BASS_UNICODE flag can be used with a UTF-16 string.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PROXY">
            <summary>
            Proxy server settings (in the form of "user:pass@server:port"... <see langword="null"/> = don't use a proxy).
            <para>proxy (string pointer): The proxy server settings, in the form of "user:pass@server:port"... NULL = don't use a proxy. "" (empty string) = use the OS's default proxy settings. If only the "user:pass@" part is specified, then those authorization credentials are used with the default proxy server. If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.</para>
            <para>makes a copy of the provided string, so it does not need to persist beyond the call. Changes take effect from the next internet stream creation call.</para>
            <para>On Windows and Windows CE, the BASS_UNICODE flag can be used with a UTF-16 string.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PASSIVE">
            <summary>
            Use passive mode in FTP connections?
            <para>passive (bool): If <see langword="true"/>, passive mode is used, otherwise normal/active mode is used.</para>
            <para>Changes take effect from the next internet stream creation call. By default, passive mode is enabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_REC_BUFFER">
            <summary>
            The buffer length for recording channels.
            <para>length (int): The buffer length in milliseconds... 1000 (min) - 5000 (max). If the length specified is outside this range, it is automatically capped.</para>
            <para>Unlike a playback buffer, where the aim is to keep the buffer full, a recording buffer is kept as empty as possible and so this setting has no effect on latency. The default recording buffer length is 2000 milliseconds. Unless processing of the recorded data could cause significant delays, or you want to use a large recording period with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>, there should be no need to increase this.</para>
            <para>Using this config option only affects the recording channels that are created afterwards, not any that have already been created. So you can have channels with differing buffer lengths by using this config option each time before creating them.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PLAYLIST">
            <summary>
            Process URLs in PLS, M3U, WPL or ASX playlists?
            <para>netlists (int): When to process URLs in PLS, M3U, WPL or ASX playlists... 0 = never, 1 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> only, 2 = in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> too.</para>
            <para>When enabled, BASS will process PLS, M3U, WPL and ASX playlists, going through each entry until it finds a URL that it can play. 
            By default, playlist procesing is disabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MUSIC_VIRTUAL">
            <summary>
            The maximum number of virtual channels to use in the rendering of IT files.
            <para>number (int): The number of virtual channels... 1 (min) to 512 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>This setting only affects IT files, as the other MOD music formats do not have virtual channels. The default setting is 64. Changes only apply to subsequently loaded files, not any that are already loaded.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_VERIFY">
            <summary>
            The amount of data to check in order to verify/detect the file format.
            <para>length (int): The amount of data to check, in bytes... 1000 (min) to 100000 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats, 
            but it may also be used by add-ons (see the documentation). For internet (and "buffered" user file) streams, a quarter of the length is used, up to a minimum of 1000 bytes.</para>
            <para>The verification length excludes any tags that may be at the start of the file. The default length is 16000 bytes.</para>
            <para>For internet (and "buffered" user file) streams, the BASS_CONFIG_VERIFY_NET setting determines how much data is checked.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UPDATETHREADS">
            <summary>
            The number of threads to use for updating playback buffers.
            <para>threads (int): The number of threads to use... 0 = disable automatic updating.</para>
            <para>The number of update threads determines how many HSTREAM/HMUSIC channel playback buffers can be updated in parallel; 
            each thread can process one channel at a time. The default is to use a single thread, but additional threads can be used to take advantage of multiple CPU cores. 
            There is generally nothing much to be gained by creating more threads than there are CPU cores, but one benefit of using multiple threads even with a single CPU core is that a slow updating channel need not delay the updating of other channels.</para>
            <para>When automatic updating is disabled (threads = 0), <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> should be used instead.</para>
            <para>The number of update threads can be changed at any time, including during playback.</para>
            <para><b>Platform-specific:</b> The number of update threads is limited to 1 on Windows CE platforms.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DEV_BUFFER">
            <summary>
            Linux, Android and CE only: The output device buffer length.
            <para>length (int): The buffer length in milliseconds.</para>
            <para>The device buffer is where the final mix of all playing channels is placed, ready for the device to play. Its length affects the latency of things like starting and stopping playback of a channel, so you will probably want to avoid setting it unnecessarily high, but setting it too short could result in breaks in the output.</para>
            <para>When using a large device buffer, the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_NOBUFFER"/> attribute could be used to skip the channel buffering stage, to avoid further increasing latency for real-time generated sound and/or DSP/FX changes.</para>
            <para>Changes to this config setting only affect subsequently initialized devices, not any that are already initialized.</para>
            <para>This config option is only available on Linux, Android and Windows CE. The device's buffer is determined automatically on other platforms.</para>
            <para><b>Platform-specific:</b> On Linux, the driver may choose to use a different buffer length if it decides that the specified length is too short or long. The buffer length actually being used can be obtained with <see cref="T:Un4seen.Bass.BASS_INFO"/>, like this: latency + minbuf / 2.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_VISTA_TRUEPOS">
            <summary>
            Enable true play position mode on Windows Vista and newer?
            <para>truepos (bool): If enabled, DirectSound's 'true play position' mode is enabled on Windows Vista and newer (default is <see langword="true"/>).</para>
            <para>Unless this option is enabled, the reported playback position will advance in 10ms steps on Windows Vista and newer. As well as affecting the precision of <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, this also affects the timing of non-mixtime syncs. When this option is enabled, it allows finer position reporting but it also increases latency</para>
            <para>The default setting is enabled. Changes only affect channels that are created afterwards, not any that already exist. The latency and minbuf values in the <see cref="T:Un4seen.Bass.BASS_INFO"/> structure reflect the setting at the time of the device's <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MP3_ERRORS">
            <summary>
            Suppress silencing for corrupted MP3 frames.
            <para>errors (bool): Suppress error correction silences? (default is <see langword="false"/>).</para>
            <para>When BASS is detecting some corruption in an MP3 file's Huffman coding, it silences the frame to avoid any unpleasent noises that can result from corruption.
            Set this parameter to <see langword="true"/> in order to suppress this behavior and </para>
            <para>This applies only to the regular BASS version and NOT the "mp3-free" version.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DEV_DEFAULT">
            <summary>
            Windows-only: Include a "Default" entry in the output device list?
            <para>default (bool): If <see langword="true"/>, a 'Default' device will be included in the device list (default is <see langword="false"/>).</para>
            <para>BASS does not usually include a "Default" entry in its device list, as that would ultimately map to one of the other devices and be a duplicate entry. When the default device is requested in a <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call (with device = -1), BASS will check the default device at that time, and initialize it. But Windows 7 has the ability to automatically switch the default output to the new default device whenever it changes, and in order for that to happen, the default device (rather than a specific device) needs to be used. That is where this option comes in.</para>
            <para>When enabled, the "Default" device will also become the default device to <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> (with device = -1). When the "Default" device is used, the <see cref="M:Un4seen.Bass.Bass.BASS_SetVolume(System.Single)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_GetVolume"/> functions work a bit differently to usual; they deal with the "session" volume, which only affects the current process's output on the device, rather than the device's volume.</para>
            <para>This option can only be set before <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> has been called.</para>
            <para><b>Platform-specific:</b> This config option is only available on Windows. It is available on all Windows versions (not including CE), but only Windows 7 has the default output switching feature.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_READTIMEOUT">
            <summary>
            The time to wait for a server to deliver more data for an internet stream.
            <para>timeout (int): The time to wait in milliseconds (default=0, infinite).</para>
            <para>When the timeout is hit, the connection with the server will be closed. The default setting is 0, no timeout.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_VISTA_SPEAKERS">
            <summary>
            Enable speaker assignment with panning/balance control on Windows Vista and newer?
            <para>enable (bool): If <see langword="true"/>, speaker assignment with panning/balance control is enabled on Windows Vista and newer.</para>
            <para>Panning/balance control via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_PAN"/> attribute is not available when <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> is used on Windows due to the way that the speaker assignment needs to be implemented there. The situation is improved with Windows Vista, and speaker assignment can generally be done in a way that does permit panning/balance control to be used at the same time, but there may still be some drivers that it does not work properly with, so it is disabled by default and can be enabled via this config option. Changes only affect channels that are created afterwards, not any that already exist.</para>
            <para><b>Platform-specific:</b> This config option is only available on Windows. It is available on all Windows versions (not including CE), but only has effect on Windows Vista and newer. Speaker assignment with panning/balance control is always possible on other platforms, where BASS generates the final mix.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MF_DISABLE">
            <summary>
            Disable the use of Media Foundation?
            <para>enable (bool): Disable Media Foundation?</para>
            <para>This option determines whether Media Foundation codecs can be used to decode files and streams. It is set to <see langword="false"/> by default when Media Foundation codecs are available, which is on Windows 7 and above, and updated versions of Vista. It will otherwise be <see langword="true"/> and read-only.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_HANDLES">
            <summary>
            Gets the total number of HSTREAM/HSAMPLE/HMUSIC/HRECORD handles.
            <para>none: only used with <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/>.</para>
            <para>The handle count may not only include the app-created stuff but also internal stuff, eg. BASS_WASAPI_Init will create a stream when the BASS_WASAPI_BUFFER flag is used.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UNICODE">
            <summary>
            Gets or Sets the Unicode character set in device information.
            <para>utf8 (bool): If <see langword="true"/>, device information will be in UTF-8 form. Otherwise it will be ANSI.</para>
            <para>This config option determines what character set is used in the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> structure and by the <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInputName(System.Int32)"/> function. 
            The default setting is ANSI, and it can only be changed before <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has been called.</para>
            <para><b>Platform-specific:</b> This config option is only available on Windows.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SRC">
            <summary>
            Gets or Sets the default sample rate conversion quality.
            <para>quality (int): The sample rate conversion quality... 0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation, 4 = 64 point sinc interpolation. Other values are also accepted.</para>
            <para>This config option determines what sample rate conversion quality new channels will initially have, except for sample channels (HCHANNEL), which use the BASS_CONFIG_SRC_SAMPLE setting.
            A channel's sample rate conversion quality can subsequently be changed via the BASS_ATTRIB_SRC attribute (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>).</para>
            <para>The default setting is 1 (8 point sinc interpolation) or 2 when SSE is available (16 point sinc interpolation).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SRC_SAMPLE">
            <summary>
            Gets or Sets the default sample rate conversion quality for samples.
            <para>quality (int): The sample rate conversion quality... 0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation. Other values are also accepted.</para>
            <para>This config option determines what sample rate conversion quality a new sample channel will initially have, following a <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/> call.
            The channel's sample rate conversion quality can subsequently be changed via the BASS_ATTRIB_SRC attribute (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>).</para>
            <para>The default setting is 0 (linear interpolation).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ASYNCFILE_BUFFER">
            <summary>
            The buffer length for asynchronous file reading (default setting is 65536 bytes (64KB)).
            <para>length (int): The buffer length in bytes. This will be rounded up to the nearest 4096 byte (4KB) boundary.</para>
            <para>This determines the amount of file data that can be read ahead of time with asynchronous file reading. Changes only affect streams that are created afterwards, not any that already exist. So it is possible to have streams with differing buffer lengths by using this config option before creating each of them.</para>
            <para>When asynchronous file reading is enabled, the buffer level is available from <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_OGG_PRESCAN">
            <summary>
            Pre-scan chained OGG files?
            <para>prescan (bool): If <see langword="true"/>, chained OGG files are pre-scanned.</para>
            <para>This option is enabled by default, and is equivalent to including the BASS_STREAM_PRESCAN flag in a <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call when opening an OGG file. It can be disabled if seeking and an accurate length reading are not required from chained OGG files, for faster stream creation.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_AIRPLAY">
            <summary>
            OSX only: Gets or Sets which Airplay receivers are enabled.
            <para>receivers (int): Enabled receivers... the 1st bit is the 1st reciever, the 2nd bit is the 2nd receiver, etc. If a bit is set, then the corresponding receiver is enabled.</para>
            <para>This config option determines which Airplay receivers will receive the sound when the Airplay output device is used. The receiver configuration is a global setting, so changes will also affect any other software that uses the Airplay device.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> can be used to enumerate the available Airplay receivers. Unlike the output device list, where entries are never removed (the BASS_DEVICE_ENABLED flag is just unset), entries may be removed from the Airplay receiver list as it only contains receivers that are currently available. That means you should not depend on the bit indexes remaining constant.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_VERIFY_NET">
            <summary>
            The amount of data to check in order to verify/detect the file format of internet streams.
            <para>length (int): The amount of data to check, in bytes... 1000 (min) to 1000000 (max), or 0 = 25% of the BASS_CONFIG_VERIFY setting (with a minimum of 1000 bytes). If the value specified is outside this range, it is automatically capped.</para>
            <para>Of the file formats supported as standard, this setting only affects the detection of MP3/MP2/MP1 formats, but it may also be used by add-ons (see the documentation). 
            The verification length excludes any tags that may be found at the start of the file. The default setting is 0, which means 25% of the BASS_CONFIG_VERIFY setting.</para>
            <para>As well as internet streams, this config setting also applies to "buffered" user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_SEEK">
            <summary>
            Determines the maximum forward seek that will be allowed when creating an internet or buffered user file stream.
            <para>length (int): the maximum forward seek that will be allowed.</para>
            <para>The seeking involves downloading up to the requested position, so there needs to be some limit to avoid potentially pre-downloading massive files entirely, 
            eg. to read ID3v1 tags from the end.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PLAYLIST_DEPTH">
            <summary>
            Maximum nested playlist processing depth.
            <para>depth (int): Maximum nested playlist processing depth... 0 = do not process nested playlists.</para>
            <para>When playlist processing is enabled via the BASS_CONFIG_NET_PLAYLIST option, this option limits how deep into nested playlists BASS_StreamCreateURL will go. The default depth is 1, which means playlists within the root playlist will be processed, but not playlists within those playlists.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_PREBUF_WAIT">
            <summary>
            Wait for pre-buffering when opening internet streams?
            <para>wait (bool): Wait for pre-buffering... <see langword="false"/> = no, <see langword="true"/> = yes.</para>
            <para>This setting determines whether <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> will wait for an amount of data to be downloaded before returning the new stream's handle. 
            The amount is determined by the BASS_CONFIG_NET_BUFFER and BASS_CONFIG_NET_PREBUF settings. 
            The default setting is disabled. When it is disabled, pre-buffering will happen asynchronously and playback will begin in a stalled state while pre-buffering is in progress. 
            The progress can be monitored with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>.</para>
            <para>As well as internet streams, this config setting also applies to streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> and the STREAMFILE_BUFFER file system.
            <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> will never pre-buffer when using the STREAMFILE_BUFFERPUSH system.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_LIBSSL">
            <summary>
            The OpenSSL (or compatible) library to use for handling HTTPS connections.
            <para>filename (string pointer): The filename of the OpenSSL library to use... NULL = use default. This should include the full path if it is not in the system library search path.</para>
            <para>By default, BASS will try to use the system's OpenSSL library to handle HTTPS connections. It will look for libssl.so, libssl.so.10, or libssl.so.1.0.0. If the target system uses a different filename for it, or you want to use a custom OpenSSL build, this option should be set to that. That should be done before the first HTTPS connection is opened. If the specified library cannot be loaded, BASS will fallback to trying the defaults.</para>
            <para>BASS makes a copy of the provided string, so it does not need to persist beyond the call..</para>
            <para>This option is only available on the Linux and Android platforms.
            On Android, BASS will look for the library in the app's library directory if a full path is not provided. A BASS_SSL add-on is available, which will be used by default when present. If that is not present then the default is to use the system's libssl.so or libboringssl.so library, but note that is not possible when targetting Android 7 (API level 24) or above.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_WASAPI_PERSIST">
            <summary>
            Presist resp. retain Windows mixer settings when using WASAPI output?
            <para>retain (bool): Retain Windows mixer settings... <see langword="false"/> = no, <see langword="true"/> = yes (default).</para>
            <para>Changes should be made before calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_PRIORITY">
            <summary>
            BASSenc add-on: Encoder DSP priority (default -1000)
            <para>priority (int): The priorty determines where in the DSP chain the encoding is performed - all DSP with a higher priority will be present in the encoding. Changes only affect subsequent encodings, not those that have already been started. The default priority is -1000.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_QUEUE">
            <summary>
            BASSenc add-on: The maximum queue length (default 10000, 0=no limit)
            <para>limit (int): The async encoder queue size limit in milliseconds; 0=unlimited.</para>
            <para>When queued encoding is enabled, the queue's buffer will grow as needed to hold the queued data, up to a limit specified by this config option.
            The default limit is 10 seconds (10000 milliseconds). Changes only apply to new encoders, not any already existing encoders.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_ACM_LOAD">
            <summary>
            BASSenc add-on: ACM codec name to give priority for the formats it supports.
            <para>codec (string pointer): The ACM codec name to give priority (e.g. 'l3codecp.acm').</para>
            <para>BASSenc does make a copy of the config string, so it can be freed right after calling it.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_CAST_TIMEOUT">
            <summary>
            BASSenc add-on: The time to wait to send data to a cast server (default 5000ms)
            <para>timeout (int): The time to wait, in milliseconds.</para>
            <para>When an attempt to send data is timed-out, the data is discarded. <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetNotify(System.Int32,Un4seen.Bass.AddOn.Enc.ENCODENOTIFYPROC,System.IntPtr)"/> can be used to receive a notification of when this happens.</para>
            <para>The default timeout is 5 seconds (5000 milliseconds). Changes take immediate effect.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_ENCODE_CAST_PROXY">
            <summary>
            BASSenc add-on: Proxy server settings when connecting to Icecast and Shoutcast (in the form of "[user:pass@]server:port"... <see langword="null"/> = don't use a proxy but a direct connection).
            <para>proxy (string pointer): The proxy server settings, in the form of "[user:pass@]server:port"... <see langword="null"/> = don't use a proxy but make a direct connection (default). If only the "server:port" part is specified, then that proxy server is used without any authorization credentials.</para>
            <para>BASSenc does not make a copy of the config string, so it must reside in the heap (not the stack), eg. a global variable. This also means that the proxy settings can subsequently be changed at that location without having to call this function again.</para>
            <para>This setting affects how the following functions connect to servers: <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastGetStats(System.Int32,Un4seen.Bass.AddOn.Enc.BASSEncodeStats,System.String)"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)"/>.
            When a proxy server is used, it needs to support the HTTP 'CONNECT' method. The default setting is NULL (do not use a proxy). </para>
            <para>Changes take effect from the next internet stream creation call. By default, BASSenc will not use any proxy settings when connecting to Icecast and Shoutcast.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_COMPACT">
            <summary>
            BASSMIDI add-on: Automatically compact all soundfonts following a configuration change?
            <para>compact (bool): If <see langword="true"/>, all soundfonts are compacted following a MIDI stream being freed, or a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> call.</para>
            <para>The compacting isn't performed immediately upon a MIDI stream being freed or <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamSetFonts(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_FONT[],System.Int32)"/> being called. It's actually done 2 seconds later (in another thread), so that if another MIDI stream starts using the soundfonts in the meantime, they aren't needlessly closed and reopened.</para>
            <para>Samples that have been preloaded by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_FontLoad(System.Int32,System.Int32,System.Int32)"/> are not affected by automatic compacting. Other samples that have been preloaded by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamLoadSamples(System.Int32)"/> are affected though, so it is probably wise to disable this option when using that function.</para>
            <para>By default, this option is enabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_VOICES">
            <summary>
            BASSMIDI add-on: The maximum number of samples to play at a time (polyphony).
            <para>voices (int): Maximum number of samples to play at a time... 1 (min) - 1000 (max).</para>
            <para>This setting determines the maximum number of samples that can play together in a single MIDI stream. This isn't necessarily the same thing as the maximum number of notes, due to presets often layering multiple samples. When there are no voices available to play a new sample, the voice with the lowest volume will be killed to make way for it.</para>
            <para>The more voices that are used, the more CPU that is required. So this option can be used to restrict that, for example on a less powerful system. The CPU usage of a MIDI stream can also be restricted via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CPU"/> attribute.</para>
            <para>Changing this setting only affects subsequently created MIDI streams, not any that have already been created. The default setting is 128 voices.</para>
            <para>Platform-specific</para>
            <para>The default setting is 100, except on iOS, where it is 40.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_AUTOFONT">
            <summary>
            BASSMIDI add-on: Automatically load matching soundfonts?
            <para>autofont (bool): If <see langword="true"/>, BASSMIDI will try to load a soundfont matching the MIDI file.</para>
            <para>This option only applies to local MIDI files, loaded using <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag,System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> via the plugin system). BASSMIDI won't look for matching soundfonts for MIDI files loaded from the internet.</para>
            <para>By default, this option is enabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_DEFFONT">
            <summary>
            BASSMIDI add-on: Default soundfont usage
            <para>filename (string): Filename of the default soundfont to use (<see langword="null"/> = no default soundfont).</para>
            <para>When setting the default soundfont, a copy is made of the filename, so it does not need to persist beyond the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfigPtr(Un4seen.Bass.BASSConfig,System.IntPtr)"/> call. If the specified soundfont cannot be loaded, the default soundfont setting will remain as it is. <see cref="M:Un4seen.Bass.Bass.BASS_GetConfigPtr(Un4seen.Bass.BASSConfig)"/> can be used to confirm what that is.</para>
            <para>On Windows, the default is to use one of the Creative soundfonts (28MBGM.SF2 or CT8MGM.SF2 or CT4MGM.SF2 or CT2MGM.SF2), if present in the windows system directory.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_IN_PORTS">
            <summary>
            BASSMIDI add-on: The number of MIDI input ports to make available
            <para>ports (int): Number of input ports... 0 (min) - 10 (max).</para>
            <para>MIDI input ports allow MIDI data to be received from other software, not only MIDI devices. Once a port has been initialized via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InInit(System.Int32,Un4seen.Bass.AddOn.Midi.MIDIINPROC,System.IntPtr)"/>, the ALSA client and port IDs can be retrieved from <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_InGetDeviceInfo(System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_DEVICEINFO)"/>, which other software can use to connect to the port and send data to it. Prior to initialization, an input port will have a client ID of 0.</para>
            <para>The default is for 1 input port to be available. Note: This option is only available on Linux.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_FILTER">
            <summary>
            BASSmix add-on: The order of filter used to reduce aliasing (only available/used pre BASSmix 2.4.7, where BASS_CONFIG_SRC is used).
            <para>order (int): The filter order... 2 (min) to 50 (max), and even. If the value specified is outside this range, it is automatically capped.</para>
            <para>The filter order determines how abruptly the level drops at the cutoff frequency, or the roll-off. The levels rolls off at 6 dB per octave for each order. For example, a 4th order filter will roll-off at 24 dB per octave. A low order filter may result in some aliasing persisting, and sounds close to the cutoff frequency being attenuated. 
            Higher orders reduce those things, but require more processing.</para>
            <para>By default, a 4th order filter is used. Changes only affect channels that are subsequently plugged into a mixer, not those that are already plugged in.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_BUFFER">
            <summary>
            BASSmix add-on: The source channel buffer size multiplier.
            <para>multiple (int): The buffer size multiplier... 1 (min) to 5 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>When a source channel has buffering enabled, the mixer will buffer the decoded data, so that it is available to the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/> functions. 
            To reach the source channel's buffer size, the multiplier (multiple) is applied to the BASS_CONFIG_BUFFER setting at the time of the mixer's creation. If the source is played at it's default rate, then the buffer only need to be as big as the mixer's buffer. 
            But if it's played at a faster rate, then the buffer needs to be bigger for it to contain the data that is currently being heard from the mixer. For example, playing a channel at 2x its normal speed would require the buffer to be 2x the normal size (multiple = 2).</para>
            <para>Larger buffers obviously require more memory, so the multiplier should not be set higher than necessary.</para>
            <para>The default multiplier is 2x. Changes only affect subsequently setup channel buffers. An existing channel can have its buffer reinitilized by disabling and then re-enabling the BASS_MIXER_BUFFER flag using <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIXER_POSEX">
            <summary>
            BASSmix add-on: How far back to keep record of source positions to make available for <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPositionEx(System.Int32,Un4seen.Bass.BASSMode,System.Int32)"/>.
            <para>length (int): The length of time to back, in milliseconds.</para>
            <para>If a mixer is not a decoding channel (not using the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag), this config setting will just be a minimum and the mixer will always have a position record at least equal to its playback buffer length, as determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option.</para>
            <para>The default setting is 2000ms. Changes only affect newly created mixers, not any that already exist.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SPLIT_BUFFER">
            <summary>
            BASSmix add-on: The splitter buffer length.
            <para>length (int): The buffer length in milliseconds... 100 (min) to 5000 (max). If the value specified is outside this range, it is automatically capped.</para>
            <para>When a source has its first splitter stream created, a buffer is allocated for its sample data, which all of its subsequently created splitter streams will share. This config option determines how big that buffer is. The default is 2000ms.</para>
            <para>The buffer will always be kept as empty as possible, so its size does not necessarily affect latency; it just determines how far splitter streams can drift apart before there are buffer overflow issues for those left behind.</para>
            <para>Changes do not affect buffers that have already been allocated; any sources that have already had splitter streams created will continue to use their existing buffers.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MP4_VIDEO">
            <summary>
            BASSaac add-on: play audio from mp4 (video) files?
            <para>playmp4 (bool): If <see langword="true"/> (default) BASSaac will play the audio from mp4 video files. If <see langword="false"/> mp4 video files will not be played.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_AAC_PRESCAN">
            <summary>
            BASSaac add-on: pre-scan ADTS AAC files for seek points and accurate length
            <para>prescan (bool): If <see langword="true"/> (default) BASSaac will prescan ADTS AAC files. If <see langword="false"/> prescan is disabled.</para>
            <para>If prescan is disabled, the BASS_STREAM_PRESCAN flag can be used to override that.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_AAC_MP4">
            <summary>
            BASSaac add-on: Support MP4 in BASS_AAC_StreamCreateXXX functions?
            <para>usemp4 (bool): If <see langword="true"/> BASSaac supports MP4 in the BASS_AAC_StreamCreateXXX functions. If <see langword="false"/> (default) only AAC is supported.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_WINAMP_INPUT_TIMEOUT">
            <summary>
            BASSWinamp add-on: Winamp input timeout.
            <para>timeout (int): The time (in milliseconds) to wait until timing out, because the plugin is not using the output system.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_FREQ">
            <summary>
            BASSdsd add-on: the default sample rate when converting to PCM.
            <para>freq (int): the sample rate.</para>
            <para>This setting determines what sample rate is used by default when converting to PCM. The rate actually used may be different if the specified rate is not valid for a particular DSD rate, in which case it will be rounded up (or down if there are none higher) to the nearest valid rate; the valid rates are 1/8, 1/16, 1/32, etc. of the DSD rate down to a minimum of 44100 Hz.</para>
            <para>The default setting is 88200 Hz. Changes only affect subsequently created streams, not any that already exist.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_GAIN">
            <summary>
            BASSdsd add-on: the default gain applied when converting to PCM.
            <para>gain (int): the gain in decibels.</para>
            <para>This setting determines what gain is applied by default when converting to PCM. Changes only affect subsequently created streams, not any that already exist. An existing stream's gain can be changed via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_GAIN"/> attribute.</para>
            <para>The default setting is 6dB.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSDeviceInfo">
            <summary>
            BASS_DEVICEINFO flags to be used with <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_NONE">
            <summary>
            The device is not enabled and not initialized.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_ENABLED">
            <summary>
            The device is enabled. It will not be possible to initialize the device if this flag is not present.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_DEFAULT">
            <summary>
            The device is the system default.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_INIT">
            <summary>
            The device is initialized, ie. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has been called.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_LOOPBACK">
            <summary>
            The device is a loopback device.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_INPUT">
            <summary>
            The device is an input (capture) device.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_UNPLUGGED">
            <summary>
            The device is unplugged.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_DISABLED">
            <summary>
            The device is disabled.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICES_AIRPLAY">
            <summary>
            Flag: Used in the device paramater to enumerate Airplay receivers instead of soundcards.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_NETWORK">
            <summary>
            An audio endpoint device that the user accesses remotely through a network.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_SPEAKERS">
            <summary>
            A set of speakers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_LINE">
            <summary>
            An audio endpoint device that sends a line-level analog signal to a line-input jack on an audio adapter or that receives a line-level analog signal from a line-output jack on the adapter.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_HEADPHONES">
            <summary>
            A set of headphones.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_MICROPHONE">
            <summary>
            A microphone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_HEADSET">
            <summary>
            An earphone or a pair of earphones with an attached mouthpiece for two-way communication.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_HANDSET">
            <summary>
            The part of a telephone that is held in the hand and that contains a speaker and a microphone for two-way communication.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_DIGITAL">
            <summary>
            An audio endpoint device that connects to an audio adapter through a connector for a digital interface of unknown type.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_SPDIF">
            <summary>
            An audio endpoint device that connects to an audio adapter through a Sony/Philips Digital Interface (S/PDIF) connector.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_HDMI">
            <summary>
            An audio endpoint device that connects to an audio adapter through a High-Definition Multimedia Interface (HDMI) connector.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_DISPLAYPORT">
            <summary>
            An audio endpoint device that connects to an audio adapter through a DisplayPort connector.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSDeviceInfo.BASS_DEVICE_TYPE_MASK">
            <summary>
            Bitmask to identify the device type.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInfo">
            <summary>
            BASS_INFO flags to be used with <see cref="T:Un4seen.Bass.BASS_INFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_NONE">
            <summary>
            Non of the falgs are set
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_CONTINUOUSRATE">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_EMULDRIVER">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated. Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_CERTIFIED">
            <summary>
            The device driver has been certified by Microsoft. This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARYMONO">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARYSTEREO">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARY8BIT">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInfo.DSCAPS_SECONDARY16BIT">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSRecordInfo">
            <summary>
            BASS_RECORDINFO flags to be used with <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordInfo.DSCAPS_NONE">
            <summary>
            Non of the flags is set
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordInfo.DSCAPS_EMULDRIVER">
            <summary>
            The device's drivers do NOT have DirectSound support, so it is being emulated. Updated drivers should be installed.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordInfo.DSCAPS_CERTIFIED">
            <summary>
            The device driver has been certified by Microsoft. This flag is always set on WDM drivers.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSRecordFormat">
            <summary>
            Formats flags of BASS_RECORDINFO.formats member to be used with <see cref="T:Un4seen.Bass.BASS_RECORDINFO"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_UNKNOWN">
            <summary>
            unknown format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1M08">
            <summary>
            11.025 kHz, Mono,   8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1S08">
            <summary>
            11.025 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1M16">
            <summary>
            11.025 kHz, Mono,   16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_1S16">
            <summary>
            11.025 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2M08">
            <summary>
            22.05  kHz, Mono,   8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2S08">
            <summary>
            22.05  kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2M16">
            <summary>
            22.05  kHz, Mono,   16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_2S16">
            <summary>
            22.05  kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4M08">
            <summary>
            44.1   kHz, Mono,   8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4S08">
            <summary>
            44.1   kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4M16">
            <summary>
            44.1   kHz, Mono,   16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_4S16">
            <summary>
            44.1   kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48M08">
            <summary>
            48 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48S08">
            <summary>
            48 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48M16">
            <summary>
            48 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_48S16">
            <summary>
            48 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96M08">
            <summary>
            96 kHz, Mono, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96S08">
            <summary>
            96 kHz, Stereo, 8-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96M16">
            <summary>
            96 kHz, Mono, 16-bit
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSRecordFormat.WAVE_FORMAT_96S16">
            <summary>
            96 kHz, Stereo, 16-bit
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS3DMode">
            <summary>
            3D Channel Mode flags to be used with e.g. <see cref="T:Un4seen.Bass.BASS_SAMPLE"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_LEAVECURRENT">
            <summary>
            To be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DAttributes(System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Int32)"/> in order to leave the current 3D processing mode unchanged.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_NORMAL">
            <summary>
            normal 3D processing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_RELATIVE">
            <summary>
            The channel's 3D position (position/velocity/orientation) are relative to the listener. 
            <para>When the listener's position/velocity/orientation is changed with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, the channel's position relative to the listener does not change.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DMode.BASS_3DMODE_OFF">
            <summary>
            Turn off 3D processing on the channel, the sound will be played in the center.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSMode">
            <summary>
            Channel Position Mode flags to be used with e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_BYTE">
            <summary>
            Byte position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_BYTES">
            <summary>
            Byte position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_MUSIC_ORDERS">
            <summary>
            Order.Row position (HMUSIC only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_MIDI_TICK">
            <summary>
            Tick position (MIDI streams only).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_OGG">
            <summary>
            OGG bitstream number.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_RESET">
            <summary>
            Flag: Reset user file buffers. This allows a user file stream with the BASS_STREAM_BLOCK flag set to be reset, so that it is ready to process new data. 
            This flag can only be used with the BASS_POS_BYTE mode, and pos must be 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_RELATIVE">
            <summary>
            Flag: The requested position is relative to the current position. pos is treated as signed in this case and can be negative.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_INEXACT">
            <summary>
            Flag: Allow inexact seeking. For speed, seeking may stop at the beginning of a block rather than partially processing the block to reach the requested position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MUSIC_POSRESET">
            <summary>
            MOD Music Flag: Stop all notes when moving position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MUSIC_POSRESETEX">
            <summary>
            MOD Music Flag: Stop all notes and reset bmp/etc when moving position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MIXER_NORAMPIN">
            <summary>
            Mixer Flag: Don't ramp-in the start after seeking.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_MIXER_RESET">
            <summary>
            Mixer Flag: Clear mixer's playback buffer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_DECODE">
            <summary>
            Get the decoding (not playing) position.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_DECODETO">
            <summary>
            Flag: decode to the position instead of seeking.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_POS_SCAN">
            <summary>
            Flag: Scan the file to build a seek table up to the position, if it has not already been scanned.
            <para>Scanning will continue from where it left off previously rather than restarting from the beginning of the file each time. 
            This flag only applies to MP3/MP2/MP1 files and will be ignored with other file formats.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSMode.BASS_MIDI_DECAYSEEK">
            <summary>
            Midi Add-On: Let the old sound decay naturally (including reverb) when changing the position, including looping and such can also be used in <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> calls to have it apply to particular position changes.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSLevel">
            <summary>
            Level retrieval flags (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSLevel.BASS_LEVEL_ALL">
            <summary>
            Retrieves mono levels
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSLevel.BASS_LEVEL_MONO">
            <summary>
            Retrieves mono levels
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSLevel.BASS_LEVEL_STEREO">
            <summary>
            Retrieves stereo levels
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSLevel.BASS_LEVEL_RMS">
            <summary>
            Optional Flag: If set it returns RMS levels instead of peak leavels
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSLevel.BASS_LEVEL_VOLPAN">
            <summary>
            Volume and Panning attribute affected level retrieval
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS3DAlgorithm">
            <summary>
            Software 3D mixing algorithm modes to be used with <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/> using the BASS_CONFIG_3DALGORITHM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_DEFAULT">
            <summary>
            Default algorithm (currently translates to BASS_3DALG_OFF)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_OFF">
            <summary>
            Uses normal left and right panning. The vertical axis is ignored except for scaling of volume due to distance. 
            <para>Doppler shift and volume scaling are still applied, but the 3D filtering is not performed. 
            This is the most CPU efficient software implementation, but provides no virtual 3D audio effect. 
            Head Related Transfer Function processing will not be done. 
            Since only normal stereo panning is used, a channel using this algorithm may be accelerated by a 2D hardware voice if no free 3D hardware voices are available.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_FULL">
            <summary>
            This algorithm gives the highest quality 3D audio effect, but uses more CPU.
            <para>Requires Windows 98 2nd Edition or Windows 2000 that uses WDM drivers, if this mode is not available then BASS_3DALG_OFF will be used instead.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS3DAlgorithm.BASS_3DALG_LIGHT">
            <summary>
            This algorithm gives a good 3D audio effect, and uses less CPU than the FULL mode. 
            <para>Requires Windows 98 2nd Edition or Windows 2000 that uses WDM drivers, if this mode is not available then BASS_3DALG_OFF will be used instead.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSStreamProc">
            <summary>
            STREAMPROC flag used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> resp. used with a user sample stream to be used with <see cref="T:Un4seen.Bass.STREAMPROC"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamProc.STREAMPROC_DUMMY">
            <summary>
            Create a "dummy" stream.
            <para>A dummy stream doesn't have any sample data of its own, but a decoding dummy stream (with BASS_STREAM_DECODE flag) can be used to apply DSP/FX processing to any sample data, 
            by setting DSP/FX on the stream and feeding the data through <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. 
            The dummy stream should have the same sample format as the data being fed through it.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamProc.STREAMPROC_PUSH">
            <summary>
            Create a "push" stream.
            <para>Instead of BASS pulling data from a STREAMPROC function, data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamProc.BASS_STREAMPROC_END">
            <summary>
            Flag to signify that the end of the stream is reached.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSStreamSystem">
            <summary>
            User file system flag to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_NOBUFFER">
            <summary>
            Unbuffered file system (like also used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>).
            <para>The unbuffered file system is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>. In this system, BASS does not do any intermediate buffering - 
            it simply requests data from the file as and when it needs it. This means that reading (<see cref="T:Un4seen.Bass.FILEREADPROC"/>) must be quick, 
            otherwise the decoding will be delayed and playback buffer underruns (old data repeated) are a possibility. 
            It's not so important for seeking (<see cref="T:Un4seen.Bass.FILESEEKPROC"/>) to be fast, as that is generally not required during decoding, except when looping a file.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_BUFFER">
            <summary>
            Buffered file system (like also used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>).
            <para>The buffered file system is what is used by <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>. 
            As the name suggests, data from the file is buffered so that it's readily available for decoding - 
            BASS creates a thread dedicated to "downloading" the data. This is ideal for when the data is coming from a source that has high latency, like the internet. 
            It's not possible to seek in buffered file streams, until the download has reached the requested position - it's not possible to seek at all if it's being streamed in blocks.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamSystem.STREAMFILE_BUFFERPUSH">
            <summary>
            Buffered, with the data pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>.
            <para>The push buffered file system is the same as STREAMFILE_BUFFER, except that instead of the file data being pulled from the <see cref="T:Un4seen.Bass.FILEREADPROC"/> function in a "download" thread, 
            the data is pushed to BASS via <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutFileData(System.Int32,System.IntPtr,System.Int32)"/>. A <see cref="T:Un4seen.Bass.FILEREADPROC"/> function is still required, to get the initial data used in the creation of the stream.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSStreamFilePosition">
            <summary>
            Stream File Position modes to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_CURRENT">
            <summary>
            Position that is to be decoded for playback next. This will be a bit ahead of the position actually being heard due to buffering.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_DOWNLOAD">
            <summary>
            Download progress of an internet file stream or "buffered" user file stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_END">
            <summary>
            End of the file, in other words the file length. When streaming in blocks, the file length is unknown, so the download buffer length is returned instead.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_START">
            <summary>
            Start of stream data in the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_CONNECTED">
            <summary>
            Internet file stream or "buffered" user file stream is still connected? 0 = no, 1 = yes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_BUFFER">
            <summary>
            The amount of data in the buffer of an internet file stream or "buffered" user file stream. 
            <para>Unless streaming in blocks, this is the same as BASS_FILEPOS_DOWNLOAD.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_SOCKET">
            <summary>
            Returns the socket hanlde used for streaming.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_ASYNCBUF">
            <summary>
            The amount of data in the asynchronous file reading buffer. This requires that the BASS_ASYNCFILE flag was used at the stream's creation.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_SIZE">
            <summary>
            Total size of the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_BUFFERING">
            <summary>
            The percentage of buffering remaining before playback of an internet file stream or "buffered" user file stream can resume
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_WMA_BUFFER">
            <summary>
            WMA add-on: internet buffering progress (0-100%)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSStreamFilePosition.BASS_FILEPOS_HLS_SEGMENT">
            <summary>
            HLS add-on: segment sequence number
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSVam">
            <summary>
            Voice allocation management flags.
            These flags enable hardware resource stealing... if the hardware has no	available voices, a currently playing buffer will be stopped to make room for the new buffer. 
            </summary>
            <remarks>
            NOTE: only samples loaded/created with the BASS_SAMPLE_VAM flag are considered for termination by the DX7 voice management.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_HARDWARE">
            <summary>
            Play the sample in hardware. If no hardware voices are available then the "play" call will fail
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_SOFTWARE">
            <summary>
            Play the sample in software (ie. non-accelerated). No other VAM flags may be used together with this flag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_TERM_TIME">
            <summary>
            If there are no free hardware voices, the buffer to be terminated will be the one with the least time left to play.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_TERM_DIST">
            <summary>
            If there are no free hardware voices, the buffer to be terminated will be one that was loaded/created with the BASS_SAMPLE_MUTEMAX flag and is beyond it's max distance. 
            If there are no buffers that match this criteria, then the "play" call will fail.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSVam.BASS_VAM_TERM_PRIO">
            <summary>
            If there are no free hardware voices, the buffer to be terminated will be the one with the lowest priority.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSFlag">
            <summary>
            Stream/Sample/Music/Recording/BASS_FX create flags to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleCreate(System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_SampleLoad(System.String,System.Int64,System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="T:Un4seen.Bass.BASS_SAMPLE"/>,
            <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/> and 
            <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_ReverseCreate(System.Int32,System.Single,Un4seen.Bass.BASSFlag)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_DecodeGet(System.Int32,System.Double,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,Un4seen.Bass.AddOn.Fx.BPMPROGRESSPROC,System.IntPtr)"/>, <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_BPM_CallbackSet(System.Int32,Un4seen.Bass.AddOn.Fx.BPMPROC,System.Double,System.Int32,Un4seen.Bass.AddOn.Fx.BASSFXBpm,System.IntPtr)"/> etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_DEFAULT">
            <summary>
            0 = default create stream: 16 Bit, stereo, no Float, hardware mixing, no Loop, no 3D, no speaker assignments...
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS">
            <summary>
            Use 8-bit resolution. If neither this or the BASS_SAMPLE_FLOAT flags are specified, then the stream is 16-bit. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_MONO">
            <summary>
            Decode/play the stream (MP3/MP2/MP1 only) in mono, reducing the CPU usage (if it was originally stereo).
            <para>This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_LOOP">
            <summary>
            Loop the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_3D">
            <summary>
            Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 
            <para>3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_SOFTWARE">
            <summary>
            Force the stream to not use hardware mixing.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_MUTEMAX">
            <summary>
            Sample: muted at max distance (3D only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_VAM">
            <summary>
            Sample: uses the DX7 voice allocation &amp; management
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FX">
            <summary>
            Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details.
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream. Requires DirectX 8 or above.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT">
            <summary>
            Use 32-bit floating-point sample data (see <a href="../Overview.html#FloatingPoint">Floating-Point Channels</a> for details). WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_RECORD_PAUSE">
            <summary>
            Recording: Start the recording paused. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> to start it.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_RECORD_ECHOCANCEL">
            <summary>
            Recording: enable echo cancellation (only available on certain devices, like iOS).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_RECORD_AGC">
            <summary>
            Recording: enabled automatic gain control (only available on certain devices, like iOS).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_PRESCAN">
            <summary>
            Enable pin-point accurate seeking (to the exact byte) on the MP3/MP2/MP1 stream.
            <para>This also increases the time taken to create the stream, due to the entire file being pre-scanned for the seek points.
            Note: BASS_STREAM_PRESCAN is ONLY needed for files with a VBR, files with a CBR are always accurate.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_AUTOFREE">
            <summary>
            Automatically free the stream's resources when it has reached the end, or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_RESTRATE">
            <summary>
            Restrict the download rate of the file to the rate required to sustain playback.
            <para>If this flag is not used, then the file will be downloaded as quickly as possible.
            This flag has no effect on "unbuffered" streams (buffer=<see langword="false"/>).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_BLOCK">
            <summary>
            Download and play the file in smaller chunks.
            <para>Uses a lot less memory than otherwise, but it's not possible to seek or loop the stream - once it's ended, the file must be opened again to play it again. 
            This flag will automatically be applied when the file length is unknown. 
            This flag also has the effect of resticting the download rate. 
            This flag has no effect on "unbuffered" streams (buffer=<see langword="false"/>).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE">
            <summary>
            Decode the sample data, without outputting it. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. 
            <para>BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are all ignored when using this flag, as are the SPEAKER flags.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_STREAM_STATUS">
            <summary>
            Pass status info (HTTP/ICY tags) from the server to the DOWNLOADPROC callback during connection. 
            <para>This can be useful to determine the reason for a failure.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_FRONT">
            <summary>
            Front speakers (channel 1/2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR">
            <summary>
            Rear/Side speakers (channel 3/4)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_CENLFE">
            <summary>
            Center &amp; LFE speakers (5.1, channel 5/6)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR2">
            <summary>
            Rear Center speakers (7.1, channel 7/8)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_LEFT">
            <summary>
            Speaker Modifier: left channel only
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_RIGHT">
            <summary>
            Speaker Modifier: right channel only
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_FRONTLEFT">
            <summary>
            Front Left speaker only (channel 1)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_FRONTRIGHT">
            <summary>
            Front Right speaker only (channel 2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REARLEFT">
            <summary>
            Rear/Side Left speaker only (channel 3)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REARRIGHT">
            <summary>
            Rear/Side Right speaker only (channel 4)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_CENTER">
            <summary>
            Center speaker only (5.1, channel 5)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_LFE">
            <summary>
            LFE speaker only (5.1, channel 6)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR2LEFT">
            <summary>
            Rear Center Left speaker only (7.1, channel 7)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_REAR2RIGHT">
            <summary>
            Rear Center Right speaker only (7.1, channel 8)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR1">
            <summary>
            speakers Pair 1
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR2">
            <summary>
            speakers Pair 2
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR3">
            <summary>
            speakers Pair 3
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR4">
            <summary>
            speakers Pair 4
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR5">
            <summary>
            speakers Pair 5
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR6">
            <summary>
            Speakers Pair 6
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR7">
            <summary>
            Speakers Pair 7
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR8">
            <summary>
            Speakers Pair 8
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR9">
            <summary>
            Speakers Pair 9
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR10">
            <summary>
            Speakers Pair 10
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR11">
            <summary>
            Speakers Pair 11
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR12">
            <summary>
            Speakers Pair 12
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR13">
            <summary>
            Speakers Pair 13
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR14">
            <summary>
            Speakers Pair 14
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPEAKER_PAIR15">
            <summary>
            Speakers Pair 15
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_ASYNCFILE">
            <summary>
            Use an async look-ahead cache.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_UNICODE">
            <summary>
            File is a Unicode (16-bit characters) filename
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_OVER_VOL">
            <summary>
            Sample: override lowest volume
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_OVER_POS">
            <summary>
            Sample: override longest playing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_OVER_DIST">
            <summary>
            Sample: override furthest from listener (3D only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_WV_STEREO">
            <summary>
            BASSWV add-on: limit to stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DOWNMIX_2">
            <summary>
            BASS_AC3 add-on: downmix to stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DOWNMIX_4">
            <summary>
            BASS_AC3 add-on: downmix to quad
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_DSD_RAW">
            <summary>
            BASSdsd add-on: Produce raw DSD data instead of PCM. The DSD data is in blocks of 8 bits (1 byte) per-channel with the MSB being first/oldest. 
            DSD data is not playable by BASS, so the BASS_STREAM_DECODE flag is required.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_DSD_DOP">
            <summary>
            BASSdsd add-on: Produce DSD-over-PCM data (with 0x05/0xFA markers). DSD-over-PCM data is 24-bit, so the BASS_SAMPLE_FLOAT flag is required.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DOWNMIX_DOLBY">
            <summary>
            BASS_AC3 add-on: downmix to dolby
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AC3_DYNAMIC_RANGE">
            <summary>
            BASS_AC3 add-on: enable dynamic range compression
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AAC_FRAME960">
            <summary>
            BASS_AAC add-on: use 960 samples per frame
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_AAC_STEREO">
            <summary>
            BASS_AAC add-on: downmatrix to stereo
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_END">
            <summary>
            BASSmix add-on: end the stream when there are no sources
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_PAUSE">
            <summary>
            BASSmix add-on: don't process the source
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_NONSTOP">
            <summary>
            BASSmix add-on: don't stall when there are no sources
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_RESUME">
            <summary>
            BASSmix add-on: resume a stalled mixer immediately upon new/unpaused source
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_POSEX">
            <summary>
            BASSmix add-on: enable <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPositionEx(System.Int32,Un4seen.Bass.BASSMode,System.Int32)"/> support.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_LIMIT">
            <summary>
            BASSmix add-on: Limit mixer processing to the amount available from this source.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_MATRIX">
            <summary>
            BASSmix add-on: Matrix mixing
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_DOWNMIX">
            <summary>
            BASSmix add-on: downmix to stereo (or mono if mixer is mono)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_NORAMPIN">
            <summary>
            BASSmix add-on: don't ramp-in the start
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPLIT_SLAVE">
            <summary>
            BASSmix add-on: only read buffered data.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIXER_BUFFER">
            <summary>
            BASSmix add-on: buffer source data for <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_SPLIT_POS">
            <summary>
            BASSmix add-on: The splitter's length and position is based on the splitter's (rather than the source's) channel count.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_CD_SUBCHANNEL">
            <summary>
            BASSCD add-on: Read sub-channel data. 96 bytes of de-interleaved sub-channel data will be returned after each 2352 bytes of audio. This flag can not be used with the BASS_SAMPLE_FLOAT flag, and is ignored if the BASS_STREAM_DECODE flag is not used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_CD_SUBCHANNEL_NOHW">
            <summary>
            BASSCD add-on: Read sub-channel data, without using any hardware de-interleaving. This is identical to the BASS_CD_SUBCHANNEL flag, except that the de-interleaving is always performed by BASSCD even if the drive is apparently capable of de-interleaving itself.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_CD_C2ERRORS">
            <summary>
            BASSCD add-on: Include C2 error info. 296 bytes of C2 error info is returned after each 2352 bytes of audio (and optionally 96 bytes of sub-channel data).
            This flag cannot be used with the BASS_SAMPLE_FLOAT flag, and is ignored if the BASS_STREAM_DECODE flag is not used.
            <para>The first 294 bytes contain the C2 error bits (one bit for each byte of audio), followed by a byte containing the logical OR of all 294 bytes, 
            which can be used to quickly check if there were any C2 errors. The final byte is just padding.</para>
            <para>Note that if you request both sub-channel data and C2 error info, the C2 info will come before the sub-channel data!</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_NOSYSRESET">
            <summary>
            BASSMIDI add-on: Ignore system reset events (MIDI_EVENT_SYSTEM) when the system mode is unchanged. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_DECAYEND">
            <summary>
            BASSMIDI add-on: Let the sound decay naturally (including reverb) instead of stopping it abruptly at the end of the file. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_NOFX">
            <summary>
            BASSMIDI add-on: Disable the MIDI reverb/chorus processing. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_DECAYSEEK">
            <summary>
            BASSMIDI add-on: Let the old sound decay naturally (including reverb) when changing the position, including looping. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>, and can also be used in <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> calls to have it apply to particular position changes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_NOCROP">
            <summary>
            BASSMIDI add-on: Do not remove empty space (containing no events) from the end of the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_NOTEOFF1">
            <summary>
            BASSMIDI add-on: Only release the oldest instance upon a note off event (MIDI_EVENT_NOTE with velocity=0) when there are overlapping instances of the note. Otherwise all instances are released. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_SINCINTER">
            <summary>
            BASSMIDI add-on: Use sinc interpolated sample mixing. This increases the sound quality, but also requires more CPU. Otherwise linear interpolation is used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_FONT_MMAP">
            <summary>
            BASSMIDI add-on: Map the file into memory. This flag is ignored if the soundfont is packed as the sample data cannot be played directly from a mapping; it needs to be decoded. This flag is also ignored if the file is too large to be mapped into memory.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_FONT_XGDRUMS">
            <summary>
            BASSMIDI add-on: Use bank 127 in the soundfont for XG drum kits. 
            <para>When an XG drum kit is needed, bank 127 in soundfonts that have this flag set will be checked first, before falling back to bank 128 (the standard SF2 drum kit bank) if it is not available there.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_FONT_NOFX">
            <summary>
            BASSMIDI add-on: Ignore the soundfont's reverb and chorus settings.
            <para>If you would like to ignore the soundfont's reverb/chorus on only some presets/banks, then you can load 2 instances of it (one with BASS_MIDI_FONT_NOFX flag and one without), and then assign them as wanted in a BASS_MIDI_StreamSetFonts call. The 2 instances will share resources, so they won't really use any more memory than 1 instance.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_PACK_NOHEAD">
            <summary>
            BASSMIDI add-on: Don't send a WAVE header to the encoder. If this flag is used then the sample format (mono 16-bit) must be passed to the encoder some other way, eg. via the command-line.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MIDI_PACK_16BIT">
            <summary>
            BASSMIDI add-on: Reduce 24-bit sample data to 16-bit before encoding.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_FREESOURCE">
            <summary>
            BASS_FX add-on: Free the source handle as well?
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_BPM_BKGRND">
            <summary>
            BASS_FX add-on: If in use, then you can do other stuff while detection's in process.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_BPM_MULT2">
            <summary>
            BASS_FX add-on: If in use, then will auto multiply bpm by 2 (if BPM &lt; MinBPM*2)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_TEMPO_ALGO_LINEAR">
            <summary>
            BASS_FX add-on (AddOn.Fx.BassFx.BASS_FX_TempoCreate): Uses a linear interpolation mode (simple).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_TEMPO_ALGO_CUBIC">
            <summary>
            BASS_FX add-on (AddOn.Fx.BassFx.BASS_FX_TempoCreate): Uses a cubic interpolation mode (recommended, default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_FX_TEMPO_ALGO_SHANNON">
            <summary>
            BASS_FX add-on (AddOn.Fx.BassFx.BASS_FX_TempoCreate): Uses a 8-tap band-limited Shannon interpolation (complex, but not much better than cubic).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FLOAT">
            <summary>
            Music: Use 32-bit floating-point sample data (see <a href="../Overview.html#FloatingPoint">Floating-Point Channels</a> for details). WDM drivers or the BASS_STREAM_DECODE flag are required to use this flag. 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_MONO">
            <summary>
            Music: Decode/play the mod music in mono, reducing the CPU usage (if it was originally stereo).
            This flag is automatically applied if BASS_DEVICE_MONO was specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_LOOP">
            <summary>
            Music: Loop the music. This flag can be toggled at any time using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelFlags(System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASSFlag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_3D">
            <summary>
            Music: Use 3D functionality. This is ignored if BASS_DEVICE_3D wasn't specified when calling <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>. 
            <para>3D streams must be mono (chans=1). The SPEAKER flags can not be used together with this flag.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FX">
            <summary>
            Music: Enable the old implementation of DirectX 8 effects. See the <a href="../Overview.html#DX8DMOEffects">DX8 effect implementations</a> section for details.
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to add effects to the stream. Requires DirectX 8 or above.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_AUTOFREE">
            <summary>
            Music: Automatically free the music when it ends. This allows you to play a music and forget about it, as BASS will automatically free the music's resources when it has reached the end or when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> (or <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>) is called. 
            <para>Note that some musics never actually end on their own (ie. without you stopping them).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_DECODE">
            <summary>
            Music: Decode the music into sample data, without outputting it. 
            <para>Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to retrieve decoded sample data. 
            BASS_SAMPLE_SOFTWARE/3D/FX/AUTOFREE are ignored when using this flag, as are the SPEAKER flags.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_PRESCAN">
            <summary>
            Music: Calculate the playback length of the music, and enable seeking in bytes. This slightly increases the time taken to load the music, depending on how long it is. 
            <para>In the case of musics that loop, the length until the loop occurs is calculated. Use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> to retrieve the length.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_RAMP">
            <summary>
            Music: Use "normal" ramping (as used in FastTracker 2).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_RAMPS">
            <summary>
            Music: Use "sensitive" ramping.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_SURROUND">
            <summary>
            Music: Apply XMPlay's surround sound to the music (ignored in mono).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_SURROUND2">
            <summary>
            Music: Apply XMPlay's surround sound mode 2 to the music (ignored in mono).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FT2PAN">
            <summary>
            Music: Apply FastTracker 2 panning to XM files.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_FT2MOD">
            <summary>
            Music: Play .MOD file as FastTracker 2 would.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_PT1MOD">
            <summary>
            Music: Play .MOD file as ProTracker 1 would.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_NONINTER">
            <summary>
            Music: Use non-interpolated mixing. This generally reduces the sound quality, but can be good for chip-tunes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_SINCINTER">
            <summary>
             Music: Sinc interpolated sample mixing.
            This increases the sound quality, but also requires quite a bit more processing. If neither this or the BASS_MUSIC_NONINTER flag is specified, linear interpolation is used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_POSRESET">
            <summary>
            Music: Stop all notes when seeking (using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>). 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_POSRESETEX">
            <summary>
            Music: Stop all notes and reset bpm/etc when seeking.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_STOPBACK">
            <summary>
            Music: Stop the music when a backward jump effect is played. This stops musics that never reach the end from going into endless loops. 
            <para>Some MOD musics are designed to jump all over the place, so this flag would cause those to be stopped prematurely. 
            If this flag is used together with the BASS_SAMPLE_LOOP flag, then the music would not be stopped but any BASS_SYNC_END sync would be triggered.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFlag.BASS_MUSIC_NOSAMPLE">
            <summary>
            Music: Don't load the samples. This reduces the time taken to load the music, notably with MO3 files, which is useful if you just want to get the name and length of the music without playing it.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSChannelType">
            <summary>
            Channel Type flags to be used with <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> (see also <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/>)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_UNKNOWN">
            <summary>
            Unknown channel format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_SAMPLE">
            <summary>
            Sample channel. (HCHANNEL)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_RECORD">
            <summary>
            Recording channel. (HRECORD)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_MO3">
            <summary>
            MO3 format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM">
            <summary>
            User sample stream. This can also be used as a flag to test if the channel is any kind of HSTREAM.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_OGG">
            <summary>
            OGG format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP1">
            <summary>
            MP1 format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP2">
            <summary>
            MP2 format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP3">
            <summary>
            MP2 format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AIFF">
            <summary>
            WAV format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_CA">
            <summary>
            CoreAudio codec stream. Additional information is avaliable via the <see cref="T:Un4seen.Bass.BASS_TAG_CACODEC"/> tag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MF">
            <summary>
            Media Foundation codec stream. Additional information is avaliable via the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_MF"/> tag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AM">
            <summary>
            Android Foundation codec stream. Additional information is avaliable via the <see cref="!:BASSTag.BASS_TAG_AM_MINE"/> tag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_DUMMY">
            <summary>
            A "dummy" stream (using STREAMPROC_DUMMY). 
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_DEVICE">
            <summary>
            A "dummy" stream for device final output mix (using STREAMPROC_DEVICE).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MIXER">
            <summary>
            BASSmix mixer stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_SPLIT">
            <summary>
            BASSmix splitter stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV">
            <summary>
            WAV format stream, LOWORD=codec.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV_PCM">
            <summary>
            WAV format stream, PCM 16-bit.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV_FLOAT">
            <summary>
            WAV format stream, FLOAT 32-bit.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_MOD">
            <summary>
            MOD format music. This can also be used as a flag to test if the channel is any kind of HMUSIC.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_MTM">
            <summary>
            MTM format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_S3M">
            <summary>
            S3M format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_XM">
            <summary>
            XM format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_MUSIC_IT">
            <summary>
            IT format music.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV">
            <summary>
            WavPack Lossless format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV_H">
            <summary>
             WavPack Hybrid Lossless format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV_L">
            <summary>
            WavPack Lossy format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WV_LH">
            <summary>
             WavPack Hybrid Lossy format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_CD">
            <summary>
            Audio-CD, CDA
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WMA">
            <summary>
            WMA format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WMA_MP3">
            <summary>
            MP3 over WMA format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_FLAC">
            <summary>
            FLAC format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_FLAC_OGG">
            <summary>
            FLAC OGG format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_OFR">
            <summary>
            Optimfrog format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_APE">
            <summary>
            APE format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MPC">
            <summary>
            MPC format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AAC">
            <summary>
            AAC format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP4">
            <summary>
            MP4 format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_SPX">
            <summary>
            Speex format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_ALAC">
            <summary>
            Apple Lossless (ALAC) format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_TTA">
            <summary>
            TTA format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AC3">
            <summary>
            AC3 format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_OPUS">
            <summary>
            Opus format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WINAMP">
            <summary>
            Winamp input format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_DSD">
            <summary>
            Direct Stream Digital (DSD) format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MIDI">
            <summary>
            MIDI sound format stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_ADX">
            <summary>
            ADX format stream.
            <para>ADX is a lossy proprietary audio storage and compression format developed by CRI Middleware specifically for use in video games, it is derived from ADPCM.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AIX">
            <summary>
            AIX format stream.
            <para>Only for ADX of all versions (with AIXP support).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_TEMPO">
            <summary>
            BASS_FX tempo stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_REVERSE">
            <summary>
            BASS_FX reverse stream.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_VIDEO">
            <summary>
            Video format stream.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSData">
            <summary>
            Flags to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_AVAILABLE">
            <summary>
            Query how much data is buffered
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_INDIVIDUAL">
            <summary>
            FFT flag: FFT for each channel, else all combined
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_NOWINDOW">
            <summary>
            FFT flag: no Hanning window
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_REMOVEDC">
            <summary>
            FFT flag: pre-remove DC bias
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_COMPLEX">
            <summary>
            FFT flag: return complex data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT_NYQUIST">
            <summary>
            FFT flag: return extra Nyquist value
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FIXED">
            <summary>
            flag: return 8.24 fixed-point data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FLOAT">
            <summary>
            flag: return floating-point sample data
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT256">
            <summary>
            256 sample FFT (returns 128 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT512">
            <summary>
            512 sample FFT (returns 256 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT1024">
            <summary>
            1024 sample FFT (returns 512 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT2048">
            <summary>
            2048 sample FFT (returns 1024 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT4096">
            <summary>
            4096 sample FFT (returns 2048 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT8192">
            <summary>
            8192 sample FFT (returns 4096 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT16384">
            <summary>
            16384 sample FFT (returns 8192 floating-point values)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSData.BASS_DATA_FFT32768">
            <summary>
            32768 sample FFT (returns 16384 floating-point values)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSActive">
            <summary>
            <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> return values.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_STOPPED">
            <summary>
            The channel is not active, or handle is not a valid channel.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_PLAYING">
            <summary>
            The channel is playing (or recording).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_STALLED">
            <summary>
            Playback of the stream has been stalled due to there not being enough sample data to continue playing. The playback will automatically resume once there's sufficient data to do so.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_PAUSED">
            <summary>
            The channel is paused.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSActive.BASS_ACTIVE_PAUSED_DEVICE">
            <summary>
            The channel's device is paused.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInput">
            <summary>
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/> flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInput.BASS_INPUT_NONE">
            <summary>
            No input flag change.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInput.BASS_INPUT_OFF">
            <summary>
            Disable the input. This flag can't be used when the device supports only one input at a time.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInput.BASS_INPUT_ON">
            <summary>
            Enable the input. If the device only allows one input at a time, then any previously enabled input will be disabled by this.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSInputType">
            <summary>
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordSetInput(System.Int32,Un4seen.Bass.BASSInput,System.Single)"/> flags.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_ERROR">
            <summary>
            The type of input is errorness.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_MASK">
            <summary>
            The type of input is also indicated in the high 8-bits of <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInput(System.Int32,System.Single@)"/> (use BASS_INPUT_TYPE_MASK to test the return value).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_UNDEF">
            <summary>
            Anything that is not covered by the other types
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_DIGITAL">
            <summary>
            Digital input source, for example, a DAT or audio CD.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_LINE">
            <summary>
            Line-in. On some devices, "Line-in" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_MIC">
            <summary>
            Microphone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_SYNTH">
            <summary>
            Internal MIDI synthesizer.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_CD">
            <summary>
            Analog audio CD.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_PHONE">
            <summary>
            Telephone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_SPEAKER">
            <summary>
            PC speaker.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_WAVE">
            <summary>
            The device's WAVE/PCM output.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_AUX">
            <summary>
            Auxiliary. Like "Line-in", "Aux" may be combined with other analog sources into a single BASS_INPUT_TYPE_ANALOG input on some devices.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSInputType.BASS_INPUT_TYPE_ANALOG">
            <summary>
            Analog, typically a mix of all analog sources (what you hear).
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSTag">
            <summary>
            Types of what's returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_ID3">
            <summary>
            ID3v1 tags : A pointer to a 128 byte block is returned (see <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_ID3"/>).
            <para>See <a href="http://www.id3.org/id3v1.html">www.id3.org</a> for details of the block's structure.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_ID3V2">
            <summary>
            ID3v2 tags : A pointer to a variable length block is returned.
            <para>See <a href="http://www.id3.org">www.id3.org</a> for details of the block's structure.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_OGG">
            <summary>
            OGG comments : Only available when streaming an OGG file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_HTTP">
            <summary>
            HTTP headers : Only available when streaming from a HTTP server. A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_ICY">
            <summary>
            ICY headers : A pointer to a series of null-terminated ANSI strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_META">
            <summary>
            ICY (Shoutcast) metadata :  A single null-terminated ANSI string containing the current stream title and url (usually omitted). The format of the string is: StreamTitle='xxx';StreamUrl='xxx';
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_APE">
            <summary>
            APE (v1 or v2) tags : Only available when streaming an APE file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MP4">
            <summary>
            iTunes/MP4 metadata : Only available when streaming a MP4 file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_WMA">
            <summary>
            WMA header tags: WMA tags : Only available when streaming a WMA file. A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_VENDOR">
            <summary>
            OGG encoder : A single null-terminated UTF-8 string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_LYRICS3">
            <summary>
            Lyric3v2 tag : A single ANSI string is returned, containing the Lyrics3v2 information. See <a href="http://www.id3.org/Lyrics3v2">www.id3.org/Lyrics3v2</a> for details of its format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_WMA_META">
            <summary>
            WMA mid-stream tag: a single UTF-8 string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_CA_CODEC">
            <summary>
            Apple CoreAudio codec info : <see cref="T:Un4seen.Bass.BASS_TAG_CACODEC"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_CUE">
            <summary>
            FLAC cuesheet : <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_CUE"/> structure (which includes <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK"/> and <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK_INDEX"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_WMA_CODEC">
            <summary>
            WMA codec: A description of the codec used by the file. 2 null-terminated UTF-8 strings are returned, with the 1st string being the name of the codec, and the 2nd containing additional information like what VBR setting was used.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MF">
            <summary>
            Media Foundation tags :  A pointer to a series of null-terminated UTF-8 strings is returned, the final string ending with a double null.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_WAVEFORMAT">
            <summary>
            WAVE format : A pointer to a <see cref="!:WAVEFORMATEXT"/> structure is returned.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_AM_MIME">
            <summary>
            Android Media MIME type : ASCII string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_AM_NAME">
            <summary>
            Android Media codec name : ASCII string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_INFO">
            <summary>
            RIFF/WAVE tags : array of null-terminated ANSI strings.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_BEXT">
            <summary>
            BWF/RF64 tags (Broadcast Audio Extension) : A pointer to a variable length block is returned (see <see cref="T:Un4seen.Bass.BASS_TAG_BEXT"/>).
            <para>See the <a href="http://www.ebu.ch/CMSimages/en/tec_doc_t3285_tcm6-10544.pdf">EBU specification</a> for details of the block's structure.</para>
            <para>When reading BWF tags into a <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure e.g. via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> the following mapping is performed if no RIFF_INFO tags are present:</para>
            <para>Description = Title (max. 256 chars)</para>
            <para>Originator = Artist (max. 32 chars)</para>
            <para>OriginatorReference = EncodedBy (max. 32 chars)</para>
            <para>OriginationDate = Year (in format 'yyyy-mm-dd hh:mm:ss')</para>
            <para>TimeReference = Track</para>
            <para>UMID = Copyright (max. 64 chars)</para>
            <para>CodingHistory = Comment</para>
            <para>However, if RIFF_INFO tags are present the BWF tags are present in the NativeTags.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_CART">
            <summary>
            RIFF/BWF Radio Traffic Extension tags : A pointer to a variable length block is returned (see <see cref="T:Un4seen.Bass.BASS_TAG_CART"/>).
            <para>See the <a href="ftp://ftp.orban.com/Audicy/Cart_Chunk_AES46/">EBU specifications</a> for details of the block's structure.</para>
            <para>When reading BWF tags into a <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure e.g. via <see cref="M:Un4seen.Bass.AddOn.Tags.BassTags.BASS_TAG_GetFromFile(System.String)"/> the following mapping is performed if no RIFF_INFO tags are present:</para>
            <para>Title = Title (max. 64 chars)</para>
            <para>Artist = Artist (max. 64 chars)</para>
            <para>Category = Grouping (max. 64 chars)</para>
            <para>Classification = Mood (max. 64 chars)</para>
            <para>ProducerAppID = Publisher (max. 64 chars)</para>
            <para>ProducerAppVersion = EncodedBy (max. 64 chars)</para>
            <para>TagText = Comment</para>
            <para>However, if RIFF_INFO tags are present the CART tags are present in the NativeTags.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_DISP">
            <summary>
            RIFF DISP text chunk: a single ANSI string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_CUE">
            <summary>
            RIFF CUE chunk: see <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_SMPL">
            <summary>
            RIFF SMPL chunk: see <see cref="T:Un4seen.Bass.BASS_TAG_SMPL"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_APE_BINARY">
            <summary>
            + index# : <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_APE_BINARY"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_NAME">
            <summary>
            MOD music name : a single ANSI string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_MESSAGE">
            <summary>
            MOD message : a single ANSI string.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_ORDERS">
            <summary>
            MOD music order list: BYTE array of pattern numbers played at that order position.
            <para>Pattern number 254 is "+++" (skip order) and 255 is "---" (end song). You can use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLength(System.Int32,Un4seen.Bass.BASSMode)"/> with BASS_POS_MUSIC_ORDER to get the length of the array.
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_AUTH">
            <summary>
            MOD music author: UTF-8 string, only available in files created with the OpenMPT tracker.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_INST">
            <summary>
            + instrument#, MOD instrument name : ANSI string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MUSIC_SAMPLE">
            <summary>
            + sample#, MOD sample name : ANSI string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_MIDI_TRACK">
            <summary>
            + track#, track text : array of null-terminated ANSI strings
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_PICTURE">
            <summary>
            + index# : <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_PICTURE"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_ARTIST">
            <summary>
            DSDIFF artist : ASCII string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_TITLE">
            <summary>
            DSDIFF title : ASCII string
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_COMMENT">
            <summary>
            + index, DSDIFF comment : A pointer to the DSDIFF comment tag structure (see <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_COMMENT"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_HLS_EXTINF">
            <summary>
            HLS tags: segment's EXTINF tag, a single UTF-8 string
            </summary>
            <remarks>The current segment's EXTINF tag in the media playlist. A single UTF-8 string is returned, containing the duration of the segment and possibly a title too (separated by a comma). This will be updated every time a new segment begins downloading.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_HLS_STREAMINF">
            <summary>
            HLS tags: segment's EXT-X-STREAM-INF tag, a single UTF-8 string
            </summary>
            <remarks>The EXT-X-STREAM-INF tag from the master playlist for the media playlist that is being used. A single UTF-8 string is returned. This will only be available if a master playlist was opened, rather than a media playlist directly.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_HLS_DATE">
            <summary>
            HLS tags: segment's EXT-X-PROGRAM-DATE-TIME tag, a single UTF-8 string
            </summary>
            <remarks>The initial EXT-X-PROGRAM-DATE-TIME tag value in the media playlist. A single string is returned, containg the start date and time in ISO/IEC 8601:2004 form. This will not be updated with the value of any later EXT-X-PROGRAM-DATE-TIME tags that are received.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASSTag.BASS_TAG_UNKNOWN">
            <summary>
            Unknown tags : not supported tags
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSAttribute">
            <summary>
            Channel attribute options used by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single@)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_FREQ">
            <summary>
            The sample rate of a channel.
            <para>freq: The sample rate... 0 = original rate (when the channel was created).</para>
            <para>This attribute applies to playback of the channel, and does not affect the channel's sample data, so has no real effect on decoding channels. It is still adjustable though, so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix">BassMix</see> add-on, and anything else that wants to use it.</para>
            <para>It is not possible to change the sample rate of a channel if the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a> enabled on it, unless DirectX 9 or above is installed.</para>
            <para>Increasing the sample rate of a stream or MOD music increases its CPU usage, and reduces the length of its playback buffer in terms of time. If you intend to raise the sample rate above the original rate, then you may also need to increase the buffer length via the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to avoid break-ups in the sound.</para>
            <para>When using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/> to slide this attribute, the BASS_SLIDE_LOG flag can be used to make a slide logarithmic rather than linear.</para>
            <para><b>Platform-specific</b></para>
            <para>When using DirectSound output on Windows, the sample rate will get rounded down to a whole number during playback.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_VOL">
            <summary>
            The volume level of a channel.
            <para>volume: The volume level... 0 (silent) to 1 (full). This can go above 1.0 for amplification.</para>
            <para>This attribute applies to playback of the channel, and does not affect the channel's sample data, so has no real effect on decoding channels. It is still adjustable though, so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix">BassMix</see> add-on, and anything else that wants to use it.
            The BASS_FX_VOLUME effect can be used via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/> to change the level of a channel's sample data.</para>
            <para>When using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/> to slide this attribute, a negative volume value can be used to fade-out and then stop the channel.
            When the linear volume curve is in use, the BASS_SLIDE_LOG flag can also be used to make a slide logarithmic rather than linear.</para>
            <para>When using DirectSound output on Windows, amplification is not supported so this attribute will be limited to 1.0. On platforms/architectures without floating-point support (see BASS_CONFIG_FLOAT), amplification is limited to 16x.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_PAN">
            <summary>
            The panning/balance position of a channel.
            <para>pan: The pan position... -1 (full left) to +1 (full right), 0 = centre.</para>
            <para>This attribute applies to playback of the channel, and does not affect the channel's sample data, so has no real effect on decoding channels. It is still adjustable though, so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix">BassMix</see> add-on, and anything else that wants to use it.</para>
            <para>It is not possible to set the pan position of a 3D channel. It is also not possible to set the pan position when using <a href="../Overview.html#SpeakerAssignement">speaker assignment</a>, but if needed, it can be done via a <see cref="T:Un4seen.Bass.DSPPROC">DSP function</see> instead (not on mono channels).</para>
            <para><b>Platform-specific</b></para>
            <para>On Windows, this attribute has no effect when <a href="../Overview.html#SpeakerAssignement">speaker assignment</a> is used, except on Windows Vista and newer with the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_VISTA_SPEAKERS"/> config option enabled. Balance control could be implemented via a <see cref="T:Un4seen.Bass.DSPPROC">DSP function</see> instead</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_EAXMIX">
            <summary>
            The wet (reverb) / dry (no reverb) mix ratio on a sample, stream, or MOD music channel with 3D functionality.
            <para>mix: The wet / dry ratio... 0 (full dry) to 1 (full wet), -1 = automatically calculate the mix based on the distance (the default).</para>
            <para>Obviously, EAX functions have no effect if the output device does not support EAX. <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> can be used to check that. EAX only affects 3D channels, but EAX functions do not require <see cref="M:Un4seen.Bass.Bass.BASS_Apply3D"/> to apply the changes.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">Additional ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOEAX</term><description>The channel does not have EAX support. EAX only applies to 3D channels that are mixed by the hardware/drivers. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> can be used to check if a channel is being mixed by the hardware.</description></item>
            </list>
            </para>
            <para>EAX is only supported on Windows.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_NOBUFFER">
            <summary>
            Non-Windows: Disable playback buffering?
            <para>nobuffer: Disable playback buffering... 0 = no, else yes..</para>
            <para>A playing channel is normally asked to render data to its playback buffer in advance, via automatic buffer updates or the <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> functions, ready for mixing with other channels to produce the final mix that is given to the output device.
            When this attribute is switched on (the default is off), that buffering is skipped and the channel will only be asked to produce data as it is needed during the generation of the final mix. This allows the lowest latency to be achieved, but also imposes tighter timing requirements on the channel to produce its data and apply any DSP/FX (and run mixtime syncs) that are set on it; if too long is taken, there will be a break in the output, affecting all channels that are playing on the same device.</para>
            <para>The channel's data is still placed in its playback buffer when this attribute is on, which allows <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> to be used, although there is likely to be less data available to them due to the buffer being less full.</para>
            <para>This attribute can be changed mid-playback. If switched on, any already buffered data will still be played, so that there is no break in sound.</para>
            <para>This attribute is not available on Windows, as BASS does not generate the final mix.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_CPU">
            <summary>
            The CPU usage of a channel.
            <para>cpu: The CPU usage (in percentage).</para>
            <para>This attribute gives the percentage of CPU that the channel is using, including the time taken by decoding and DSP processing, and any FX that are not using the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effect implementation</a>. It does not include the time taken to add the channel's data to the final output mix during playback. The processing of some add-on stream formats may also not be entirely included, if they use additional decoding threads; see the add-on documentation for details.</para>
            <para>Like <see cref="M:Un4seen.Bass.Bass.BASS_GetCPU"/>, this function does not strictly tell the CPU usage, but rather how timely the processing is. For example, if it takes 10ms to generate 100ms of data, that would be 10%. If the reported usage exceeds 100%, that means the channel's data is taking longer to generate than to play. The duration of the data is based on the channel's current sample rate (<see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_FREQ"/>).</para>
            <para>A channel's CPU usage is updated whenever it generates data. That could be during a playback buffer update cycle, or a <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> call, or a <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> call. For a decoding channel, it would be in a <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> call.</para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SRC">
            <summary>
            The sample rate conversion quality of a channel.
            <para>quality: The sample rate conversion quality... 0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation, 3 = 32 point sinc interpolation, 4 = 64 point sinc interpolation. Other values are also accepted but will be interpreted as 0 or 4, depending on whether they are lower or higher.</para>
            <para>When a channel has a different sample rate to what the output device is using, the channel's sample data will need to be converted to match the output device's rate during playback. This attribute determines how that is done. The linear interpolation option uses less CPU, but the sinc interpolation gives better sound quality (less aliasing), with the quality and CPU usage increasing with the number of points. A good compromise for lower spec systems could be to use sinc interpolation for music playback and linear interpolation for sound effects.</para>
            <para>Whenever possible, a channel's sample rate should match the output device's rate to avoid the need for any sample rate conversion. The device's sample rate could be used in <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> or <see cref="N:Un4seen.Bass.AddOn.Midi"/> stream creation calls, for example.</para>
            <para>The sample rate conversion occurs (when required) during playback, after the sample data has left the channel's playback buffer, so it does not affect the data delivered by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>. Although this attribute has no direct effect on decoding channels, it is still available so that it can be used by the <see cref="N:Un4seen.Bass.AddOn.Mix"/> add-on and anything else that wants to use it.</para>
            <para>This attribute can be set at any time, and changes take immediate effect. A channel's initial setting is determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SRC"/> config option, or <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_SRC_SAMPLE"/> in the case of a sample channel.</para>
            <para><b>Platform-specific</b></para>
            <para>On Windows, sample rate conversion is handled by Windows or the output device/driver rather than BASS, so this setting has no effect on playback there.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_NET_RESUME">
            <summary>
            The download buffer level required to resume stalled playback.
            <para>resume: The resumption level in percent... 0 - 100 (the default is 50%).</para>
            <para>This attribute determines what percentage of the download buffer (<see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_NET_BUFFER"/>) needs to be filled before playback of a stalled internet stream will resume.
            It also applies to 'buffered' user file streams created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.
            The buffering progress can be monitored with <see cref="M:Un4seen.Bass.Bass.BASS_StreamGetFilePosition(System.Int32,Un4seen.Bass.BASSStreamFilePosition)"/> (BASS_FILEPOS_BUFFERING).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SCANINFO">
            <summary>
            The scanned info of a channel.
            <para>scaninfo: The scanned info.</para>
            <para>size: The size of the scanned info.</para>
            <para>This attribute is the information that is scanned from a file when the BASS_STREAM_PRESCAN flag is used in a <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> call or when the BASS_POS_SCAN flag is used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>.
            It is supported on MP3/MP2/MP1 files and chained OGG files. It may be supported by add-ons too; see the documentation.</para>
            <para>The structure of the scanned info may change in future versions, so if the data is stored, be prepared for BASS_ChannelSetAttributeEx to fail when trying to apply it; the file can be scanned again if that happens.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_NORAMP">
            <summary>
            Disable Playback ramping?
            <para>noramp: Disable playback ramping... 0 = no, else yes.</para>
            <para>By default, a channel will be ramped-in when starting playback and ramped-out when stopping playback, to avoid sudden level changes that could result in a click sound each time.
            That ramping can be disabled by enabling this option. Volume (BASS_ATTRIB_VOL) and panning (BASS_ATTRIB_PAN) changes are always ramped regardless of this option setting.</para>
            <para>Ramping only applies during normal playback and does not affect decoding channels; it will not be present in the data delivered by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>.
            Ramping-in is skipped when a channel's sample data begins at a low level. Ramping-out only applies when a channel is stopped or paused via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPause(System.Int32)"/>, 
            not when the output device is stopped or paused via <see cref="M:Un4seen.Bass.Bass.BASS_Stop"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Pause"/>, nor when the end is reached.</para>
            <para>This attribute is not available on Windows, as BASS does not generate the final mix.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_BITRATE">
            <summary>
            Gets the average bitrate (bkps).
            <para>bitrate: The bitrate in kilobits per second (bkps).</para>
            <para>This attribute gives the average bitrate of the file's audio data. If the file also contains video, that is excluded from the bitrate calculation.
            This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_BUFFER">
            <summary>
            Playback buffering length.
            <para>buffer The buffering length in seconds... 0 = no buffering. This is automatically capped to the full length of the channel's playback buffer.</para>
            <para>This attribute allows the amount of playback buffering to be changed without recreating the channel to get a new buffer. It limits how much data the update thread(s) or the <see cref="M:Un4seen.Bass.Bass.BASS_Update(System.Int32)"/> function will try to keep in the playback buffer; 
            it cannot exceed the length of the buffer, determined by the BASS_CONFIG_BUFFER setting at the time of its creation. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelUpdate(System.Int32,System.Int32)"/> is unaffected and can still be used to fill the entire buffer. Push streams (using STREAMPROC_PUSH) are also unaffected; they will always place as much data as possible in their playback buffers.</para>
            <para>When this attribute is set to 0, no data will be buffered and the channel will only be asked to produce data as it is needed during the generation of the final mix. This allows the lowest latency to be achieved, but also imposes tighter timing requirements on the channel to produce its data and apply any DSP/FX (and run mixtime syncs) that are set on it; 
            if too long is taken, there will be a break in the output, affecting all channels that are playing on the same device. The channel's data is still placed in its playback buffer, which allows <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> to be used, although there is likely to be less data available to them due to the buffer being less full.</para>
            <para>This attribute can be changed mid-playback. Any excess data that is currently in the playback buffer will still be played but not replaced.</para>
            <para>The default value is the channel's full playback buffer length, as determined by the BASS_CONFIG_BUFFER setting at the time of its creation.</para>
            <para>This attribute is not available when using DirectSound output on Windows, as BASS does not generate the final mix.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_AMPLIFY">
            <summary>
            The amplification level of a MOD music.
            <para>amp: Amplification level... 0 (min) to 100 (max). This will be rounded down to a whole number.</para>
            <para>As the amplification level get's higher, the sample data's range increases, and therefore, the resolution increases. But if the level is set too high, then clipping can occur, which can result in distortion of the sound.</para>
            <para>You can check the current level of a MOD music at any time by using <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>. By doing so, you can decide if a MOD music's amplification level needs adjusting.</para>
            <para>The default amplification level is 50.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PANSEP">
            <summary>
            The pan separation level of a MOD music.
            <para>pansep: Pan separation... 0 (min) to 100 (max), 50 = linear. This will be rounded down to a whole number.</para>
            <para>By default BASS uses a linear panning "curve". If you want to use the panning of FT2, use a pan separation setting of around 35. To use the Amiga panning (ie. full left and right) set it to 100.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER">
            <summary>
            The position scaler of a MOD music.
            <para>scale: The scaler... 1 (min) to 256 (max). This will be rounded down to a whole number.</para>
            <para>When calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/>, the row (HIWORD) will be scaled by this value. By using a higher scaler, you can get a more precise position indication.</para>
            <para>The default scaler is 1.</para>
            <para>
            <example>
            Get the position of a MOD music accurate to within a 10th of a row:
            <code>
            // set the scaler
            Bass.BASS_ChannelSetAttribute(music, BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER, 10f);
            int pos = Bass.BASS_MusicGetOrderPosition(music);
            // the order
            int order = Utils.LowWord32(pos);
            // the row
            int row = HighWord32(pos) / 10;
            // the 10th of a row
            int row10th = HighWord32(pos) % 10;
            </code>
            <code lang="vbnet">
            ' set the scaler
            Bass.BASS_ChannelSetAttribute(music, BASSAttribute.BASS_ATTRIB_MUSIC_PSCALER, 10F)
            Dim pos As Integer = Bass.BASS_MusicGetOrderPosition(music)
            ' the order
            Dim order As Integer = Utils.LowWord32(pos)
            ' the row
            Dim row As Integer = HighWord32(pos) / 10
            ' the 10th of a row
            Dim row10th As Integer = HighWord32(pos) Mod 10
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_BPM">
            <summary>
            The BPM of a MOD music.
            <para>bpm: The BPM... 1 (min) to 255 (max). This will be rounded down to a whole number.</para>
            <para>This attribute is a direct mapping of the MOD's BPM, so the value can be changed via effects in the MOD itself.</para>
            <para>Note that by changing this attribute, you are changing the playback length.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_SPEED">
            <summary>
            The speed of a MOD music.
            <para>speed: The speed... 0 (min) to 255 (max). This will be rounded down to a whole number.</para>
            <para>This attribute is a direct mapping of the MOD's speed, so the value can be changed via effects in the MOD itself.</para>
            <para>The "speed" is the number of ticks per row. Setting it to 0, stops and ends the music. Note that by changing this attribute, you are changing the playback length.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_VOL_GLOBAL">
            <summary>
            The global volume level of a MOD music.
            <para>volume: The global volume level... 0 (min) to 64 (max, 128 for IT format). This will be rounded down to a whole number.</para>
            <para>This attribute is a direct mapping of the MOD's global volume, so the value can be changed via effects in the MOD itself.
            The "speed" is the number of ticks per row. Setting it to 0, stops and ends the music. Note that by changing this attribute, you are changing the playback length.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_ACTIVE">
            <summary>
            The number of active channels in a MOD music.
            <para>active: The number of channels.</para>
            <para>This attribute gives the number of channels (including virtual) that are currently active in the decoder, which may not match what is being heard during playback due to buffering. 
            To reduce the time difference, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_VOL_CHAN">
            <summary>
            The volume level of a channel in a MOD music + <i>channel#</i>.
            <para>channel: The channel to set the volume of... 0 = 1st channel.</para>
            <para>volume: The volume level... 0 (silent) to 1 (full).</para>
            <para>The volume curve used by this attribute is always linear, eg. 0.5 = 50%. The <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_VOL"/> config option setting has no effect on this. The volume level of all channels is initially 1 (full).</para>
            <para>This attribute can also be used to count the number of channels in a MOD Music.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            <para>
            <example>
            Count the number of channels in a MOD music:
            <code>
            int channels = 0;
            float dummy;
            while (Bass.BASS_ChannelGetAttribute(music, (BASSAttribute)((int)BASS_ATTRIB_MUSIC_VOL_CHAN + channels), ref dummy))
            {
              channels++; 
            }
            </code>
            <code lang="vbnet">
            Dim channels As Integer = 0
            Dim dummy As Single
            While Bass.BASS_ChannelGetAttribute(music, CType(CInt(BASS_ATTRIB_MUSIC_VOL_CHAN) + channels, BASSAttribute), dummy)
              channels += 1
            End While
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MUSIC_VOL_INST">
            <summary>
            The volume level of an instrument in a MOD music + <i>inst#</i>.
            <para>inst: The instrument to set the volume of... 0 = 1st instrument.</para>
            <para>volume: The volume level... 0 (silent) to 1 (full).</para>
            <para>The volume curve used by this attribute is always linear, eg. 0.5 = 50%. The <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_CURVE_VOL"/> config option setting has no effect on this. The volume level of all instruments is initially 1 (full). For MOD formats that do not use instruments, read "sample" for "instrument".</para>
            <para>This attribute can also be used to count the number of instruments in a MOD music.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_BUFFER"/> config option to reduce the buffer length.</para>
            <para>
            <example>
            Count the number of instruments in a MOD music:
            <code>
            int instruments = 0;
            float dummy;
            while (Bass.BASS_ChannelGetAttribute(music, (BASSAttribute)((int)BASSAttribute.BASS_ATTRIB_MUSIC_VOL_INST + instruments), ref dummy))
            {
              instruments++; 
            }
            </code>
            <code lang="vbnet">
            Dim instruments As Integer = 0
            Dim dummy As Single
            While Bass.BASS_ChannelGetAttribute(music, CType(CInt(BASSAttribute.BASS_ATTRIB_MUSIC_VOL_INST) + instruments, BASSAttribute), dummy)
              instruments += 1
            End While
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO">
            <summary>
            BASS_FX Tempo: The Tempo in percents (-95%..0..+5000%).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_PITCH">
            <summary>
            BASS_FX Tempo: The Pitch in semitones (-60..0..+60).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_FREQ">
            <summary>
            BASS_FX Tempo: The Samplerate in Hz, but calculates by the same % as BASS_ATTRIB_TEMPO.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_USE_AA_FILTER">
            <summary>
            BASS_FX Tempo Option: Use FIR low-pass (anti-alias) filter (gain speed, lose quality)? <see langword="true"/>=1 (default), <see langword="false"/>=0.
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            <para>On iOS, Android, WinCE and Linux ARM platforms this is by default disabled for lower CPU usage.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_AA_FILTER_LENGTH">
            <summary>
            BASS_FX Tempo Option: FIR low-pass (anti-alias) filter length in taps (8 .. 128 taps, default = 32, should be %4).
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_USE_QUICKALGO">
            <summary>
            BASS_FX Tempo Option: Use quicker tempo change algorithm (gain speed, lose quality)? <see langword="true"/>=1, <see langword="false"/>=0 (default).
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_SEQUENCE_MS">
            <summary>
            BASS_FX Tempo Option: Tempo Sequence in milliseconds (default = 82).
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_SEEKWINDOW_MS">
            <summary>
            BASS_FX Tempo Option: SeekWindow in milliseconds (default = 14).
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_OVERLAP_MS">
            <summary>
            BASS_FX Tempo Option: Tempo Overlap in milliseconds (default = 12).
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_TEMPO_OPTION_PREVENT_CLICK">
            <summary>
            BASS_FX Tempo Option: Prevents clicks with tempo changes (default = FALSE).
            <para>See <see cref="M:Un4seen.Bass.AddOn.Fx.BassFx.BASS_FX_TempoCreate(System.Int32,Un4seen.Bass.BASSFlag)"/> for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_REVERSE_DIR">
            <summary>
            BASS_FX Reverse: The Playback direction (-1=BASS_FX_RVS_REVERSE or 1=BASS_FX_RVS_FORWARD).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_PPQN">
            <summary>
            BASSMIDI: Gets the Pulses Per Quarter Note (or ticks per beat) value of the MIDI file.
            <para>ppqn: The PPQN value.</para>
            <para>This attribute is the number of ticks per beat as defined by the MIDI file; it will be 0 for MIDI streams created via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, 
            It is also read-only, so can't be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            <para>
            <example>
            Get the currnet position of a MIDI stream in beats:
            <code>
            float ppqn;
            Bass.BASS_ChannelGetAttribute(midi, BASSAttribute.BASS_ATTRIB_MIDI_PPQN, ref ppqn);
            long tick = Bass.BASS_ChannelGetPosition(midi, BASSMode.BASS_POS_MIDI_TICK);
            float beat = tick / ppqn;
            </code>
            <code lang="vbnet">
            Dim ppqn As Single 
            Bass.BASS_ChannelGetAttribute(midi, BASSAttribute.BASS_ATTRIB_MIDI_PPQN, ppqn) 
            Dim tick As Long = Bass.BASS_ChannelGetPosition(midi, BASSMode.BASS_POS_MIDI_TICK) 
            Dim beat As Single = tick / ppqn 
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CPU">
            <summary>
            BASSMIDI: The maximum percentage of CPU time that a MIDI stream can use.
            <para>limit: The CPU usage limit... 0 to 100, 0 = unlimited.</para>
            <para>It is not strictly the CPU usage that is measured, but rather how timely the stream is able to render data. For example, a limit of 50% would mean that the rendering would need to be at least 2x real-time speed. When the limit is exceeded, BASSMIDI will begin killing voices, starting with the most quiet.</para>
            <para>When the CPU usage is limited, the stream's samples are loaded asynchronously so that any loading delays (eg. due to slow disk) do not hold up the stream for too long. If a sample cannot be loaded in time, then it will be silenced until it is available and the stream will continue playing other samples as normal in the meantime.
            This does not affect sample loading via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamLoadSamples(System.Int32)"/>, which always operates synchronously.</para>
            <para>By default, a MIDI stream will have no CPU limit.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_CHANS">
            <summary>
            BASSMIDI: The number of MIDI channels in a MIDI stream.
            <para>channels: The number of MIDI channels... 1 (min) - 128 (max). For a MIDI file stream, the minimum is 16.</para>
            <para>New channels are melodic by default. Any notes playing on a removed channel are immediately stopped.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_VOICES">
            <summary>
            BASSMIDI: The maximum number of samples to play at a time (polyphony) in a MIDI stream.
            <para>voices: The number of voices... 1 (min) - 1000 (max).</para>
            <para>If there are currently more voices active than the new limit, then some voices will be killed to meet the limit. The number of voices currently active is available via the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_VOICES_ACTIVE"/> attribute.</para>
            <para>A MIDI stream will initially have a default number of voices as determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_MIDI_VOICES"/> config option.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_VOICES_ACTIVE">
            <summary>
            BASSMIDI: The number of samples currently playing in a MIDI stream.
            <para>voices: The number of voices.</para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_STATE">
            <summary>
            BASSMIDI: The current state of a MIDI stream (2nd overload).
            <para>state: the buffer of the state data.</para>
            <para>size: the size of the state data buffer.</para>
            <para>This attribute includes the state of all events in all MIDI channels, except for MIDI_EVENT_NOTE (playing notes are not preserved) and MIDI_EVENT_TEMPO. <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent)"/> can be used to get the MIDI_EVENT_TEMPO event state.</para>
            <para>The structure of the MIDI state data may change in future versions, so if the data is stored, be prepared for <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/> to fail when trying to apply it.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_SRC">
            <summary>
            BASSMIDI: The sample rate conversion quality of a MIDI stream's samples.
            <para>quality: The sample rate conversion quality... 0 = linear interpolation, 1 = 8 point sinc interpolation, 2 = 16 point sinc interpolation.</para>
            <para>The samples in a soundfont will usually need to be played at rates that are different to their original rates. This attribute determines how that is done. The linear interpolation option uses less CPU, but the sinc interpolation gives better sound quality (less aliasing), with the quality and CPU usage increasing with the number of points.</para>
            <para>When this attribute setting is changed, the BASS_MIDI_SINCINTER flag is automatically set or unset on the MIDI stream accordingly, and vice versa. Changes can be made at any time, but the effect of changes during playback will not be heard instantaneously due to buffering.</para>
            <para>Platform-specific:</para>
            <para>On Android and iOS, sinc interpolation requires a NEON supporting CPU. Sinc interpolation is not available on Windows CE. 16 point sinc interpolation is only available on Windows/OSX/Linux and requires an SSE2 supporting CPU.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_KILL">
            <summary>
            BASSMIDI: Disable killed note fading?
            <para>bool: 0 = killed note fading enabled (default), 1 = killed note fading disabled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIDI_TRACK_VOL">
            <summary>
            BASSMIDI: The volume level of a track in a MIDI file stream + <i>track#</i>.
            <para>track#: The track to set the volume of... 0 = first track.</para>
            <para>volume: The volume level (0.0=silent, 1.0=normal/default).</para>
            <para>The volume curve used by this attribute is always linear, eg. 0.5 = 50%. The BASS_CONFIG_CURVE_VOL config option setting has no effect on this.</para>
            <para>During playback, the effect of changes to this attribute are not heard instantaneously, due to buffering. To reduce the delay, use the BASS_CONFIG_BUFFER config option to reduce the buffer length.</para>
            <para>This attribute can also be used to count the number of tracks in a MIDI file stream. MIDI streams created via <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamCreate(System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/> do not have any tracks.</para>
            <para>
            <example>
            Count the number of tracks in a MIDI stream:
            <code>
            int tracks = 0;
            float dummy;
            while (Bass.BASS_ChannelGetAttribute(midi, (BASSAttribute)((int)BASSAttribute.BASS_ATTRIB_MIDI_TRACK_VOL + tracks), ref dummy))
            {
              tracks++; 
            }
            </code>
            <code lang="vbnet">
            Dim tracks As Integer = 0
            Dim dummy As Single
            While Bass.BASS_ChannelGetAttribute(midi, CType(CInt(BASSAttribute.BASS_ATTRIB_MIDI_TRACK_VOL) + tracks, BASSAttribute), dummy)
              tracks += 1
            End While
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_OPUS_ORIGFREQ">
            <summary>
            BASSOPUS: The sample rate of an Opus stream's source material.
            <para>freq: The sample rate.</para>
            <para>Opus streams always have a sample rate of 48000 Hz, and an Opus encoder will resample the source material to that if necessary.
            This attribute presents the original sample rate, which may be stored in the Opus file header. This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_GAIN">
            <summary>
            BASSdsd: The gain applied when converting to PCM.
            <para>gain: The gain in decibels.</para>
            <para>This attribute is only applicable when converting to PCM, and is unavailable when producing DSD-over-PCM or raw DSD data.
            The default setting is determined by the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_DSD_GAIN"/> config option.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_DSD_RATE">
            <summary>
            BASSdsd: The DSD sample rate.
            <para>rate: The DSD sample rate.</para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_MIXER_LATENCY">
            <summary>
            BASSmix: Custom output latency.
            <para>latency: The latency in seconds.</para>
            <para>When a mixer is played by BASS, the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetLevel(System.Int32)"/> and <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> functions 
            will get the output latency and account for that so that they reflect what is currently being heard, but that cannot be done when a different output system is used, eg. ASIO or WASAPI. 
            In that case, this attribute can be used to tell the mixer what the output latency is, so that those functions can still account for it. The mixer needs to have the BASS_STREAM_DECODE and BASS_MIXER_POSEX flags set to use this attribute.</para>
            <para>The default setting is 0 (no accounting for latency). Changes take immediate effect.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SPLIT_ASYNCBUFFER">
            <summary>
            BASSmix: Amount of data to asynchronously buffer from a splitter's source.
            <para>buffer: The amount to buffer, in seconds... 0 = disable asynchronous buffering.
            The asynchronous buffering will be limited to the splitter's buffer length, as determined by BASS_CONFIG_SPLIT_BUFFER.</para>
            <para>A splitter stream will usually get data from its source only when it is needed. This attribute allows the data to be gotten ahead of time asynchronously instead, so that it is ready for the splitter to access immediately when needed. This is not really useful with normal BASS playback (which is already buffered) but it can be used to implement buffering in other cases, eg. for mixer sources. The setting applies to all splitter streams that have the same source.</para>
            <para>When there are multiple splitters with the same source, the asynchronous buffering is based on the most advanced of them, which means that the asynchronous buffer length should be under the splitter buffer length (BASS_CONFIG_SPLIT_BUFFER) to allow the splitter positions to get apart from each other without the buffer overflowing for any of them. That margin should be at least equal to the maximum amount that you expect the splitter positions to get apart at any time.</para>
            <para>By default, the asynchronous buffering will try to fill any space in the buffer in one data request of the source. It can be broken down into smaller amounts via the BASS_ATTRIB_SPLIT_ASYNCPERIOD attribute.</para>
            <para>If a splitter stream needs more data than has been buffered then it will revert to synchronously getting data from the source for the remainder, unless it has the BASS_SPLIT_SLAVE flag set.</para>
            <para>The amount of data that a splitter has buffered can be retrieved from <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Split_StreamGetAvailable(System.Int32)"/>.</para>
            <para>The default setting is 0 (no asynchronous buffering). Changes take immediate effect.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_SPLIT_ASYNCPERIOD">
            <summary>
            BASSmix: Maximum amount of data to asynchronously buffer at a time from a splitter's source.
            <para>period: The maximum amount to data to asynchronously buffer at a time from the source, in seconds... 0 = as much as possible.</para>
            <para>When asynchronous buffering is enabled via the BASS_ATTRIB_SPLIT_ASYNCBUFFER attribute, this attribute limits how much data is requested from the source at a time. When there is more space available in the buffer, the request will be repeated until the space is filled.</para>
            <para>The setting applies to all splitter streams that have the same source. The default setting is 0 (as much as possible). Changes take immediate effect.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_WEBM_TRACK">
            <summary>
            BASSWEBM: The active track number.
            <para>track: The track number... 1 = first.</para>
            <para>This attribute is read-only, so cannot be modified via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSAttribute.BASS_SLIDE_LOG">
            <summary>
            Flag: Slide the attribute's value logarthmically rather than linearly.
            This cannot be used when going from positive to negative or vice versa. An exception is when using a negative value with BASS_ATTRIB_VOL to fade-out and stop.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSSync">
            <summary>
            Sync types to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> (param flag) and <see cref="T:Un4seen.Bass.SYNCPROC"/> (data flag).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_POS">
            <summary>
            Sync when a channel reaches a position.
            <para>param : position in bytes</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MUSICINST">
            <summary>
            Sync when an instrument (sample for the non-instrument based formats) is played in a MOD music (not including retrigs).
            <para>param : LOWORD=instrument (1=first) HIWORD=note (0=c0...119=b9, -1=all)</para>
            <para>data : LOWORD=note HIWORD=volume (0-64)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_END">
            <summary>
            Sync when a channel reaches the end.
            <para>param : not used</para>
            <para>data : 1 = the sync is triggered by a backward jump in a MOD music, otherwise not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MUSICFX">
            <summary>
            Sync when the "sync" effect (XM/MTM/MOD: E8x/Wxx, IT/S3M: S2x) is used.
            <para>param : 0:data=pos, 1:data="x" value</para>
            <para>data : param=0: LOWORD=order HIWORD=row, param=1: "x" value</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_META">
            <summary>
            Sync when metadata is received in a stream.
            <para>param : not used</para>
            <para>data : not used - the updated metadata is available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_META)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_SLIDE">
            <summary>
            Sync when an attribute slide is completed.
            <para>param : not used</para>
            <para>data : the type of slide completed (one of the BASS_SLIDE_xxx values)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_STALL">
            <summary>
            Sync when playback has stalled.
            <para>param : not used</para>
            <para>data : 0=stalled, 1=resumed</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_DOWNLOAD">
            <summary>
            Sync when downloading of an internet (or "buffered" user file) stream has ended.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_FREE">
            <summary>
            Sync when a channel is freed.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MUSICPOS">
            <summary>
            Sync when a MOD music reaches an order:row position.
            <para>param : LOWORD=order (0=first, -1=all) HIWORD=row (0=first, -1=all)</para>
            <para>data : LOWORD=order HIWORD=row</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_SETPOS">
            <summary>
            Sync when seeking (inc. looping and restarting). So it could be used to reset DSP/etc.
            <para>param : position in bytes</para>
            <para>data : 0=playback is unbroken, 1=if is it broken (eg. buffer flushed). The latter would be the time to reset DSP/etc.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_OGG_CHANGE">
            <summary>
            Sync when a new logical bitstream begins in a chained OGG stream. Updated tags are available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_DEV_FAIL">
            <summary>
            Sync when the channel's device stops unexpectedly (eg. if it is disconnected/disabled). When this happens, it will not be possible to resume a recording but it may be possible to resume playback via <see cref="M:Un4seen.Bass.Bass.BASS_Start"/> once the device becomes available again.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_DEV_FORMAT">
            <summary>
            Sync when the sample format (sample rate and/or channel count) of the channel's device changes. The new format is available from <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/>.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIXTIME">
            <summary>
            FLAG: sync at mixtime, else at playtime
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_ONETIME">
            <summary>
            FLAG: sync only once, else continuously
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIXER_ENVELOPE">
            <summary>
            MIX add-on: Sync when an envelope reaches the end.
            <para>param : not used</para>
            <para>data : envelope type</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIXER_ENVELOPE_NODE">
            <summary>
            MIX add-on: Sync when an envelope node is reached.
            <para>param : Optional limit the sync to a certain envelope type (one of the <see cref="T:Un4seen.Bass.AddOn.Mix.BASSMIXEnvelope"/> values).</para>
            <para>data : Will contain the envelope type in the LOWORD and the current node number in the HIWORD.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_WMA_CHANGE">
            <summary>
            WMA add-on: Sync on a track change in a server-side playlist. Updated tags are available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_WMA_META">
            <summary>
            WMA add-on: Sync on a mid-stream tag change in a server-side playlist. Updated tags are available via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            <para>param : not used</para>
            <para>data : not used - the updated metadata is available from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WMA_META)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_CD_ERROR">
            <summary>
            CD add-on: Sync when playback is stopped due to an error. For example, the drive door being opened.
            <para>param : not used</para>
            <para>data : the position that was being read from the CD track at the time.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_CD_SPEED">
            <summary>
            CD add-on: Sync when the read speed is automatically changed due to the BASS_CONFIG_CD_AUTOSPEED setting.
            <para>param : not used</para>
            <para>data : the new read speed.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_WINAMP_SYNC_BITRATE">
            <summary>
            WINAMP add-on: Sync when bitrate is changed or retrieved from a winamp input plug-in.
            <para>param : not used</para>
            <para>data : the bitrate retrieved from the winamp input plug-in - called when it is retrieved or changed (VBR MP3s, OGGs, etc).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_MARKER">
            <summary>
            MIDI add-on: Sync when a marker is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.</para>
            <para>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_MARKER, data)
              ...
            End Sub
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_CUE">
            <summary>
            MIDI add-on: Sync when a cue is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.</para>
            <para>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_CUE, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_CUE, data)
              ...
            End Sub
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_LYRIC">
            <summary>
            MIDI add-on: Sync when a lyric event is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.
            If the text begins with a '/' (slash) character, a new line should be started. If it begins with a '\' (backslash) character, the display should be cleared.</para>
            <para>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_LYRIC, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_MIDI_MARK_LYRIC, data)
              ...
            End Sub
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_TEXT">
            <summary>
            MIDI add-on: Sync when a text event is encountered.
            <para>param : not used</para>
            <para>data : the marker index, which can be used in a <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/> call.
            Lyrics can sometimes be found in BASS_MIDI_MARK_TEXT instead of BASS_MIDI_MARK_LYRIC markers.</para>
            <para>
            <example>
            <code>
            private void MidiSync(int handle, int channel, int data, IntPtr user)
            {
              BASS_MIDI_MARK mark = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_SYNC_MIDI_TEXT, data);
              ...
            }
            </code>
            <code lang="vbnet">
            Private Sub MidiSync(handle As Integer, channel As Integer, data As Integer, user As IntPtr)
              Dim mark As BASS_MIDI_MARK = BassMidi.BASS_MIDI_StreamGetMark(channel, BASSMIDIMarker.BASS_SYNC_MIDI_TEXT, data)
              ...
            End Sub
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_EVENT">
            <summary>
            MIDI add-on: Sync when a type of event is processed, in either a MIDI file or <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/>.
            <para>param : event type (0 = all types).</para>
            <para>data : LOWORD = event parameter, HIWORD = channel  (high 8 bits contain the event type when syncing on all types). See <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamEvent(System.Int32,System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIEvent,System.Int32)"/> for a list of event types and their parameters.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_TICK">
            <summary>
            MIDI add-on: Sync when reaching a tick position.
            <para>param : tick position.</para>
            <para>data : not used</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_TIMESIG">
            <summary>
            MIDI add-on: Sync when a time signature event is processed.
            <para>param : event type.</para>
            <para>data : The time signature events are given (by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>) in the form of "numerator/denominator metronome-pulse 32nd-notes-per-MIDI-quarter-note", eg. "4/4 24 8".</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_MIDI_KEYSIG">
            <summary>
            MIDI add-on: Sync when a key signature event is processed.
            <para>param : event type.</para>
            <para>data : The key signature events are given (by <see cref="M:Un4seen.Bass.AddOn.Midi.BassMidi.BASS_MIDI_StreamGetMark(System.Int32,Un4seen.Bass.AddOn.Midi.BASSMIDIMarker,System.Int32,Un4seen.Bass.AddOn.Midi.BASS_MIDI_MARK)"/>) in the form of "a b", where a is the number of sharps (if positive) or flats (if negative), and b signifies major (if 0) or minor (if 1).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSSync.BASS_SYNC_HLS_SEGMENT">
            <summary>
            BASShls add-on: Sync when a new segment begins downloading.
            <para>param : not used.</para>
            <para>data : not used.</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSFXType">
            <summary>
            FX effect types, use with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetFX(System.Int32,Un4seen.Bass.BASSFXType,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_CHORUS">
            <summary>
            DX8 Chorus. Use <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_COMPRESSOR">
            <summary>
            DX8 Compressor. Use <see cref="T:Un4seen.Bass.BASS_DX8_COMPRESSOR"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_DISTORTION">
            <summary>
            DX8 Distortion. Use <see cref="T:Un4seen.Bass.BASS_DX8_DISTORTION"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_ECHO">
            <summary>
            DX8 Echo. Use <see cref="T:Un4seen.Bass.BASS_DX8_ECHO"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_FLANGER">
            <summary>
            DX8 Flanger. Use <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_GARGLE">
            <summary>
            DX8 Gargle. Use <see cref="T:Un4seen.Bass.BASS_DX8_GARGLE"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_I3DL2REVERB">
            <summary>
            DX8 I3DL2 (Interactive 3D Audio Level 2) reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_PARAMEQ">
            <summary>
            DX8 Parametric equalizer. Use <see cref="T:Un4seen.Bass.BASS_DX8_PARAMEQ"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_DX8_REVERB">
            <summary>
            DX8 Reverb. Use <see cref="T:Un4seen.Bass.BASS_DX8_REVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_VOLUME">
            <summary>
            Volume level adjustment. Use <see cref="T:Un4seen.Bass.BASS_FX_VOLUME_PARAM"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ROTATE">
            <summary>
            BASS_FX Channel Volume Ping-Pong (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ROTATE"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO">
            <summary>
            BASS_FX Echo (2 channels max). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_FLANGER">
            <summary>
            BASS_FX Flanger (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FLANGER"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_VOLUME">
            <summary>
            BASS_FX Volume control (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_PEAKEQ">
            <summary>
            BASS_FX Peaking Equalizer (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PEAKEQ"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_REVERB">
            <summary>
            BASS_FX Reverb (2 channels max). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_REVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_LPF">
            <summary>
            BASS_FX Low Pass Filter (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_LPF"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_MIX">
            <summary>
            BASS_FX Channel Swap/Remap/Downmix (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_MIX"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_DAMP">
            <summary>
            BASS_FX Dynamic Amplification (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DAMP"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_AUTOWAH">
            <summary>
            BASS_FX Auto WAH (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_AUTOWAH"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO2">
            <summary>
            BASS_FX Echo 2 (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO2"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_PHASER">
            <summary>
            BASS_FX Phaser (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PHASER"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO3">
            <summary>
            BASS_FX Echo 3 (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO3"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_CHORUS">
            <summary>
            BASS_FX Chorus (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_CHORUS"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_APF">
            <summary>
            BASS_FX All Pass Filter (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_APF"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_COMPRESSOR">
            <summary>
            BASS_FX Dynamic Range Compressor (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_DISTORTION">
            <summary>
            BASS_FX Distortion (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_DISTORTION"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_COMPRESSOR2">
            <summary>
            BASS_FX Dynamic Range Compressor (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_COMPRESSOR2"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_VOLUME_ENV">
            <summary>
            BASS_FX Volume Envelope (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_VOLUME_ENV"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_BQF">
            <summary>
            BASS_FX BiQuad filters (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_BQF"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_ECHO4">
            <summary>
            BASS_FX Echo/Reverb 4 (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_ECHO4"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_PITCHSHIFT">
            <summary>
            BASS_FX Pitch Shift using FFT (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_PITCHSHIFT"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXType.BASS_FX_BFX_FREEVERB">
            <summary>
            BASS_FX Pitch Shift using FFT (multi channel). Use <see cref="T:Un4seen.Bass.AddOn.Fx.BASS_BFX_FREEVERB"/> structure to set/get parameters.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASSFXPhase">
            <summary>
            DX8 effect types, use with e.g. the <see cref="T:Un4seen.Bass.BASS_DX8_CHORUS"/> and <see cref="T:Un4seen.Bass.BASS_DX8_FLANGER"/> effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_NEG_180">
            <summary>
            Phase differential between left and right LFOs (-180)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_NEG_90">
            <summary>
            Phase differential between left and right LFOs (-90)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_ZERO">
            <summary>
            Phase differential between left and right LFOs (+/-0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_90">
            <summary>
            Phase differential between left and right LFOs (+90)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASSFXPhase.BASS_FX_PHASE_180">
            <summary>
            Phase differential between left and right LFOs (+180)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.WAVEFormatTag">
            <summary>
            Defines possible wave formats to be used with the <see cref="F:Un4seen.Bass.WAVEFORMATEX.wFormatTag"/> flag.
            </summary>
            <remarks>See the MMREG.H file for more codec numbers.</remarks>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.UNKNOWN">
            <summary>
            Unknown Format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.PCM">
            <summary>
            PCM format (8 or 16 bit), Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.ADPCM">
            <summary>
            AD PCM Format, Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.IEEE_FLOAT">
            <summary>
            IEEE PCM Float format (32 bit)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.DOLBY_AC2">
            <summary>
            AC2, Dolby Laboratories
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.GSM610">
            <summary>
            GSM 6.10, Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MSNAUDIO">
            <summary>
            MSN Audio, Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MPEG">
            <summary>
            MPEG format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MPEGLAYER3">
            <summary>
            ISO/MPEG Layer3 Format
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.DOLBY_AC3_SPDIF">
            <summary>
            AC3 Digital, Sonic Foundry
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.RAW_AAC1">
            <summary>
            Raw AAC
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MSAUDIO1">
            <summary>
            Microsoft Corporation
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.WMA">
            <summary>
            Windows Media Audio. This format is valid for versions 2 through 9
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.WMA_PRO">
            <summary>
            Windows Media Audio 9 Professional
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.WMA_LOSSLESS">
            <summary>
            Windows Media Audio 9 Lossless
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.WMA_SPDIF">
            <summary>
            Windows Media SPDIF Digital Audio
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MPEG_ADTS_AAC">
            <summary>
            ADTS AAC Audio
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MPEG_RAW_AAC">
            <summary>
            Raw AAC
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MPEG_LOAS">
            <summary>
            MPEG-4 audio transport stream with a synchronization layer (LOAS) and a multiplex layer (LATM)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.MPEG_HEAAC">
            <summary>
            High-Efficiency Advanced Audio Coding (HE-AAC) stream
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFormatTag.EXTENSIBLE">
            <summary>
            Extensible Format (user defined)
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_PLUGINFORM">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> to retrieve information on the supported plugin formats.
            </summary>
            <remarks>The plugin information does not change, so the returned pointer remains valid for as long as the plugin is loaded.
            <para>The extension filter is for information only. A plugin will check the file contents rather than file extension, to verify that it is a supported format.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGINFORM.ctype">
            <summary>
            The channel type, as would appear in the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGINFORM.name">
            <summary>
            The Format description or name.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGINFORM.exts">
            <summary>
            File extension filter, in the form of "*.ext1;*.ext2;etc...".
            </summary>
            <remarks>The extension filter is for information only. A plugin will check the file contents rather than file extension, to verify that it is a supported format.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGINFORM.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGINFORM.#ctor(System.String,System.String,Un4seen.Bass.BASSChannelType)">
            <summary>
            Constructor.
            </summary>
            <param name="ChannelType">The channel type, as would appear in the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> structure.</param>
            <param name="Name">The Format description or name.</param>
            <param name="Extensions">File extension filter, in the form of "*.ext1;*.ext2;etc...".</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGINFORM.ToString">
            <summary>
            A description of the plugin format (name|exts) which can be used for file filter settings.
            </summary>
            <returns>The file filter of the plugin format (name|exts).</returns>
        </member>
        <member name="T:Un4seen.Bass.bass_plugininfo">
            <summary>
            Only used internally! See <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.bass_plugininfo.version">
            <summary>
            plugin version (same form as BASS_GetVersion).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.bass_plugininfo.formatc">
            <summary>
            Number of supported formats.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.bass_plugininfo.formats">
            <summary>
            The pointer to the array of supported formats. The array contains formatc elements.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_PLUGININFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> to retrieve information on a plugin.
            </summary>
            <remarks>This class can not be used directly! It will be returned and created by <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> only.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGININFO.version">
            <summary>
            Plugin version, in the same form as given by <see cref="M:Un4seen.Bass.Bass.BASS_GetVersion"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGININFO.formatc">
            <summary>
            Number of supported formats.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_PLUGININFO.formats">
            <summary>
            The array of supported formats. The array contains <see cref="F:Un4seen.Bass.BASS_PLUGININFO.formatc"/> number of elements.
            </summary>
            <remarks>
            Note: There is no guarantee that the list of supported formats is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor">
            <summary>
            An instance of this class can not be created directly. Use <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> instead.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor(System.Int32,Un4seen.Bass.BASS_PLUGINFORM[])">
            <summary>
            Internal Constructor.
            </summary>
            <param name="Formats">The formats to use.</param>
            <param name="Version">The version of the plugin.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor(System.IntPtr)">
            <summary>
            Constructor. Can be used with the return value of <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfoPtr(System.Int32)"/>.
            </summary>
            <param name="pluginInfoPtr">A pointer to the <see cref="T:Un4seen.Bass.BASS_PLUGININFO"/> structure.</param>
            <remarks>Should only be used with the return value of <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfoPtr(System.Int32)"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Constructor
            </summary>
            <param name="ver">The version of the plugin.</param>
            <param name="count">The number of supported formats.</param>
            <param name="fPtr">The pointer to the array of supported formats</param>
            <remarks>Only used internally.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.ReadArrayStructure(System.Int32,System.IntPtr)">
            <summary>
            Reads in the <see cref="T:Un4seen.Bass.BASS_PLUGINFORM"/> array.
            </summary>
            <param name="count">Number of array elements to read.</param>
            <param name="p">The pointer to the first array element.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_PLUGININFO.ToString">
            <summary>
            A description of the plugin structure (version, formatc).
            </summary>
            <returns>A description of the plugin structure (version, formatc).</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_DEVICEINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_GetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetDeviceInfo(System.Int32,Un4seen.Bass.BASS_DEVICEINFO)"/> to retrieve information on a device.
            </summary>
            <remarks>
            <para>When a device is disabled/disconnected, it is still retained in the device list, but the BASS_DEVICE_ENABLED flag is removed from it. If the device is subsequently re-enabled, it may become available again with the same device number, or the system may add a new entry for it.</para>
            <para>When a new device is connected, it can affect the other devices and result in the system moving them to new device entries. If an affected device is initialized, it will stop working and will need to be reinitialized using its new device number.</para>
            <para><b>Platform-specific</b></para>
            <para>On Windows, <i>driver</i> can reveal the type of driver being used on systems that support both VxD and WDM drivers (Windows Me/98SE). 
            Further information can be obtained from the file via the GetFileVersionInfo function. On Vista and newer, the device's endpoint ID is given rather than its driver filename. 
            On OSX, driver is the device's UID, and on Linux it is the ALSA device name. It is unused on other platforms. 
            The device type is only available on Windows (Vista and newer) and OSX. On Windows, DisplayPort devices will have BASS_DEVICE_TYPE_HDMI rather than BASS_DEVICE_TYPE_DISPLAYPORT.</para>
            <para>Depending on the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_UNICODE"/> config setting, <i>name</i> and <i>driver</i> can be in ANSI or UTF-8 form on Windows.
            They are always in UTF-16 form on Windows CE, and UTF-8 on other platforms - note, that Bass.Net always enables the Unicode form and does all the conversion for you by default!
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.driver">
            <summary>
            The filename of the driver being used... <see langword="null"/> = no driver (ie. "no sound" device).
            <para>On systems that can use both VxD and WDM drivers (Windows Me/98SE), this will reveal which type of driver is being used.</para>
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.id">
            <summary>
            The driver id resp. interface name being used... <see langword="null"/> = no id (ie. interface name is not available).
            <para>Only available on Vista/Win7 systems.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DEVICEINFO.flags">
            <summary>
            The device's current status. A combination of these flags (<see cref="T:Un4seen.Bass.BASSDeviceInfo"/>):
            <list type="table">
            <item><term>BASS_DEVICE_ENABLED</term><description>The device is enabled. It will not be possible to initialize the device if this flag is not present.</description></item>
            <item><term>BASS_DEVICE_DEFAULT</term><description>The device is the system default.</description></item>
            <item><term>BASS_DEVICE_INIT</term><description>The device is initialized, ie. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has been called.</description></item>
            </list>
            The type of device may also be indicated in the high 8 bits (use BASS_DEVICE_TYPE_MASK to test), and can be one of the following:
            <list type="table">
            <item><term>BASS_DEVICE_TYPE_DIGITAL</term><description>An audio endpoint device that connects to an audio adapter through a connector for a digital interface of unknown type.</description></item>
            <item><term>BASS_DEVICE_TYPE_DISPLAYPORT</term><description>An audio endpoint device that connects to an audio adapter through a DisplayPort connector.</description></item>
            <item><term>BASS_DEVICE_TYPE_HANDSET</term><description>The part of a telephone that is held in the hand and that contains a speaker and a microphone for two-way communication.</description></item>
            <item><term>BASS_DEVICE_TYPE_HDMI</term><description>An audio endpoint device that connects to an audio adapter through a High-Definition Multimedia Interface (HDMI) connector.</description></item>
            <item><term>BASS_DEVICE_TYPE_HEADPHONES</term><description>A set of headphones.</description></item>
            <item><term>BASS_DEVICE_TYPE_HEADSET</term><description>An earphone or a pair of earphones with an attached mouthpiece for two-way communication.</description></item>
            <item><term>BASS_DEVICE_TYPE_LINE</term><description>An audio endpoint device that sends a line-level analog signal to a line-input jack on an audio adapter or that receives a line-level analog signal from a line-output jack on the adapter.</description></item>
            <item><term>BASS_DEVICE_TYPE_MICROPHONE</term><description>A microphone.</description></item>
            <item><term>BASS_DEVICE_TYPE_NETWORK</term><description>An audio endpoint device that the user accesses remotely through a network.</description></item>
            <item><term>BASS_DEVICE_TYPE_SPDIF</term><description>An audio endpoint device that connects to an audio adapter through a Sony/Philips Digital Interface (S/PDIF) connector.</description></item>
            <item><term>BASS_DEVICE_TYPE_SPEAKERS</term><description>A set of speakers.</description></item>
            </list>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.status">
            <summary>
            The device's current status. A combination of these flags (<see cref="T:Un4seen.Bass.BASSDeviceInfo"/>):
            <list type="table">
            <item><term>BASS_DEVICE_ENABLED</term><description>The device is enabled. It will not be possible to initialize the device if this flag is not present.</description></item>
            <item><term>BASS_DEVICE_DEFAULT</term><description>The device is the system default.</description></item>
            <item><term>BASS_DEVICE_INIT</term><description>The device is initialized, ie. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_RecordInit(System.Int32)"/> has been called.</description></item>
            </list>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.type">
            <summary>
            The type of device:
            <list type="table">
            <item><term>BASS_DEVICE_TYPE_DIGITAL</term><description>An audio endpoint device that connects to an audio adapter through a connector for a digital interface of unknown type.</description></item>
            <item><term>BASS_DEVICE_TYPE_DISPLAYPORT</term><description>An audio endpoint device that connects to an audio adapter through a DisplayPort connector.</description></item>
            <item><term>BASS_DEVICE_TYPE_HANDSET</term><description>The part of a telephone that is held in the hand and that contains a speaker and a microphone for two-way communication.</description></item>
            <item><term>BASS_DEVICE_TYPE_HDMI</term><description>An audio endpoint device that connects to an audio adapter through a High-Definition Multimedia Interface (HDMI) connector.</description></item>
            <item><term>BASS_DEVICE_TYPE_HEADPHONES</term><description>A set of headphones.</description></item>
            <item><term>BASS_DEVICE_TYPE_HEADSET</term><description>An earphone or a pair of earphones with an attached mouthpiece for two-way communication.</description></item>
            <item><term>BASS_DEVICE_TYPE_LINE</term><description>An audio endpoint device that sends a line-level analog signal to a line-input jack on an audio adapter or that receives a line-level analog signal from a line-output jack on the adapter.</description></item>
            <item><term>BASS_DEVICE_TYPE_MICROPHONE</term><description>A microphone.</description></item>
            <item><term>BASS_DEVICE_TYPE_NETWORK</term><description>An audio endpoint device that the user accesses remotely through a network.</description></item>
            <item><term>BASS_DEVICE_TYPE_SPDIF</term><description>An audio endpoint device that connects to an audio adapter through a Sony/Philips Digital Interface (S/PDIF) connector.</description></item>
            <item><term>BASS_DEVICE_TYPE_SPEAKERS</term><description>A set of speakers.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DEVICEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DEVICEINFO.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns>A description of the decive info object (name).</returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.IsEnabled">
            <summary>
            The device is enabled and can be used.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.IsDefault">
            <summary>
            The device is the system default device.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_DEVICEINFO.IsInitialized">
            <summary>
            The device is already initialized.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_INFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)"/> to retrieve information on the current device.
            </summary>
            <remarks>
            The DSCAPS_SECONDARY flags only indicate which sample formats are supported by hardware mixing.
            <para><b>Platform-specific</b></para>
            <para>On Windows, it is possible for speakers to mistakenly be 2 with some devices/drivers when the device in fact supports more speakers. In that case, the BASS_DEVICE_CPSPEAKERS flag can be used (with BASS_Init) to use the Windows control panel setting, or the BASS_DEVICE_SPEAKERS flag can be used to force the enabling of speaker assignment to up to 8 speakers, even though the device may not really support that many speakers. The result of assigning channels to nonexistent speakers is undefined; they may be heard on other speakers or not heard at all.</para>
            <para>The flags, hwsize, hwfree, freesam, free3d, minrate, maxrate, eax, and dsver members are only used on Windows, as DirectSound and hardware mixing are only available there. The freq member is not available on Windows prior to Vista.</para>
            <para>On Windows, the availability of the latency and minbuf values depends on the BASS_DEVICE_LATENCY flag being used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> was called.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.flags">
            <summary>
            The device's capabilities. A combination of these flags (<see cref="T:Un4seen.Bass.BASSInfo"/>):
            <list type="table">
            <item><term>DSCAPS_CONTINUOUSRATE</term><description>The device supports all sample rates between minrate and maxrate.</description></item>
            <item><term>DSCAPS_EMULDRIVER</term><description>The device's drivers do NOT have DirectSound support, so it is being emulated. Updated drivers should be installed.</description></item>
            <item><term>DSCAPS_CERTIFIED</term><description>The device driver has been certified by Microsoft. This flag is always set on WDM drivers.</description></item>
            <item><term>DSCAPS_SECONDARYMONO</term><description>Mono samples are supported by hardware mixing.</description></item>
            <item><term>DSCAPS_SECONDARYSTEREO</term><description>Stereo samples are supported by hardware mixing.</description></item>
            <item><term>DSCAPS_SECONDARY8BIT</term><description>8-bit samples are supported by hardware mixing.</description></item>
            <item><term>DSCAPS_SECONDARY16BIT</term><description>16-bit samples are supported by hardware mixing.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.hwsize">
            <summary>
            The device's total amount of hardware memory.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.hwfree">
            <summary>
            The device's amount of free hardware memory.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.freesam">
            <summary>
            The number of free sample slots in the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.free3d">
            <summary>
            The number of free 3D sample slots in the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.minrate">
            <summary>
            The minimum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.maxrate">
            <summary>
            The maximum sample rate supported by the hardware.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.eax">
            <summary>The device supports EAX and has it enabled?
            <para>The device's "Hardware acceleration" needs to be set to "Full" in it's "Advanced Properties" setup, else EAX is disabled.</para>
            <para>This is always <see langword="false"/> if BASS_DEVICE_3D was not used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> was called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.minbuf">
            <summary>The minimum buffer length (rounded up to the nearest millisecond) recommended for use with the BASS_CONFIG_BUFFER config option (see <see cref="M:Un4seen.Bass.Bass.BASS_GetConfig(Un4seen.Bass.BASSConfig)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).
            <para>Requires that BASS_DEVICE_LATENCY was used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> was called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.dsver">
            <summary>
            DirectSound version.
            <para>9 = DX9/8/7/5 features are available, 8 = DX8/7/5 features are available, 7 = DX7/5 features are available, 5 = DX5 features are available. 0 = none of the DX9/8/7/5 features are available.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.latency">
            <summary>The delay (rounded up to the nearest millisecond) for playback of HSTREAM/HMUSIC channels to start and be heard.
            <para>Requires that BASS_DEVICE_LATENCY was used when <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> was called.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.initflags">
            <summary>
            The flags parameter of the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call (<see cref="T:Un4seen.Bass.BASSInit"/>).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.speakers">
            <summary>The number of speakers the device/drivers supports... 2 means that there is no support for speaker assignment - this will always be the case with non-WDM drivers in Windows.
            <para>It's also possible that it could mistakenly be 2 with some devices/drivers, when the device in fact supports more speakers.</para>
            <para>In that case the BASS_DEVICE_SPEAKERS or BASS_DEVICE_CPSPEAKERS flag can be used in the <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> call to force the enabling of speaker assignment.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_INFO.freq">
            <summary>
            The device's current output sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_INFO.ToString">
            <summary>
            A description of the decive info object (speakers, rates, dx, eax).
            </summary>
            <returns>A description of the decive info object (speakers, rates, dx, eax).</returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsContinuousRate">
            <summary>
            The device supports all sample rates between minrate and maxrate.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsMonoSamples">
            <summary>
            Mono samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.SupportsStereoSamples">
            <summary>
            Stereo samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.Supports8BitSamples">
            <summary>
            8-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_INFO.Supports16BitSamples">
            <summary>
            16-bit samples are supported by hardware mixing.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_RECORDINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_RecordGetInfo(Un4seen.Bass.BASS_RECORDINFO)"/> to retrieve information on the current recording device.
            </summary>
            <remarks>
            <para>The formats member does not represent all the formats supported by the device, just the "standard" ones.</para>
            <para>If there is no DirectSound driver for the device (ie. it's being emulated), then the driver member will contain something like "WaveIn" instead of a filename.</para>
            <para><b>Platform-specific</b></para>
            <para>The flags member is only used on Windows. The formats member is only used on Windows/OSX/iOS, and only for the device's channel count in the case of OSX and iOS. On Windows, it does not necessarily represent all of the formats supported by the device, just the "standard" ones. freq is also only available on Windows/OSX/iOS, but not on Windows prior to Vista.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.flags">
            <summary>
            The device's capabilities <see cref="T:Un4seen.Bass.BASSRecordInfo"/>.
            A combination of these flags (see <see cref="T:Un4seen.Bass.BASSRecordInfo"/>):
            <list type="table">
            <item><term>DSCCAPS_EMULDRIVER</term><description>The device's drivers do NOT have DirectSound recording support, so it is being emulated.</description></item>
            <item><term>DSCCAPS_CERTIFIED</term><description>The device driver has been certified by Microsoft.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.formats">
            <summary>
            The standard formats supported by the device (default is WAVE_FORMAT_4S16).
            A combination of these flags (see <see cref="T:Un4seen.Bass.BASSRecordFormat"/>):
            <list type="table">
            <item><term>WAVE_FORMAT_1M08</term><description>11025hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_1S08</term><description>11025hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_1M16</term><description>11025hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_1S16</term><description>11025hz, Stereo, 16-bit</description></item>
            <item><term>WAVE_FORMAT_2M08</term><description>22050hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_2S08</term><description>22050hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_2M16</term><description>22050hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_2S16</term><description>22050hz, Stereo, 16-bit</description></item>
            <item><term>WAVE_FORMAT_4M08</term><description>44100hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_4S08</term><description>44100hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_4M16</term><description>44100hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_4S16</term><description>44100hz, Stereo, 16-bit</description></item>
            </list>
            The number of channels supported by the device is in the high 8 bits.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.inputs">
            <summary>
            The number of input sources available to the device
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.singlein">
            <summary>
            <see langword="true"/> = only one input may be active at a time
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_RECORDINFO.freq">
            <summary>
            The device's current input sample rate. This is only available on Windows Vista and OSX.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_RECORDINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_RECORDINFO.ToString">
            <summary>
            A description of the record decive info object (inputs, singlein).
            </summary>
            <returns>A description of the record decive info object (inputs, singlein).</returns>
        </member>
        <member name="P:Un4seen.Bass.BASS_RECORDINFO.WaveFormat">
            <summary>
            The standard wave formats supported by the device (default is WAVE_FORMAT_4S16).
            A combination of these flags (see <see cref="T:Un4seen.Bass.BASSRecordFormat"/>):
            <list type="table">
            <item><term>WAVE_FORMAT_1M08</term><description>11025hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_1S08</term><description>11025hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_1M16</term><description>11025hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_1S16</term><description>11025hz, Stereo, 16-bit</description></item>
            <item><term>WAVE_FORMAT_2M08</term><description>22050hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_2S08</term><description>22050hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_2M16</term><description>22050hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_2S16</term><description>22050hz, Stereo, 16-bit</description></item>
            <item><term>WAVE_FORMAT_4M08</term><description>44100hz, Mono, 8-bit</description></item>
            <item><term>WAVE_FORMAT_4S08</term><description>44100hz, Stereo, 8-bit</description></item>
            <item><term>WAVE_FORMAT_4M16</term><description>44100hz, Mono, 16-bit</description></item>
            <item><term>WAVE_FORMAT_4S16</term><description>44100hz, Stereo, 16-bit</description></item>
            </list>
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_RECORDINFO.Channels">
            <summary>
            Gets the available channel count for a recording input.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_RECORDINFO.SupportsDirectSound">
            <summary>
            The device's drivers has DirectSound support
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_RECORDINFO.IsCertified">
            <summary>
            The device driver has been certified by Microsoft. Always true for WDM drivers.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_FILEPROCS">
            <summary>
            Table of callback functions used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/>.
            </summary>
            <remarks>A copy is made of the procs callback function table, so it does not have to persist beyond this function call. 
            This means it is not required to pin the 'procs' instance, but it is still required to keep a reference as long as BASS uses the callback delegates in order to prevent the callbacks from being garbage collected.
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            ...
            private BASS_FILEPROCS _myStreamCreateUser;
            private FileStream _fs;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, this.Handle);
            // creating the user file callback delegates
            _myStreamCreateUser = new BASS_FILEPROCS(
                new FILECLOSEPROC(MyFileProcUserClose), 
                new FILELENPROC(MyFileProcUserLength), 
                new FILEREADPROC(MyFileProcUserRead), 
                new FILESEEKPROC(MyFileProcUserSeek));
            // open the file...
            _fs = File.OpenRead("test.mp3");
            // create the stream (the PRESCAN flag shows you what BASS is doing at the beginning to scan the entire file)
            // if that generates to much output for you, you can simply remove it
            int stream = Bass.BASS_StreamCreateFileUser(BASSStreamSystem.STREAMFILE_NOBUFFER, BASSFlag.BASS_STREAM_PRESCAN | BASSFlag.BASS_STREAM_AUTOFREE, _myStreamCreateUser, IntPtr.Zero);
            // play the channel
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MyFileProcUserClose(IntPtr user)
            {
              if (_fs == null)
                return;
              _fs.Close();
              Console.WriteLine("File Closed");
            }
            
            private long MyFileProcUserLength(IntPtr user)
            {
              if (_fs == null)
                return 0L;
              return _fs.Length;
            }
            
            private int MyFileProcUserRead(IntPtr buffer, int length, IntPtr user)
            {
              if (_fs == null)
                return 0;
              try
              {
                // at first we need to create a byte[] with the size of the requested length
                byte[] data = new byte[length];
                // read the file into data
                int bytesread = _fs.Read(data, 0, length);
                // and now we need to copy the data to the buffer
                // we write as many bytes as we read via the file operation
                Marshal.Copy(data, 0, buffer, bytesread);
                return bytesread;
              }
              catch { return 0; }
            }
            
            private bool MyFileProcUserSeek(long offset, IntPtr user)
            {
              if (_fs == null)
                return false;
              try
              {
                long pos = _fs.Seek(offset, SeekOrigin.Begin);
                return true;
              }
              catch
              {
                return false;
              }
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            ...
            Private _myStreamCreateUser As BASS_FILEPROCS
            Private _fs As FileStream
            ...
            Bass.BASS_Init(- 1, 44100, BASSInit.BASS_DEVICE_DEFAULT, Me.Handle)
            ' creating the user file callback delegates
            _myStreamCreateUser = New BASS_FILEPROCS(
                New FILECLOSEPROC(AddressOf MyFileProcUserClose), 
                New FILELENPROC(AddressOf MyFileProcUserLength), 
                New FILEREADPROC(AddressOf MyFileProcUserRead), 
                New FILESEEKPROC(AddressOf MyFileProcUserSeek))
            ' open the file...
            _fs = File.OpenRead("test.mp3")
            ' create the stream (the PRESCAN flag shows you what BASS is doing at the beginning to scan the entire file)
            ' if that generates to much output for you, you can simply remove it
            Dim stream As Integer = Bass.BASS_StreamCreateFileUser(BASSStreamSystem.STREAMFILE_NOBUFFER, BASSFlag.BASS_STREAM_PRESCAN Or BASSFlag.BASS_STREAM_AUTOFREE, _myStreamCreateUser, IntPtr.Zero)
            ' play the channel
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MyFileProcUserClose(user As IntPtr)
              If _fs Is Nothing Then
                Return
              End If 
              _fs.Close()
            End Sub
            
            Private Function MyFileProcUserLength(user As IntPtr) As Long
              If _fs Is Nothing Then
                Return 0L
              End If 
              Return _fs.Length   
            End Function
            
            Private Function MyFileProcUserRead(buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              If _fs Is Nothing Then
                Return 0
              End If 
              Try
                ' at first we need to create a byte[] with the size of the requested length
                Dim data(length - 1) As Byte
                ' read the file into data
                Dim bytesread As Integer = _fs.Read(data, 0, length)
                ' and now we need to copy the data to the buffer
                ' we write as many bytes as we read via the file operation
                Marshal.Copy(data, 0, buffer, bytesread)
                Return bytesread
              Catch
                Return 0
              End Try
            End Function
            
            Private Function MyFileProcUserSeek(offset As Long, user As IntPtr) As Boolean
              If _fs Is Nothing Then
                Return False
              End If 
              Try
                Dim pos As Long = _fs.Seek(offset, SeekOrigin.Begin)
                Return True
              Catch
                Return False
              End Try
            End Function
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.close">
            <summary>
            Callback function to close the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.length">
            <summary>
            Callback function to get the file length.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.read">
            <summary>
            Callback function to read from the file.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FILEPROCS.seek">
            <summary>
            Callback function to seek in the file. Not used by buffered file streams.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_FILEPROCS.#ctor(Un4seen.Bass.FILECLOSEPROC,Un4seen.Bass.FILELENPROC,Un4seen.Bass.FILEREADPROC,Un4seen.Bass.FILESEEKPROC)">
            <summary>
            Default constructor taking the callback delegates.
            </summary>
            <param name="closeCallback">The <see cref="T:Un4seen.Bass.FILECLOSEPROC"/> callback to use.</param>
            <param name="lengthCallback">The <see cref="T:Un4seen.Bass.FILELENPROC"/> callback to use.</param>
            <param name="readCallback">The <see cref="T:Un4seen.Bass.FILEREADPROC"/> callback to use.</param>
            <param name="seekCallback">The <see cref="T:Un4seen.Bass.FILESEEKPROC"/> callback to use.</param>
        </member>
        <member name="T:Un4seen.Bass.BASS_SAMPLE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_SampleSetInfo(System.Int32,Un4seen.Bass.BASS_SAMPLE)"/> to retrieve and set the default playback attributes of a sample.
            </summary>
            <remarks>
            <para>When a sample has 3D functionality, the iangle and oangle angles decide how wide the sound is projected around the orientation angle (as set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>). 
            Within the inside angle the volume level is the level set in the volume member (or the <see cref="F:Un4seen.Bass.BASSAttribute.BASS_ATTRIB_VOL"/> attribute when the sample is playing). 
            Outside the outer angle, the volume changes according to the outvol value. Between the inner and outer angles, the volume gradually changes between the inner and outer volume levels. 
            If the inner and outer angles are 360 degrees, then the sound is transmitted equally in all directions.</para>
            <para>When VAM is enabled, and neither the BASS_VAM_HARDWARE or BASS_VAM_SOFTWARE flags are specified, then the sample will be played in hardware if resources are available, and in software if no hardware resources are available.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.freq">
            <summary>
            Default playback rate (set to 44100 by default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.volume">
            <summary>
            Default volume... 0 (silent) to 1 (full, default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.pan">
            <summary>
            Default panning position -1 (full left) to +1 (full right) - defaulted to 0 = centre.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.flags">
            <summary>
            A combination of these flags (<see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>The samples's resolution is 8-bit. If neither this or the BASS_SAMPLE_FLOAT flags are present, then the sample's resolution is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>The samples's resolution is 32-bit floating-point.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>Looped?</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>The sample has 3D functionality enabled.</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX	</term><description>Mute the sample when it is at (or beyond) it's max distance (3D samples only).</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>The sample is not using hardware mixing... it is being mixed in software by DirectSound.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>DX7 voice allocation and management features are enabled (see below).</description></item>
            <item><term>BASS_SAMPLE_OVER_VOL</term><description>Override: the channel with the lowest volume is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_POS</term><description>Override: the longest playing channel is overriden.</description></item>
            <item><term>BASS_SAMPLE_OVER_DIST</term><description>Override: the channel furthest away (from the listener) is overriden (3D samples only).</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.length">
            <summary>
            The length in bytes.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.max">
            <summary>
            Maximum number of simultaneous playbacks (defaulted to 1).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.origres">
            <summary>
            The original resolution (bits per sample)... 0 = undefined (default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.chans">
            <summary>
            Number of channels... 1=mono, 2=stereo (default), etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.mingap">
            <summary>
            Minimum time gap in milliseconds between creating channels using <see cref="M:Un4seen.Bass.Bass.BASS_SampleGetChannel(System.Int32,System.Boolean)"/>. 
            This can be used to prevent flanging effects caused by playing a sample multiple times very close to eachother. 
            The default setting, when loading/creating a sample, is 0 (disabled).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.mode3d">
            <summary>
            The 3D processing mode... one of these flags (see <see cref="T:Un4seen.Bass.BASS3DMode"/>):
            <list type="table">
            <item><term>BASS_3DMODE_NORMAL</term><description>Normal 3D processing (default).</description></item>
            <item><term>BASS_3DMODE_RELATIVE</term><description>The sample's 3D position (position/velocity/orientation) is relative to the listener. When the listener's position/velocity/orientation is changed with <see cref="M:Un4seen.Bass.Bass.BASS_Set3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>, the sample's position relative to the listener does not change.</description></item>
            <item><term>BASS_3DMODE_OFF</term><description>Turn off 3D processing on the sample, the sound will be played in the center.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.mindist">
            <summary>
            The minimum distance (default 0). The sample's volume is at maximum when the listener is within this distance.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.maxdist">
            <summary>
            The maximum distance (default 0). The sample's volume stops decreasing when the listener is beyond this distance.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.iangle">
            <summary>
            The angle of the inside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.oangle">
            <summary>
            The angle of the outside projection cone in degrees... 0 (no cone, default) - 360 (sphere).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.outvol">
            <summary>
            The delta-volume outside the outer projection cone... 0 (silent) to 1 (full, default) - same as inside the cone.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.vam">
            <summary>
            The following are the sample's DX7 voice allocation/management settings (if VAM is enabled)...a combination of these (<see cref="T:Un4seen.Bass.BASSVam"/>):
            <list type="table">
            <item><term>BASS_VAM_HARDWARE</term><description>Play the sample in hardware (default). If no hardware voices are available then the play call will fail.</description></item>
            <item><term>BASS_VAM_SOFTWARE</term><description>Play the sample in software (ie. non-accelerated). No other VAM flags may be used together with this flag.</description></item>
            </list>
            The following flags enable hardware resource stealing... if the hardware has no available voices, a currently playing buffer will be stopped to make room for the new buffer. Only samples with VAM enabled are considered for termination:
            <list type="table">
            <item><term>BASS_VAM_TERM_TIME</term><description>If there are no free hardware voices, the buffer to be terminated will be the one with the least time left to play.</description></item>
            <item><term>BASS_VAM_TERM_DIST</term><description>If there are no free hardware voices, the buffer to be terminated will be one that was loaded/created with the BASS_SAMPLE_MUTEMAX flag and is beyond it's max distance (maxdist). If there are no buffers that match this criteria, then the play call will fail.</description></item>
            <item><term>BASS_VAM_TERM_PRIO</term><description>If there are no free hardware voices, the buffer to be terminated will be the one with the lowest priority. This flag may be used with the TERM_TIME or TERM_DIST flag, if multiple voices have the same priority then the time or distance is used to decide which to terminate.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_SAMPLE.priority">
            <summary>
            Priority, used with the BASS_VAM_TERM_PRIO flag... 0 (min, default) - 0xFFFFFFFF (max)
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_SAMPLE.origresValue">
            <summary>
            The original resolution value in bits per samples.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_SAMPLE.origresIsFloat">
            <summary>
            Is the original resolution floating point?
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_SAMPLE.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_SAMPLE.#ctor(System.Int32,System.Single,System.Single,Un4seen.Bass.BASSFlag,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Un4seen.Bass.BASS3DMode,System.Single,System.Single,System.Int32,System.Int32,System.Single,Un4seen.Bass.BASSVam,System.Int32)">
            <summary>
            Constructor to initialize the members.
            </summary>
            <param name="Freq">Default playback rate.</param>
            <param name="Volume">Default volume (0-1).</param>
            <param name="Pan">Default pan (-1=left, 0=middle, +1=right).</param>
            <param name="Flags">BASS_SAMPLE_xxx flags (<see cref="T:Un4seen.Bass.BASSFlag"/>).</param>
            <param name="Length">Length (in bytes).</param>
            <param name="Max">Maximum simultaneous playbacks.</param>
            <param name="OrigRes">Original resolution bits.</param>
            <param name="Chans">Number of channels.</param>
            <param name="MinGap">Minimum time gap in milliseconds between creating channels.</param>
            <param name="Flag3D">BASS_3DMODE_xxx mode (<see cref="T:Un4seen.Bass.BASS3DMode"/>).</param>
            <param name="MinDist">Minimum distance.</param>
            <param name="MaxDist">Maximum distance.</param>
            <param name="IAngle">Angle of inside projection cone.</param>
            <param name="OAngle">Angle of outside projection cone.</param>
            <param name="OutVol">Delta-volume outside the projection cone.</param>
            <param name="FlagsVam">Voice allocation/management flags (BASS_VAM_xxx flags <see cref="T:Un4seen.Bass.BASSVam"/>).</param>
            <param name="Priority">Priority (0=lowest, 0xffffffff=highest).</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_SAMPLE.ToString">
            <summary>
            A description of the record decive info object (driver file name, inputs etc.).
            </summary>
            <returns>A description of the record decive info object (driver file name, inputs etc.).</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_CHANNELINFO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetInfo(System.Int32,Un4seen.Bass.BASS_CHANNELINFO)"/> to retrieve information on a channel.
            </summary>
            <remarks>
            A "channel" can be a playing sample (HCHANNEL), a sample stream (HSTREAM), a MOD music (HMUSIC), or a recording (HRECORD).
            <para>Each "Channel" function can be used with one or more of these channel types.</para>
            <para>The BASS_SAMPLE_SOFTWARE flag indicates whether or not the channel's sample data is being mixed into the final output by the hardware. It does not indicate (in the case of a stream or MOD music) whether the processing required to generate the sample data is being done by the hardware, this processing is always done in software.</para>
            <para>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS. The origres member can be used to check what the resolution originally was.</para>
            </remarks>
            <example>
            <code>
            BASS_CHANNELINFO info = new BASS_CHANNELINFO();
            Bass.BASS_ChannelGetInfo(channel, info); // get info
            if (info.ctype == BassChannel.BASS_CTYPE_STREAM_MP3) 
            {
            	// it's an MP3!
            }
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.freq">
            <summary>
            Default playback rate.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.chans">
            <summary>
            Number of channels... 1=mono, 2=stereo, etc.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.flags">
            <summary>
            BASS_SAMPLE/STREAM/MUSIC/SPEAKER flags. A combination of these flags (see <see cref="T:Un4seen.Bass.BASSFlag"/>):
            <list type="table">
            <item><term>BASS_SAMPLE_8BITS</term><description>The channel's resolution is 8-bit. If neither this or the BASS_SAMPLE_FLOAT flags are present, then the channel's resolution is 16-bit.</description></item>
            <item><term>BASS_SAMPLE_FLOAT</term><description>The channel's resolution is 32-bit floating-point.</description></item>
            <item><term>BASS_SAMPLE_LOOP</term><description>The channel is looped.</description></item>
            <item><term>BASS_SAMPLE_3D</term><description>The channel has 3D functionality enabled.</description></item>
            <item><term>BASS_SAMPLE_SOFTWARE</term><description>The channel is NOT using hardware mixing... it doesn't benefit from any special hardware interpolation, etc.</description></item>
            <item><term>BASS_SAMPLE_VAM</term><description>The channel is using the DX7 voice allocation and management features. (HCHANNEL only)</description></item>
            <item><term>BASS_SAMPLE_MUTEMAX</term><description>The channel is muted when at (or beyond) it's max distance. (HCHANNEL)</description></item>
            <item><term>BASS_SAMPLE_FX</term><description>The channel has the "with FX flag" <a href="../Overview.html#DX8DMOEffects">DX8 effects implementation</a> enabled. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_STREAM_RESTRATE</term><description>The internet file download rate is restricted. (HSTREAM)</description></item>
            <item><term>BASS_STREAM_BLOCK</term><description>The internet file (or "buffered" user file) is streamed in small blocks. (HSTREAM)</description></item>
            <item><term>BASS_STREAM_AUTOFREE</term><description>The channel will automatically be freed when it ends. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_STREAM_DECODE</term><description>The channel is a "decoding channel". (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_MUSIC_RAMP</term><description>The MOD music is using "normal" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_RAMPS</term><description>The MOD music is using "sensitive" ramping. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND</term><description>The MOD music is using surround sound. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_SURROUND2</term><description>The MOD music is using surround sound mode 2. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_NONINTER</term><description>The MOD music is using non-interpolated mixing. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_FT2MOD</term><description>The MOD music is using FastTracker 2 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_PT1MOD</term><description>The MOD music is using ProTracker 1 .MOD playback. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESET</term><description>All notes will be stopped when seeking in the MOD music. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_POSRESETEX</term><description>All notes will be stopped and BPM/etc reset when seeking in the MOD music. (HMUSIC)</description></item>
            <item><term>BASS_MUSIC_STOPBACK</term><description>The MOD music will be stopped when a backward jump effect is played. (HMUSIC)</description></item>
            <item><term>BASS_SPEAKER_xxx</term><description><a scr="../Overview.html#SpeakerAssignement">Speaker assignment flags</a>. (HSTREAM/HMUSIC)</description></item>
            <item><term>BASS_UNICODE</term><description>A filename, command-line or argument is a Unicode (UTF-16) string.</description></item>
            </list>
            <i>Other flags may be supported by add-ons, see the documentation.</i>
            </summary>
            <remarks><b>Platform-specific</b>
            <para>On Linux/iOS/OSX, the BASS_UNICODE flag may not be present even if it was used in the stream's creation, as BASS will have translated the filename to the native UTF-8 form. On Windows CE, the opposite is true: the BASS_UNICODE flag may be present even if it was not used in the stream's creation, as BASS will have translated the filename to the native UTF-16 form.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.ctype">
            <summary>
            The type of channel it is, which can be one of the following (see <see cref="T:Un4seen.Bass.BASSChannelType"/>), or another value if it's an add-on format (see the add-on's API).
            <list type="table">
            <item><term>BASS_CTYPE_SAMPLE</term><description>Sample channel. (HCHANNEL)</description></item>
            <item><term>BASS_CTYPE_STREAM</term><description>User sample stream. This can also be used as a flag to test if the channel is any kind of HSTREAM.</description></item>
            <item><term>BASS_CTYPE_STREAM_OGG</term><description>OGG format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_MP1</term><description>MP1 format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_MP2</term><description>MP2 format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_MP3</term><description>MP3 format file stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_AIFF</term><description>Audio IFF format stream.</description></item>
            <item><term>BASS_CTYPE_STREAM_CA</term><description>CoreAudio codec stream. Additional information is avaliable via the <see cref="T:Un4seen.Bass.BASS_TAG_CACODEC"/> tag.</description></item>
            <item><term>BASS_CTYPE_STREAM_MF</term><description>Media Foundation codec stream. Additional format information is avaliable from <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> (BASS_TAG_WAVEFORMAT).</description></item>
            <item><term>BASS_CTYPE_STREAM_WAV</term><description>WAVE format flag. This can be used to test if the channel is any kind of WAVE format (LOWORD contains the codec number).</description></item>
            <item><term>BASS_CTYPE_STREAM_WAV_PCM</term><description>WAV format file stream, PCM.</description></item>
            <item><term>BASS_CTYPE_STREAM_WAV_FLOAT</term><description>WAV format file stream, Floating-Point.</description></item>
            <item><term>BASS_CTYPE_MUSIC_MOD</term><description>MOD format music. This can also be used as a flag to test if the channel is any kind of HMUSIC.</description></item>
            <item><term>BASS_CTYPE_MUSIC_MTM</term><description>MTM format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_S3M</term><description>S3M format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_XM</term><description>XM format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_IT</term><description>IT format music.</description></item>
            <item><term>BASS_CTYPE_MUSIC_MO3</term><description>MO3 format flag, used in combination with one of the BASS_CTYPE_MUSIC types.</description></item>
            <item><term>BASS_CTYPE_RECORD</term><description>Recording channel. (HRECORD)</description></item>
            </list>
            <i>Other channel types may be supported by add-ons, see the documentation.</i>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.origres">
            <summary>
            The original resolution (bits per sample)... 0 = undefined.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.plugin">
            <summary>
            The plugin that is handling the channel... 0 = not using a plugin. 
            <para>Note this is only available with streams created using the plugin system via the standard BASS stream creation functions, not those created by add-on functions. 
            Information on the plugin can be retrieved via <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/>.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.sample">
            <summary>
            The sample that is playing on the channel. (HCHANNEL only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.filename">
            <summary>
            The filename associated with the channel. (HSTREAM only)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_CHANNELINFO.origresIsFloat">
            <summary>
            Is the original resolution floating point?
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_CHANNELINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_CHANNELINFO.IsDecodingChannel">
            <summary>
            Is the channel a decoding channel?
            </summary>
            <remarks>Checks, that the <see cref="F:Un4seen.Bass.BASS_CHANNELINFO.flags"/> property contains the BASS_STREAM_DECODE resp. BASS_MUSIC_DECODE flag.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_CHANNELINFO.Is32bit">
            <summary>
            Gets, if the <see cref="F:Un4seen.Bass.BASS_CHANNELINFO.flags"/> property contains the BASS_SAMPLE_FLOAT resp. BASS_MUSIC_FLOAT flag.
            </summary>
            <remarks><see langword="true"/> is returned for floating-point channels - else <see langword="false"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_CHANNELINFO.Is8bit">
            <summary>
            Gets, if the <see cref="F:Un4seen.Bass.BASS_CHANNELINFO.flags"/> property contains the BASS_SAMPLE_8BITS resp. BASS_MUSIC_8BITS flag.
            </summary>
            <remarks><see langword="true"/> is returned for 8-bit channels - else <see langword="false"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_CHANNELINFO.ToString">
            <summary>
            A description of the decive info object (driver file name, inputs etc.).
            </summary>
            <returns>A description of the decive info object (driver file name, inputs etc.).</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_3DVECTOR">
            <summary>
            Structure used by the 3D functions to describe positions, velocities, and orientations (e.g. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSet3DPosition(System.Int32,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_Get3DPosition(Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR,Un4seen.Bass.BASS_3DVECTOR)"/>).
            </summary>
            <remarks>
            The left-handed coordinate system is used.
            </remarks>
            Updates the position, velocity and top of the listener:
            <code>
            BASS_3DVECTOR position = new BASS_3DVECTOR(camera.RealPosition.x, camera.RealPosition.y, camera.RealPosition.z);
            BASS_3DVECTOR direction = new BASS_3DVECTOR(camera.RealDirection.x, camera.RealDirection.y, camera.RealDirection.z);
            BASS_3DVECTOR up = new BASS_3DVECTOR(-camera.RealUp.x, -camera.RealUp.y, -camera.RealUp.z);
            
            if (!Bass.BASS_Set3DPosition(position, velocity, direction, up))
                throw new AudioException("Could not set the 3d position of the listener", "listener", Bass.BASS_ErrorGetCode());
                
            Bass.BASS_Apply3D();
            </code>
            <code lang="vbnet">
            Dim position As New BASS_3DVECTOR(camera.RealPosition.x, camera.RealPosition.y, camera.RealPosition.z)
            Dim direction As New BASS_3DVECTOR(camera.RealDirection.x, camera.RealDirection.y, camera.RealDirection.z)
            Dim up As New BASS_3DVECTOR(-camera.RealUp.x, -camera.RealUp.y, -camera.RealUp.z)
            
            If Not Bass.BASS_Set3DPosition(position, velocity, direction, up) Then
                Throw New AudioException("Could not set the 3d position of the listener", "listener", Bass.BASS_ErrorGetCode())
            End If
            
            Bass.BASS_Apply3D()
            </code>
        </member>
        <member name="F:Un4seen.Bass.BASS_3DVECTOR.x">
            <summary>
            +values=right, -values=left (default=0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_3DVECTOR.y">
            <summary>
            +values=up, -values=down (default=0)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_3DVECTOR.z">
            <summary>
            +values=front, -values=behind (default=0)
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_3DVECTOR.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_3DVECTOR.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            constructor to initialize the members
            </summary>
            <param name="X">X value (+=right, -=left)</param>
            <param name="Y">Y value (+=up, -=down)</param>
            <param name="Z">Z value (+=front, -=behind)</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_3DVECTOR.ToString">
            <summary>
            The 3D vector as a descriptive string (X=, Y=, Z=).
            </summary>
            <returns>The 3D vector as a descriptive string (X=, Y=, Z=)</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_CHORUS">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a chorus effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.lWaveform">
            <summary>
            Waveform of the LFO... 0 = triangle, 1 = sine. By default, the waveform is a sine.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_CHORUS.lPhase">
            <summary>
            Phase differential between left and right LFOs, one of <see cref="T:Un4seen.Bass.BASSFXPhase"/> values. Default is (int)BASSFXPhase.BASS_FX_PHASE_ZERO.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Un4seen.Bass.BASSFXPhase)">
            <summary>
            constructor to initialize the members
            </summary>
            <param name="WetDryMix">Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).</param>
            <param name="Depth">Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100.</param>
            <param name="Feedback">Percentage of output signal to feed back into the effect's input, in the range from -99 to 99.</param>
            <param name="Frequency">Frequency of the LFO, in the range from 0 to 10.</param>
            <param name="Waveform">Waveform of the LFO... 0 = triangle, 1 = sine.</param>
            <param name="Delay">Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20.</param>
            <param name="Phase">Phase differential between left and right LFOs (see <see cref="T:Un4seen.Bass.BASSFXPhase"/>).</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.Preset_A">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_CHORUS.Preset_B">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_COMPRESSOR">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a compression effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fGain">
            <summary>
            Output gain of signal in dB after compression, in the range from -60 to 60. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fAttack">
            <summary>
            Time in ms before compression reaches its full value, in the range from 0.01 to 500. The default value is 10 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fRelease">
            <summary>
            Time (speed) in ms at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000. The default value is 200 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fThreshold">
            <summary>
            Point at which compression begins, in dB, in the range from -60 to 0. The default value is -20 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fRatio">
            <summary>
            Compression ratio, in the range from 1 to 100. The default value is 3, which means 3:1 compression.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_COMPRESSOR.fPredelay">
            <summary>
            Time in ms after fThreshold is reached before attack phase is started, in milliseconds, in the range from 0 to 4. The default value is 4 ms.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor to already set the members
            </summary>
            <param name="Gain">Output gain of signal after compression, in the range from -60 to 60.</param>
            <param name="Attack">Time before compression reaches its full value, in the range from 0.01 to 500.</param>
            <param name="Release">Speed at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000.</param>
            <param name="Threshold">Point at which compression begins, in decibels, in the range from -60 to 0.</param>
            <param name="Ratio">Compression ratio, in the range from 1 to 100.</param>
            <param name="Predelay">Time after lThreshold is reached before attack phase is started, in milliseconds, in the range from 0 to 4.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Soft">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Soft2">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Medium">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Hard">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_Hard2">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_COMPRESSOR.Preset_HardCommercial">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_DISTORTION">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a distortion effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fGain">
            <summary>
            Amount of signal change after distortion, in the range from -60 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fEdge">
            <summary>
            Percentage of distortion intensity, in the range in the range from 0 through 100. The default value is 50 percent.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fPostEQCenterFrequency">
            <summary>
            Center frequency of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fPostEQBandwidth">
            <summary>
            Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_DISTORTION.fPreLowpassCutoff">
            <summary>
            Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000. The default value is 4000 Hz.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_DISTORTION.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_DISTORTION.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="Gain">Amount of signal change after distortion, in the range from -60 through 0.</param>
            <param name="Edge">Percentage of distortion intensity, in the range in the range from 0 through 100.</param>
            <param name="PostEQCenterFrequency">Center frequency of harmonic content addition, in the range from 100 through 8000.</param>
            <param name="PostEQBandwidth">Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000.</param>
            <param name="PreLowpassCutoff">Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_DISTORTION.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_ECHO">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a echo effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fFeedback">
            <summary>
            Percentage of output fed back into input, in the range from 0 through 100. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fLeftDelay">
            <summary>
            Delay for left channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.fRightDelay">
            <summary>
            Delay for right channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_ECHO.lPanDelay">
            <summary>
            Value that specifies whether to swap left and right delays with each successive echo. The default value is <see langword="false"/>, meaning no swap.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.#ctor(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="WetDryMix">Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).</param>
            <param name="Feedback">Percentage of output fed back into input, in the range from 0 through 100.</param>
            <param name="LeftDelay">Delay for left channel, in milliseconds, in the range from 1 through 2000.</param>
            <param name="RightDelay">Delay for right channel, in milliseconds, in the range from 1 through 2000.</param>
            <param name="PanDelay">Value that specifies whether to swap left and right delays with each successive echo.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.Preset_Small">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_ECHO.Preset_Long">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_FLANGER">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a flanger effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fWetDryMix">
            <summary>
            Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 (default) through 100 (all wet).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fDepth">
            <summary>
            Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fFeedback">
            <summary>
            Percentage of output signal to feed back into the effect's input, in the range from -99 to 99. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fFrequency">
            <summary>
            Frequency of the LFO, in the range from 0 to 10. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.lWaveform">
            <summary>
            Waveform of the LFO... 0 = triangle, 1 = sine. By default, the waveform is a sine.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.fDelay">
            <summary>
            Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4. The default value is 0 ms.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_FLANGER.lPhase">
            <summary>
            Phase differential between left and right LFOs, one of the <see cref="T:Un4seen.Bass.BASSFXPhase"/> values. Default (int)BASSFXPhase.BASS_FX_PHASE_ZERO.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.#ctor(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,Un4seen.Bass.BASSFXPhase)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="WetDryMix">Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).</param>
            <param name="Depth">Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100.</param>
            <param name="Feedback">Percentage of output signal to feed back into the effect's input, in the range from -99 to 99.</param>
            <param name="Frequency">Frequency of the LFO, in the range from 0 to 10.</param>
            <param name="Waveform">Waveform of the LFO... 0 = triangle, 1 = sine.</param>
            <param name="Delay">Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4.</param>
            <param name="Phase">Phase differential between left and right LFOs, one of <see cref="T:Un4seen.Bass.BASSFXPhase"/>.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.Preset_A">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_FLANGER.Preset_B">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_GARGLE">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a gargle effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_GARGLE.dwRateHz">
            <summary>
            Rate of modulation, in Hertz. Must be in the range from 1 through 1000. Default 500 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_GARGLE.dwWaveShape">
            <summary>
            Shape of the modulation wave... 0 = triangle, 1 = square (default).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_GARGLE.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_GARGLE.#ctor(System.Int32,System.Int32)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="RateHz">Rate of modulation, in Hertz. Must be in the range from 1 through 1000.</param>
            <param name="WaveShape">Shape of the modulation wave... 0 = triangle, 1 = square.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_GARGLE.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_I3DL2REVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of an I3DL2 (Interactive 3D Audio Level 2) reverberation effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lRoom">
            <summary>
            Attenuation of the room effect, in millibels (mB), in the range from -10000 to 0. The default value is -1000 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lRoomHF">
            <summary>
            Attenuation of the room high-frequency effect, in mB, in the range from -10000 to 0. The default value is 0 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flRoomRolloffFactor">
            <summary>
            Rolloff factor for the reflected signals, in the range from 0 to 10. The default value is 0.0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDecayTime">
            <summary>
            Decay time, in seconds, in the range from 0.1 to 20. The default value is 1.49 second.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDecayHFRatio">
            <summary>
            Ratio of the decay time at high frequencies to the decay time at low frequencies, in the range from 0.1 to 2. The default value is 0.83.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lReflections">
            <summary>
            Attenuation of early reflections relative to lRoom, in mB, in the range from -10000 to 1000. The default value is -2602 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flReflectionsDelay">
            <summary>
            Delay time of the first reflection relative to the direct path, in seconds, in the range from 0 to 0.3. The default value is 0.007 seconds.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.lReverb">
            <summary>
            Attenuation of late reverberation relative to lRoom, in mB, in the range from -10000 to 2000. The default value is 200 mB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flReverbDelay">
            <summary>
            Time limit between the early reflections and the late reverberation relative to the time of the first reflection, in seconds, in the range from 0 to 0.1. The default value is 0.011 seconds.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDiffusion">
            <summary>
            Echo density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flDensity">
            <summary>
            Modal density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_I3DL2REVERB.flHFReference">
            <summary>
            Reference high frequency, in hertz, in the range from 20 to 20000. The default value is 5000.0 Hz.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_I3DL2REVERB.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_I3DL2REVERB.#ctor(System.Int32,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="Room">Attenuation of the room effect, in millibels (mB), in the range from -10000 to 0.</param>
            <param name="RoomHF">Attenuation of the room high-frequency effect, in mB, in the range from -10000 to 0.</param>
            <param name="RoomRolloffFactor">Rolloff factor for the reflected signals, in the range from 0 to 10.</param>
            <param name="DecayTime">Decay time, in seconds, in the range from 0.1 to 20.</param>
            <param name="DecayHFRatio">Ratio of the decay time at high frequencies to the decay time at low frequencies, in the range from 0.1 to 2.</param>
            <param name="Reflections">Attenuation of early reflections relative to lRoom, in mB, in the range from -10000 to 1000.</param>
            <param name="ReflectionsDelay">Delay time of the first reflection relative to the direct path, in seconds, in the range from 0 to 0.3.</param>
            <param name="Reverb">Attenuation of late reverberation relative to lRoom, in mB, in the range from -10000 to 2000.</param>
            <param name="ReverbDelay">Time limit between the early reflections and the late reverberation relative to the time of the first reflection, in seconds, in the range from 0 to 0.1.</param>
            <param name="Diffusion">Echo density in the late reverberation decay, in percent, in the range from 0 to 100.</param>
            <param name="Density">Modal density in the late reverberation decay, in percent, in the range from 0 to 100.</param>
            <param name="HFReference">Reference high frequency, in hertz, in the range from 20 to 20000.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_I3DL2REVERB.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_PARAMEQ">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a parametric equalizer effect.
            </summary>
            <remarks>
            <para><b>Platform-specific</b></para>
            <para>On Windows, fCenter must be in the range of 80 to 16000, and not exceed one-third of the channel's sample rate. On other platforms, the range is above 0 Hz and below half the channel's sample rate.</para>
            </remarks>
            <example>
            Setting up a 3-band EQ:
            <code>
            private int[] _fxEQ = {0, 0, 0};
            ...
            // 3-band EQ
            BASS_DX8_PARAMEQ eq = new BASS_DX8_PARAMEQ();
            _fxEQ[0] = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0);
            _fxEQ[1] = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0);
            _fxEQ[2] = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0);
            eq.fBandwidth = 18f;
            eq.fCenter = 100f;
            eq.fGain = 0f;
            Bass.BASS_FXSetParameters(_fxEQ[0], eq);
            eq.fCenter = 1000f;
            Bass.BASS_FXSetParameters(_fxEQ[1], eq);
            eq.fCenter = 8000f;
            Bass.BASS_FXSetParameters(_fxEQ[2], eq);
            ...
            private void UpdateEQ(int band, float gain)
            {
              BASS_DX8_PARAMEQ eq = new BASS_DX8_PARAMEQ();
              if (Bass.BASS_FXGetParameters(_fxEQ[band], eq))
              {
                eq.fGain = gain;
                Bass.BASS_FXSetParameters(_fxEQ[band], eq);
              }
            }
            </code>
            <code lang="vbnet">
            Private _fxEQ As Integer() =  {0, 0, 0}
            ...
            ' 3-band EQ
            Dim eq As New BASS_DX8_PARAMEQ()
            _fxEQ(0) = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0)
            _fxEQ(1) = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0)
            _fxEQ(2) = Bass.BASS_ChannelSetFX(_stream, BASSFXType.BASS_FX_DX8_PARAMEQ, 0)
            eq.fBandwidth = 18F
            eq.fCenter = 100F
            Bass.BASS_FXSetParameters(_fxEQ(0), eq)
            eq.fCenter = 1000F
            Bass.BASS_FXSetParameters(_fxEQ(1), eq)
            eq.fCenter = 8000F
            Bass.BASS_FXSetParameters(_fxEQ(2), eq)
            ...
            Private Sub UpdateEQ(band As Integer, gain As Single)
              Dim eq As New BASS_DX8_PARAMEQ()
              If Bass.BASS_FXGetParameters(_fxEQ(band), eq) Then
                eq.fGain = gain
                Bass.BASS_FXSetParameters(_fxEQ(band), eq)
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_PARAMEQ.fCenter">
            <summary>
            Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the channel. Default 100 Hz.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_PARAMEQ.fBandwidth">
            <summary>
            Bandwidth, in semitones, in the range from 1 to 36. Default 18 semitones.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_PARAMEQ.fGain">
            <summary>
            Gain, in the range from -15 to 15. Default 0 dB.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="Center">Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the channel.</param>
            <param name="Bandwidth">Bandwidth, in semitones, in the range from 1 to 36.</param>
            <param name="Gain">Gain in dB, in the range from -15 to 15.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_Low">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_Mid">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_PARAMEQ.Preset_High">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_DX8_REVERB">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a reverb effect.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fInGain">
            <summary>
            Input gain of signal, in decibels (dB), in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fReverbMix">
            <summary>
            Reverb mix, in dB, in the range from -96 through 0. The default value is 0 dB.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fReverbTime">
            <summary>
            Reverb time, in milliseconds, in the range from 0.001 through 3000. The default value is 1000.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_DX8_REVERB.fHighFreqRTRatio">
            <summary>
            In the range from 0.001 through 0.999. The default value is 0.001.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_REVERB.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_REVERB.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="InGain">Input gain of signal, in decibels (dB), in the range from -96 through 0.</param>
            <param name="ReverbMix">Reverb mix, in dB, in the range from -96 through 0.</param>
            <param name="ReverbTime">Reverb time, in milliseconds, in the range from 0.001 through 3000.</param>
            <param name="HighFreqRTRatio">In the range from 0.001 through 0.999.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_DX8_REVERB.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_FX_VOLUME_PARAM">
            <summary>
            Used with <see cref="M:Un4seen.Bass.Bass.BASS_FXGetParameters(System.Int32,System.Object)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/> to retrieve and set the parameters of a volume level effect.
            </summary>
            <remarks>
            The fTime value is based on the channel's original sample rate. If the playback rate is changed via the BASS_ATTRIB_FREQ attribute, then the transition time that is heard will be affected accordingly.
            <para>When retrieving parameters, the returned fCurrent value is the level that is currently being applied, not necessarily the level that was last set via <see cref="M:Un4seen.Bass.Bass.BASS_FXSetParameters(System.Int32,System.Object)"/>. 
            During playback, it may not be the value that is currently being heard, due to buffering.</para>
            <para>Unlike the BASS_ATTRIB_VOL attribute, this effect modifies the channel's sample data, so it can be used to change the level of decoding channels and recording channels. 
            The BASS_CONFIG_CURVE_VOL setting does not affect this effect; the fTarget and fCurrent values are always linear.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_FX_VOLUME_PARAM.fTarget">
            <summary>
            The new volume level... 0 = silent, 1.0 = normal, above 1.0 = amplification. The default value is 1.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FX_VOLUME_PARAM.fCurrent">
            <summary>
            The current volume level... -1 = leave existing current level when setting parameters. The default value is 1.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FX_VOLUME_PARAM.fTime">
            <summary>
            The time to take to transition from the current level to the new level, in seconds. The default value is 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_FX_VOLUME_PARAM.lCurve">
            <summary>
            The curve to use in the transition... 0 = linear, 1 = logarithmic. The default value is 0.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_FX_VOLUME_PARAM.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_FX_VOLUME_PARAM.#ctor(System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            constructor already setting the members
            </summary>
            <param name="target">The new volume level... 0 = silent, 1.0 = normal, above 1.0 = amplification.</param>
            <param name="current">The current volume level... -1 = leave existing current level when setting parameters.</param>
            <param name="time">The time to take to transition from the current level to the new level, in seconds.</param>
            <param name="curve">The curve to use in the transition... 0 = linear, 1 = logarithmic.</param>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_ID3">
            <summary>
            TAG structure of an ID3v1 block to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
            <remarks>Use 'Marshal.PtrToStructure' to convert a tag pointer to this structure.</remarks>
            <example>
            <code>
            IntPtr p = Bass.BASS_ChannelGetTags(stream, BASSTag.BASS_TAG_ID3);
            if (p != IntPtr.Zero)
            {
              BASS_TAG_ID3 id3 = (BASS_TAG_ID3)Marshal.PtrToStructure(p, typeof(BASS_TAG_ID3));
              ...
            }
            </code>
            <code lang="vbnet">
            Dim p As IntPtr = Bass.BASS_ChannelGetTags(stream, BASSTag.BASS_TAG_ID3) 
            If p &lt;&gt; IntPtr.Zero Then 
                Dim id3 As BASS_TAG_ID3 = DirectCast(Marshal.PtrToStructure(p, GetType(BASS_TAG_ID3)), BASS_TAG_ID3) 
                ...
            End If 
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_ID3.ID">
            <summary>
            The id string (should be 'TAG').
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_ID3.Title">
            <summary>
            The title string (max. 30 characters).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_ID3.Artist">
            <summary>
            The artist string (max. 30 characters).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_ID3.Album">
            <summary>
            The album string (max. 30 characters).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_ID3.Year">
            <summary>
            The year string (max. 4 characters).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_ID3.Comment">
            <summary>
            The comment string (max. 28 characters).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_ID3.Dummy">
            <summary>
            The Dummy 0.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_ID3.Track">
            <summary>
            The track number.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_ID3.Genre">
            <summary>
            The genre id.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_BEXT">
            <summary>
            TAG structure of a BWF BEXT block to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
            <remarks>Use 'Marshal.PtrToStructure' to convert a tag pointer to this structure.</remarks>
            <example>
            <code>
            IntPtr p = Bass.BASS_ChannelGetTags(stream, BASSTag.BASS_TAG_RIFF_BEXT);
            if (p != IntPtr.Zero)
            {
              BASS_TAG_BEXT bext = (BASS_TAG_BEXT)Marshal.PtrToStructure(p, typeof(BASS_TAG_BEXT));
              string codingHist = bext.GetCodingHistory(p);
              ...
            }
            </code>
            <code lang="vbnet">
            Dim p As IntPtr = Bass.BASS_ChannelGetTags(stream, BASSTag.BASS_TAG_RIFF_BEXT) 
            If p &lt;&gt; IntPtr.Zero Then 
                Dim bext As BASS_TAG_BEXT = DirectCast(Marshal.PtrToStructure(p, GetType(BASS_TAG_BEXT)), BASS_TAG_BEXT) 
                Dim codingHist As String = bext.GetCodingHistory(p) 
                ...
            End If 
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_BEXT.Description">
            <summary>
            The description or title (max. 256 characters).
            </summary>
            <remarks>
            The description might contain a short and/or a long
            description. If this field is splitted (by a ";") the first
            entry will contain the short description and the
            second entry will contain the long description.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_BEXT.Originator">
            <summary>
            The name of the originator or artist (max. 32 characters).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_BEXT.OriginatorReference">
            <summary>
            The reference of the originator or encoded by (max. 32 characters).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_BEXT.OriginationDate">
            <summary>
            The date of creation (max. 10 characters, in format yyyy-mm-dd).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_BEXT.OriginationTime">
            <summary>
            The time of creation (max. 10 characters, in format hh:mm:ss).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_BEXT.TimeReference">
            <summary>
            First sample count since midnight (little-endian).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_BEXT.Version">
            <summary>
            The BWF version (little-endian)
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_BEXT.UMID">
            <summary>
            The SMPTE UMID as a hex string in the format 'XX XX XX... XX'.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_BEXT.Reserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_BEXT.ToString">
            <summary>
            The description field of the TAG structure.
            </summary>
            <returns>The description field of the TAG structure.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_BEXT.GetCodingHistory(System.IntPtr)">
            <summary>
            Returns the coding history for a given BASS_TAG_RIFF_BEXT tag pointer.
            </summary>
            <param name="tag">The bext tag pointer as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</param>
            <returns>The coding history string or <see langword="null"/> (if the tag pointer is not valid).</returns>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_BEXT.AsByteArray(System.String)">
            <summary>
            Returns a byte array containing the data of this instance plus the given <paramref name="codingHistory"/>.
            </summary>
            <param name="codingHistory">The new (total) coding history string to add to this structure.</param>
            <returns>The byte array containing the instance data plus the given <paramref name="codingHistory"/>.</returns>
            <remarks>This method might be used to create a raw BEXT data chunk (e.g. to be used with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.IntPtr,System.Int32)"/> method).</remarks>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_CART">
            <summary>
            TAG structure of a BWF CART block to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.
            </summary>
            <remarks>Use 'Marshal.PtrToStructure' to convert a tag pointer to this structure.</remarks>
            <example>
            <code>
            IntPtr p = Bass.BASS_ChannelGetTags(stream, BASSTag.BASS_TAG_RIFF_CART);
            if (p != IntPtr.Zero)
            {
              BASS_TAG_CART cart = (BASS_TAG_CART)Marshal.PtrToStructure(p, typeof(BASS_TAG_CART));
              string tagText = cart.GetTagText(p);
              ...
            }
            </code>
            <code lang="vbnet">
            Dim p As IntPtr = Bass.BASS_ChannelGetTags(stream, BASSTag.BASS_TAG_RIFF_CART) 
            If p &lt;&gt; IntPtr.Zero Then 
                Dim cart As BASS_TAG_CART = DirectCast(Marshal.PtrToStructure(p, GetType(BASS_TAG_CART)), BASS_TAG_CART) 
                Dim tagText As String = cart.GetTagText(p) 
                ...
            End If 
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Version">
            <summary>
            The version of the cart data structure (4 characters).
            </summary>
            <remarks>
            The first two numbers shall give the major release level (with leading 0) from 00 to 99
            and the last two shall give the revision level (with leading 0) in the range of 00 to
            99. The version number of the cart data structure as described in this
            document shall be version 1.01, and thus is represented by the string 0101.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Title">
            <summary>
            The title of the cut (max. 64 characters).
            </summary>
            <remarks>
            The title should be a descriptive summary of the audio contents of the file, and may be
            used as an entry into a table of contents, and so on. Applications that do not
            support a 64-character title may truncate the field as needed.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Artist">
            <summary>
            The artist of the cut (max. 64 characters).
            </summary>
            <remarks>
            ASCII string, 64-characters or less, holding the artist or creator name for the audio cut.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.CutID">
            <summary>
            The cut number identification (max. 64 characters).
            </summary>
            <remarks>
            ASCII string, 64-characters or less, representing the cut number, or unique cut
            key. The string shall be left justified. Some consumer systems can have
            restricted cut number lengths or allowable character set. These applications
            should provide some means of synthesizing a usable cut identifier if it has such
            restrictions.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.ClientID">
            <summary>
            The client identification (max. 64 characters).
            </summary>
            <remarks>
            ASCII string, 64-characters or less, holding a client or customer identification or name.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Category">
            <summary>
            The category identification (e.g. PSA, NEWS etc. - max. 64 characters).
            </summary>
            <remarks>
            ASCII string, 64-characters or less, holding a category name. The category
            name may be application dependent. Applications should use common category names. E.g.:
            <para>
            ALL, BED, BEDS, BIT, BITS, COM, COMM, CON, CONT, DAY, EB, EFX, FIL, FILL, ID, INT, INTR, JIN, JING, LIN, LINE, LOG, LOGO, MAG, MAGI, MUS, MUSC, NET, NETW, NEW, NEWS, PRO, PROM, PSA, SEG, SHW, SHOW, SND, SPO, SPOT, SPR, SPRT, STG, STAG, STK, STAK, SWP, SWEP, TST, TEST, TMP, TEMP.
            </para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Classification">
            <summary>
            The classification or auxiliary key (max. 64 characters).
            </summary>
            <remarks>
            ASCII string, 64-characters or less, holding a classification key. This key may
            be used for general classification, selection or sorting based on language,
            locale or other similar applications.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.OutCue">
            <summary>
            The out cue text (max. 64 characters).
            </summary>
            <remarks>
            ASCII string, 64-characters or less, holding the optional out cue phrase to be
            displayed when the cut is being played. This shall be a user readable cue
            string.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.StartDate">
            <summary>
            The start date of the cut (max. 10 characters, in format yyyy-mm-dd).
            </summary>
            <remarks>
            An ASCII date string of the form yyyy-mm-dd, such as 1998-12-25, holding the
            start date. Any valid date can be used. To signify an immediate start date, use
            '1900-01-01.'
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.StartTime">
            <summary>
            The start time of cut (max. 10 characters, in format hh:mm:ss).
            </summary>
            <remarks>
            An ASCII time string of the form hh:mm:ss, such as 12:31:45, representing the
            24 hour time-of-day for the start time on the assigned <see cref="P:Un4seen.Bass.BASS_TAG_CART.StartDate"/>. If blank,
            assume 00:00:00.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.EndDate">
            <summary>
            The end date of the cut (max. 10 characters, in format yyyy-mm-dd).
            </summary>
            <remarks>
            As in start date, but shall indicate the date after which the sequence will no
            longer be active. If the sequence is to run forever, the date shall be 9999-12-31.
            There shall be no default for this field.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.EndTime">
            <summary>
            The end time of cut (max. 10 characters, in format hh:mm:ss).
            </summary>
            <remarks>
            This code shall indicate the time of day on the appointed end date after which
            the sequence becomes inactive. If blank, applications shall assume an end
            time of 23:59:59.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.ProducerAppID">
            <summary>
            The name of the vendor or application (max. 64 characters).
            </summary>
            <remarks>
            An ASCII string, 64 characters or less, containing the vendor name, product
            name or both of the program or application that produced the WAVE file with
            this cart chunk.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.ProducerAppVersion">
            <summary>
            The version of the producer application (max. 64 characters).
            </summary>
            <remarks>
            An ASCII string, 64 characters or less, containing the version of the program
            or applications that produced the WAVE file containing the cart chunk.
            Because this string is informational only, the application may represent the
            version in any convenient format.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.UserDef">
            <summary>
            A user defined text (max. 64 characters).
            </summary>
            <remarks>
            An ASCII string, 64 characters or less, whose use and contents may be
            defined by the user of the system.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.LevelReference">
            <summary>
            Sample value for 0 dB reference (signed Int32).
            </summary>
            <remarks>
            A 32-bit signed (2s complement) integer word that shall hold the sample value
            of the 0-dB reference level for the originating system. This reference can
            facilitate scaling and metering consistency across disparate systems. As an
            example, a 16-bit linear PCM system that has its meters calibrated as 0
            corresponding to maximum signed digital value shall have the value set to
            32768 (800016).
            <para>
            The peak value shall be the absolute value of the largest sample value possible
            before saturation. In the example given, that of a 16-bit linear system using 2s
            complement notation, the range of allowable values is -32768 to 32767, thus the
            maximum peak value is 32768 in the example given.
            </para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage">
            <summary>
            1st timer usage ID (4 characters).
            </summary>
            <remarks>
            Timer types, along with their FOURCC identification should be according to the following table.
            The interpretation and behavior of systems on encountering timer information may be site dependent, implementation dependent, or both:
            <para>SEG: Segue timer (start-end, enumerated, multiples)</para>
            <para>AUD: Audio boundary (start-end)</para>
            <para>INT: Introduction (start-end, enumerated, multiples)</para>
            <para>OUT: Epilog (start-end, enumerated, multiples)</para>
            <para>SEC: Secondary (start-end, enumerated, multiples)</para>
            <para>TER: Tertiary (start-end, enumerated, multiples)</para>
            <para>MRK: Generic marker (multiplesenumerated, )</para>
            <para>EOD: End-of-data (multiples)</para>
            <para>Timers may be qualified in one of three ways:</para>
            <para>a) as start or end timers, by appending a lower case ASCII letter s for a start timer or a lower case ASCII
            letter e for an end timer; for example, the timer identification AUDs designates the start of audio following
            silence, while AUDe designates the end of the audio segment;</para>
            <para>b) as enumerated timers, by appending an ASCII numeric character; for example, SEC1 may be designated
            secondary timer number 1, SEC2 may be secondary number 2, and so on;</para>
            <para>c) as multiple timers, by having multiple instances of the same timer ID; one may have, for example,
            multiple instances of MRK.</para>
            <para>Each application may prioritize the order of the timers.</para>
            <para>
            If a timer is not used, or is not set, its usage identifier should be set to all zero characters (0x00000000).
            </para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value">
            <summary>
            1st timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>
            The time units shall be in sample periods at the sampling frequency of the associated audio data and
            shall be referenced to the first sample of the audio data.
            <para>
            The timer range shall be 232 or 4,294,967,295 sample periods. These periods
            allow timer ranges at a sampling frequency of 48 kHz, for example, to extend
            beyond 24 h (24:51:18).
            These timers may be used to activate events in the cart system.
            </para>
            <para>
            If a timer is not used, or is not set, its timer value set to 0.
            </para>
            <para>Note: This member is actually an unsigned value - but due to the CLS-compliant rule it must have been defined as a signed int.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer2Usage">
            <summary>
            2nd timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer2Value">
            <summary>
            2nd timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer3Usage">
            <summary>
            3rd timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer3Value">
            <summary>
            3rd timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer4Usage">
            <summary>
            4th timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer4Value">
            <summary>
            4th timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer5Usage">
            <summary>
            5th timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer5Value">
            <summary>
            5th timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer6Usage">
            <summary>
            6th timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer6Value">
            <summary>
            6th timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer7Usage">
            <summary>
            7th timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer7Value">
            <summary>
            7th timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer8Usage">
            <summary>
            8th timer usage ID (4 characters).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Usage"/> for details.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.Timer8Value">
            <summary>
            8th timer value in samples from head (unsigned Int32).
            </summary>
            <remarks>See <see cref="P:Un4seen.Bass.BASS_TAG_CART.Timer1Value"/> for details.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CART.Reserved">
            <summary>
            Reserved for future use (276 bytes!).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CART.URL">
            <summary>
            Uniform resource locator (max. 1024 characters).
            </summary>
            <remarks>
            An ASCII string, 1024-characters or less, representing a universal resource
            locator (URL) referencing or referenced by the audio program.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CART.ToString">
            <summary>
            The description field of the TAG structure.
            </summary>
            <returns>The description field of the TAG structure (Artist - Title).</returns>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CART.GetTagText(System.IntPtr)">
            <summary>
            Returns the free form text for scripts or tags for a given BASS_TAG_RIFF_CART tag pointer.
            </summary>
            <param name="tag">The cart tag pointer as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</param>
            <returns>The tag text string or <see langword="null"/> (if the tag pointer is not valid).</returns>
            <remarks>
            The tag text is a non-restricted ASCII characters containing a collection of strings each
            terminated by CRLF. This text may be system- or user- defined
            descriptive text for the sound, such as live tag, script information, descriptive
            text special instructions, and so on.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CART.AsByteArray(System.String)">
            <summary>
            Returns a byte array containing the data of this instance plus the given <paramref name="tagText"/>.
            </summary>
            <param name="tagText">The new (total) tag text string to add to this structure.</param>
            <returns>The byte array containing the instance data plus the given <paramref name="tagText"/>.</returns>
            <remarks>This method might be used to create a raw CART data chunk (e.g. to be used with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_AddChunk(System.Int32,System.String,System.IntPtr,System.Int32)"/> method).</remarks>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_CUE">
            <summary>
            RIFF "cue " tag cue point structure to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> 
            and the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_CUE"/> option.
            </summary>
            <remarks>
            Use the static <see cref="M:Un4seen.Bass.BASS_TAG_CUE.GetTag(System.Int32)"/> or <see cref="M:Un4seen.Bass.BASS_TAG_CUE.FromIntPtr(System.IntPtr)"/> methods to retrieve an instance.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE.NumCuePoints">
            <summary>
            The number of cue points.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE.CuePoints">
            <summary>
            The array of <see cref="T:Un4seen.Bass.BASS_TAG_CUE_POINT"/> cue points (or <see langword="null"/>).
            </summary>
            <remarks>
            Only available with the static <see cref="M:Un4seen.Bass.BASS_TAG_CUE.GetTag(System.Int32)"/> or <see cref="M:Un4seen.Bass.BASS_TAG_CUE.FromIntPtr(System.IntPtr)"/> methods.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CUE.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CUE.GetTag(System.Int32)">
            <summary>
            Gets a BASS_TAG_CUE tag from a given channel handle.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <returns>Returns a <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/> instance if the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_CUE"/> could be retrieved successfully - else <see langword="null"/> is returned.</returns>
            <remarks>This method internally calles <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve the BASS_TAG_RIFF_CUE tag.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CUE.FromIntPtr(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/> class from a pointer.
            </summary>
            <param name="p">The pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/> structure (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_CUE"/> flag).</param>
            <returns>The created instance of the <see cref="T:Un4seen.Bass.BASS_TAG_CUE"/> class on success - else <see langword="null"/> is returned.</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_CUE_POINT">
            <summary>
            RIFF "cue " tag cue point structure.
            </summary>
            <remarks>
            The structure is given by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> as it is in the RIFF file, which is little-endian, so the members will need to be reversed on big-endian platforms.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE_POINT.Name">
            <summary>
            Specifies the cue point name. Each record must have a unique Name field.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE_POINT.Position">
            <summary>
            Specifies the sample position of the cue point. This is the sequential sample number within the play order.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE_POINT.FourCC">
            <summary>
            Specifies the name or chunk ID of the chunk containing the cue point.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE_POINT.ChunkStart">
            <summary>
            Specifies the position of the start of the data chunk containing the cue point. This should be zero if there is only one chunk containing data (as is currently always the case).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE_POINT.BlockStart">
            <summary>
            Specifies the position of the start of the block containing the position. This is the byte offset from the start of the data section of the chunk, not the chunks FOURCC.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_CUE_POINT.SampleOffset">
            <summary>
            Specifies the sample offset of the cue point relative to the start of the block.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CUE_POINT.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_SMPL">
            <summary>
            RIFF "smpl" tag cue point structure to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> 
            and the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_SMPL"/> option.
            </summary>
            <remarks>
            Use the static <see cref="M:Un4seen.Bass.BASS_TAG_SMPL.GetTag(System.Int32)"/> or <see cref="M:Un4seen.Bass.BASS_TAG_SMPL.FromIntPtr(System.IntPtr)"/> methods to retrieve an instance.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.Manufacturer">
            <summary>
            Specifies the MMA Manufacturer code for the intended target device. 
            </summary>
            <remarks>
            The high byte indicates the number of low order bytes (1 or 3) that are valid for the manufacturer code. 
            For example, this value will be 0x01000013 for Digidesign (the MMA Manufacturer code is one byte, 0x13); whereas 0x03000041 identifies Microsoft (the MMA Manufacturer code is three bytes, 0x00 0x00 0x41). 
            If the sample is not intended for a specific manufacturer, then this field should be set to zero.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.Product">
            <summary>
            Specifies the Product code of the intended target device for the Manufacturer. 
            </summary>
            <remarks>
            If the sample is not intended for a specific manufacturers product, then this field should be set to zero.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.SamplePeriod">
            <summary>
            Specifies the period of one sample in nanoseconds (normally 1/nSamplesPerSec from the WAVEFORMAT structure for the RIFF WAVE file--however, this field allows fine tuning).
            </summary>
            <remarks>
            For example, 44.1 kHz would be specified as 22675 (0x00005893).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.MIDIUnityNote">
            <summary>
            Specifies the MIDI note which will replay the sample at original pitch.
            </summary>
            <remarks>
            This value ranges from 0 to 127 (a value of 60 represents Middle C as defined by the MMA).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.MIDIPitchFraction">
            <summary>
            Specifies the fraction of a semitone up from the specified MIDIUnityNote.
            </summary>
            <remarks>
            A value of 0x80000000 is 1/2 semitone (50 cents); a value of 0x00000000 represents no fine tuning between semitones.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.SMPTEFormat">
            <summary>
            Specifies the SMPTE time format used in the SMPTEOffset field.
            </summary>
            <remarks>
            Possible values are (unrecognized formats should be ignored): 0 - specifies no SMPTE offset (dwSMPTEOffset should also be zero), 
            24 - specifies 24 frames per second, 25 - specifies 25 frames per second, 29 - specifies 30 frames per second with frame dropping ("30 drop"), 
            30 - specifies 30 frames per second.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.SMPTEOffset">
            <summary>
            Specifies a time offset for the sample if it is to be syncronized or calibrated according to a start time other than 0.
            </summary>
            <remarks>
            The format of this value is 0xhhmmssff. 
            hh is a signed Hours value [-23..23]. 
            mm is an unsigned Minutes value [0..59]. 
            ss is unsigned Seconds value [0..59]. 
            ff is an unsigned value [0..(SMPTEFormat - 1)].
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.NumSampleLoops">
            <summary>
            Specifies the number (count) of <see cref="T:Un4seen.Bass.BASS_TAG_SMPL_LOOP"/> records that are contained in SampleLoops.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.SampleData">
            <summary>
            Specifies the size in bytes of the optional sampler-specific data. Sampler specific data is stored imediately following the SampleLoops records. The cbSamplerData field will be zero if no extended sampler specific information is stored in the chunk.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL.SampleLoops">
            <summary>
            The array of <see cref="T:Un4seen.Bass.BASS_TAG_SMPL_LOOP"/> loops (or <see langword="null"/>).
            </summary>
            <remarks>
            Only available with the static <see cref="M:Un4seen.Bass.BASS_TAG_SMPL.GetTag(System.Int32)"/> or <see cref="M:Un4seen.Bass.BASS_TAG_SMPL.FromIntPtr(System.IntPtr)"/> methods.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_SMPL.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_SMPL.GetTag(System.Int32)">
            <summary>
            Gets a BASS_TAG_SMPL tag from a given channel handle.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <returns>Returns a <see cref="T:Un4seen.Bass.BASS_TAG_SMPL"/> instance if the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_SMPL"/> could be retrieved successfully - else <see langword="null"/> is returned.</returns>
            <remarks>This method internally calles <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve the BASS_TAG_RIFF_SMPL tag.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_SMPL.FromIntPtr(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_SMPL"/> class from a pointer.
            </summary>
            <param name="p">The pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_SMPL"/> structure (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_RIFF_SMPL"/> flag).</param>
            <returns>The created instance of the <see cref="T:Un4seen.Bass.BASS_TAG_SMPL"/> class on success - else <see langword="null"/> is returned.</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_SMPL_LOOP">
            <summary>
            RIFF "smpl" tag loop structure.
            </summary>
            <remarks>
            The structure is given by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> as it is in the RIFF file, which is little-endian, so the members will need to be reversed on big-endian platforms.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL_LOOP.Identifier">
            <summary>
            Identifies the unique name of the loop. This field may correspond with a name stored in a cue points ("cue ") chunk. The name data is stored in an associated data list ("adtl") chunk.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL_LOOP.Type">
            <summary>
            Specifies the loop type: 0 - Loop forward (normal), 1 - Alternating loop (forward/backward), 2 - Loop backward, 3-31 - reserved for future standard types, 32-? - sampler specific types (manufacturer defined).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL_LOOP.Start">
            <summary>
            Specifies the startpoint of the loop in samples.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL_LOOP.End">
            <summary>
            Specifies the endpoint of the loop in samples (this sample will also be played).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL_LOOP.Fraction">
            <summary>
            Allows fine-tuning for loop fractional areas between samples. Values range from 0x00000000 to 0xFFFFFFFF. A value of 0x80000000 represents 1/2 of a sample length.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_SMPL_LOOP.PlayCount">
            <summary>
            Specifies the number of times.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_SMPL_LOOP.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_CACODEC">
            <summary>
            TAG structure of the Apple CoreAudio codec information structure as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTagsCA(System.Int32)"/>.
            </summary>
            <remarks>A list of file and audio data format identifiers is available from Apple, <a href="http://developer.apple.com/mac/library/documentation/MusicAudio/Conceptual/CoreAudioOverview/SupportedAudioConverterFormats/SupportedAudioConverterFormats.html"/>.
            Additional formats may be available via third-party codecs.</remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CACODEC.ftype">
            <summary>
            The file format identifier.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CACODEC.atype">
            <summary>
            The audio format identifier.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CACODEC.name">
            <summary>
            The description of the audio file format.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CACODEC.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CACODEC.#ctor(System.IntPtr)">
            <summary>
            Constructor to create an instance from the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> return value.
            </summary>
            <param name="p">The pointer as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>.</param>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_CACODEC.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns>A description of the decive info object (name).</returns>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CACODEC.TAG_CA_CODEC.ftype">
            <summary>
            The file format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CACODEC.TAG_CA_CODEC.atype">
            <summary>
            The audio format.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_CACODEC.TAG_CA_CODEC.name">
            <summary>
            The description of the audio file format.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_APE_BINARY">
            <summary>
            APE binary tag structure as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_APE_BINARY"/> flag.
            </summary>
            <remarks>
            <para>
            When calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> with the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_APE_BINARY"/> flag make sure to add the index number of the binray tag to get.
            E.g. call: <code>Bass.BASS_ChannelGetTags( stream, (BASSTag)(BASSTag.BASS_TAG_APE_BINARY + 1) )</code> to get the 2nd binary tag.
            </para>
            </remarks>
            <example>
            Read all APE binary tags:
            <code>
            BASS_TAG_APE_BINARY apeBin;
            for (int n = 0; (apeBin = BASS_TAG_APE_BINARY.GetTag(stream, n)) != null; n++)
            {
                Console.WriteLine(apeBin);
                // access the binary data
                byte[] data = apeBin.Data;
            }
            </code>
            <code lang="vbnet">
            Dim apeBin As BASS_TAG_APE_BINARY
            Dim n As Integer
            For n = 0 To (apeBin BASS_TAG_APE_BINARY.GetTag(stream, n)) &lt;&gt; Nothing Step n + 1
                Console.WriteLine(apeBin)
                ' access the binary data
                Dim data() As Byte = apeBin.Data 
            Next
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_APE_BINARY.Key">
            <summary>
            The name of the tag.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_APE_BINARY.Data">
            <summary>
            The binary tag data.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_APE_BINARY.Length">
            <summary>
            The size of <see cref="P:Un4seen.Bass.BASS_TAG_APE_BINARY.Data"/> in bytes.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_APE_BINARY.ToString">
            <summary>
            Returns the Key of the binary tag.
            </summary>
            <returns>Returns the Key of the binary tag.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_APE_BINARY.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_APE_BINARY.GetTag(System.Int32,System.Int32)">
            <summary>
            Gets a BASS_TAG_APE_BINARY tag from a given channel handle.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="index">The zero-based index of the binary tag to get.</param>
            <returns>Returns a <see cref="T:Un4seen.Bass.BASS_TAG_APE_BINARY"/> instance if the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_APE_BINARY"/> could be retrieved successfully - else <see langword="null"/> is returned.</returns>
            <remarks>This method internally calles <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve the BASS_TAG_APE_BINARY tag.</remarks>
            <example>
            Read all APE binary tags:
            <code>
            BASS_TAG_APE_BINARY apeBin;
            for (int n = 0; (apeBin = BASS_TAG_APE_BINARY.GetTag(stream, n)) != null; n++)
            {
                Console.WriteLine(apeBin);
                // access the binary data
                byte[] data = apeBin.Data;
            }
            </code>
            <code lang="vbnet">
            Dim apeBin As BASS_TAG_APE_BINARY
            Dim n As Integer
            For n = 0 To (apeBin BASS_TAG_APE_BINARY.GetTag(stream, n)) &lt;&gt; Nothing Step n + 1
                Console.WriteLine(apeBin)
                ' access the binary data
                Dim data() As Byte = apeBin.Data 
            Next
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_APE_BINARY.FromIntPtr(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_APE_BINARY"/> class from a pointer.
            </summary>
            <param name="p">The pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_APE_BINARY"/> structure (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_APE_BINARY"/> flag).</param>
            <returns>The created instance of the <see cref="T:Un4seen.Bass.BASS_TAG_APE_BINARY"/> class on success - else <see langword="null"/> is returned.</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE">
            <summary>
            FLAC picture tag structure as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_PICTURE"/> flag.
            </summary>
            <remarks>
            The width, height, depth, and colors members may be empty (0) so should not be depended on. That information can be obtained from the picture data itself.
            <para>Use the static <see cref="M:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.GetTag(System.Int32,System.Int32)"/> method to get the FLAC picture tag from a given channel handle.</para>
            <para>
            When calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> with the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_PICTURE"/> flag make sure to add the index number of the picture to get.
            E.g. call: <code>Bass.BASS_ChannelGetTags( stream, (BASSTag)(BASSTag.BASS_TAG_FLAC_PICTURE + 1) )</code> to get the 2nd picture.
            </para>
            </remarks>
            <example>
            Read all FLAC picture tags:
            <code>
            BASS_TAG_FLAC_PICTURE flacPic;
            for (int n = 0; (flacPic = BASS_TAG_FLAC_PICTURE.GetTag(stream, n)) != null; n++)
            {
                Console.WriteLine(flacPic);
                // access the image picture
                Image img = flacPic.Picture;
                // access the raw image data
                byte[] data = flacPic.Data;
            }
            </code>
            <code lang="vbnet">
            Dim flacPic As BASS_TAG_FLAC_PICTURE
            Dim n As Integer
            For n = 0 To (flacPic  BASS_TAG_FLAC_PICTURE.GetTag(stream, n)) &lt;&gt; Nothing Step n + 1
                Console.WriteLine(flacPic)
                ' access the image picture
                Dim img As Image = flacPic.Picture 
                ' access the raw image data
                Dim data() As Byte = flacPic.Data 
            Next
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_FLAC_PICTURE._apic">
            <summary>
            The picture type, according to the ID3v2 "APIC" frame specification: see <a href="http://www.id3.org/id3v2.3.0">www.id3.org</a> for details.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Mime">
            <summary>
            The MIME type string. This may be "-->" to signify that data contains a URL of the picture rather than the picture data itself.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Desc">
            <summary>
            A description string of the picture.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Width">
            <summary>
            The width in pixels.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Height">
            <summary>
            The height in pixels.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Depth">
            <summary>
            The colour depth in bits-per-pixel.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Colors">
            <summary>
            The number of colours used for indexed-colour pictures (eg. GIF).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Length">
            <summary>
            The size of <see cref="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Data"/> in bytes.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Data">
            <summary>
            The picture data.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.ImageURL">
            <summary>
            Returns the image URL, if the <see cref="P:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.Mime"/> type is "-->" - else <see langword="null"/> is returned.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.ToString">
            <summary>
            Returns the description and mime type of the picture.
            </summary>
            <returns>Returns e.g. "CoverArt (image/jpeg)".</returns>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.GetTag(System.Int32,System.Int32)">
            <summary>
            Gets a BASS_TAG_FLAC_PICTURE tag from a given channel handle.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="pictureIndex">The zero-based picture index to get.</param>
            <returns>Returns a <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE"/> instance if the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_PICTURE"/> could be retrieved successfully - else <see langword="null"/> is returned.</returns>
            <remarks>This method internally calles <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve the BASS_TAG_FLAC_PICTURE tag.</remarks>
            <example>
            Read all FLAC picture tags:
            <code>
            BASS_TAG_FLAC_PICTURE flacPic;
            for (int n = 0; (flacPic = BASS_TAG_FLAC_PICTURE.GetTag(stream, n)) != null; n++)
            {
                Console.WriteLine(flacPic);
                // access the image picture
                Image img = flacPic.Picture;
                // access the raw image data
                byte[] data = flacPic.Data;
            }
            </code>
            <code lang="vbnet">
            Dim flacPic As BASS_TAG_FLAC_PICTURE
            Dim n As Integer
            For n = 0 To (flacPic BASS_TAG_FLAC_PICTURE.GetTag(stream, n)) &lt;&gt; Nothing Step n + 1
                Console.WriteLine(flacPic)
                ' access the image picture
                Dim img As Image = flacPic.Picture 
                ' access the raw image data
                Dim data() As Byte = flacPic.Data 
            Next
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_PICTURE.FromIntPtr(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE"/> class from a pointer.
            </summary>
            <param name="p">The pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE"/> structure (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_PICTURE"/> flag).</param>
            <returns>The created instance of the <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_PICTURE"/> class on success - else <see langword="null"/> is returned.</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_FLAC_CUE">
            <summary>
            FLAC cuesheet tag structure as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_CUE"/> flag.
            </summary>
            <remarks>
            <para>Further details can be found in the FLAC format specification, here: <a href="http://flac.sourceforge.net/format.html">flac.sourceforge.net</a>.</para>
            <para>Use the static <see cref="M:Un4seen.Bass.BASS_TAG_FLAC_CUE.GetTag(System.Int32)"/> method to get the FLAC cuesheet tag from a given channel handle.</para>
            </remarks>
            <example>
            Read the FLAC cuesheet tag:
            <code>
            BASS_TAG_FLAC_CUE cuesheet = BASS_TAG_FLAC_CUE.GetTag(stream);
            </code>
            <code lang="vbnet">
            Dim cuesheet As BASS_TAG_FLAC_CUE = BASS_TAG_FLAC_CUE.GetTag(stream)
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE.Catalog">
            <summary>
            The media catalog number.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE.LeadIn">
            <summary>
            The number of lead-in samples.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE.IsCD">
            <summary>
            The cuesheet corresponds to a CD?
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE.NumTracks">
            <summary>
            The number of tracks.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE.Tracks">
            <summary>
            The array of <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK"/> tracks (or <see langword="null"/>).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_CUE.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_CUE.GetTag(System.Int32)">
            <summary>
            Gets a BASS_TAG_FLAC_CUE tag from a given channel handle.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <returns>Returns a <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE"/> instance if the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_CUE"/> could be retrieved successfully - else <see langword="null"/> is returned.</returns>
            <remarks>This method internally calles <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve the BASS_TAG_FLAC_CUE tag.</remarks>
            <example>
            Read the FLAC cuesheet tag:
            <code>
            BASS_TAG_FLAC_CUE cuesheet = BASS_TAG_FLAC_CUE.GetTag(stream);
            </code>
            <code lang="vbnet">
            Dim cuesheet As BASS_TAG_FLAC_CUE = BASS_TAG_FLAC_CUE.GetTag(stream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_CUE.FromIntPtr(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE"/> class from a pointer.
            </summary>
            <param name="p">The pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE"/> structure (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_FLAC_CUE"/> flag).</param>
            <returns>The created instance of the <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE"/> class on success - else <see langword="null"/> is returned.</returns>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK">
            <summary>
            FLAC cuesheet tag track structure as returned by the <see cref="P:Un4seen.Bass.BASS_TAG_FLAC_CUE.Tracks"/> member.
            </summary>
            <example>
            Read the FLAC cuesheet tag:
            <code>
            BASS_TAG_FLAC_CUE cuesheet = BASS_TAG_FLAC_CUE.GetTag(stream);
            </code>
            <code lang="vbnet">
            Dim cuesheet As BASS_TAG_FLAC_CUE = BASS_TAG_FLAC_CUE.GetTag(stream)
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Offset">
            <summary>
            Track offset in samples.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Number">
            <summary>
            The track number.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.ISRC">
            <summary>
            The International Standard Recording Code.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Flags">
            <summary>
            The track flags.
            </summary>
            <remarks>Any combination of the following flags:
            <list type="table">
            <item><term>TAG_FLAC_CUE_TRACK_DATA</term><description>Non-audio.</description></item>
            <item><term>TAG_FLAC_CUE_TRACK_PRE</term><description>Pre-emphasis.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.NumIndexes">
            <summary>
            The number of <see cref="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Indexes"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Indexes">
            <summary>
            The array of <see cref="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK_INDEX"/> indexes (or <see langword="null"/>).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.CUESHEETTrackType">
            <summary>
            The possible cuesheet track type <see cref="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Flags"/>.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.CUESHEETTrackType.TAG_FLAC_CUE_TRACK_AUDIO">
            <summary>
            Audio (default).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.CUESHEETTrackType.TAG_FLAC_CUE_TRACK_DATA">
            <summary>
            Non-audio.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.CUESHEETTrackType.TAG_FLAC_CUE_TRACK_PRE">
            <summary>
            Pre-emphasis.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK_INDEX">
            <summary>
            FLAC cuesheet tag track index structure as returned by the <see cref="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK.Indexes"/> member.
            </summary>
            <example>
            Read the FLAC cuesheet tag:
            <code>
            BASS_TAG_FLAC_CUE cuesheet = BASS_TAG_FLAC_CUE.GetTag(stream);
            </code>
            <code lang="vbnet">
            Dim cuesheet As BASS_TAG_FLAC_CUE = BASS_TAG_FLAC_CUE.GetTag(stream)
            </code>
            </example>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK_INDEX.Offset">
            <summary>
            Index offset in samples relative to the track offset.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK_INDEX.Number">
            <summary>
            The index number.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_FLAC_CUE_TRACK_INDEX.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT">
            <summary>
            DSDIFF comment tag structure as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_COMMENT"/> flag.
            </summary>
            <remarks>
            <para>
            When calling <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> with the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_COMMENT"/> flag make sure to add the index number of the comment tag to get.
            E.g. call: <code>Bass.BASS_ChannelGetTags( stream, (BASSTag)(BASSTag.BASS_TAG_DSD_COMMENT + 1) )</code> to get the 2nd comment tag.
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.TimeStampYear">
            <summary>
            The year of the comment creation.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.TimeStampMonth">
            <summary>
            The month of the comment creation.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.TimeStampDay">
            <summary>
            The day of the comment creation.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.TimeStampHour">
            <summary>
            The hour of the comment creation.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.TimeStampMinutes">
            <summary>
            The minutes of the comment creation.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.CommentType">
            <summary>
            The comment type... 0 = general comment, 1 = channel comment, 2 = sound source, 3 = file history.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.BASS_TAG_DSD_COMMENT.CommentRef">
            <summary>
            The comment reference. Together with CommentType this indicates to what the comment refers. 
            If CommentType=0 then this should be 0. 
            If CommentType=1 then 0 = all channels, 1 = 1st channel, 2 = 2nd channel, etc. 
            If CommentType=2 then 0 = DSD recording, 1 = analogue recording, 2 = PCM recording. 
            If CommentType=3 then 0 = general remark, 1 = name of the operator, 2 = name or type of the creating machine, 3 = time zone information, 4 = revision of the file.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASS_TAG_DSD_COMMENT.CommentText">
            <summary>
            The description of the comment.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_DSD_COMMENT.ToString">
            <summary>
            Returns the CommentText.
            </summary>
            <returns>Returns the Text of the comment tag.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_DSD_COMMENT.#ctor">
            <summary>
            Hidden default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_DSD_COMMENT.GetTag(System.Int32,System.Int32)">
            <summary>
            Gets a BASS_TAG_DSD_COMMENT tag from a given channel handle.
            </summary>
            <param name="handle">The channel handle...a HMUSIC or HSTREAM.</param>
            <param name="index">The zero-based index of the binary tag to get.</param>
            <returns>Returns a <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> instance if the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_COMMENT"/> could be retrieved successfully - else <see langword="null"/> is returned.</returns>
            <remarks>This method internally calles <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> to retrieve the BASS_TAG_DSD_COMMENT tag.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASS_TAG_DSD_COMMENT.FromIntPtr(System.IntPtr)">
            <summary>
            Creates an instance of the <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> class from a pointer.
            </summary>
            <param name="p">The pointer to a <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> structure (e.g. as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/> using the <see cref="F:Un4seen.Bass.BASSTag.BASS_TAG_DSD_COMMENT"/> flag).</param>
            <returns>The created instance of the <see cref="T:Un4seen.Bass.BASS_TAG_DSD_COMMENT"/> class on success - else <see langword="null"/> is returned.</returns>
        </member>
        <member name="T:Un4seen.Bass.WAVEFORMATEX">
            <summary>
            The WAVEFORMATEX structure defines the format of waveform-audio data. 
            Only format information common to all waveform-audio data formats is included in this structure. 
            For formats that require additional information, this structure is included as the first member in another structure, along with the additional information.
            See <see cref="!:WAVEFORMATEXT"/> for details.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.wFormatTag">
            <summary>
            Waveform-audio format type (see <see cref="T:Un4seen.Bass.WAVEFormatTag"/>). Format tags are registered with Microsoft Corporation for many compression algorithms.
            A complete list of format tags can be found in the Mmreg.h header file. 
            For one- or two-channel PCM data, this value should be WAVE_FORMAT_PCM.
            <para>Default = 1 (WAVE_FORMAT_PCM)</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.nChannels">
            <summary>
            Number of channels in the waveform-audio data. Monaural data uses one
            channel and stereo data uses two channels.
            <para>Default = 2</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.nSamplesPerSec">
            <summary>
            Sample rate, in samples per second (hertz), that each channel should
            be played or recorded. If wFormatTag is WAVE_FORMAT_PCM, then common
            values for nSamplesPerSec are 8.0 kHz, 11.025 kHz, 22.05 kHz, and
            44.1 kHz. For non-PCM formats, this member must be computed according
            to the manufacturer's specification of the format tag.
            <para>Default = 44100</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.nAvgBytesPerSec">
            <summary>
            In most cases, this member contains the required average data-transfer rate, 
            in bytes per second, for the format tag. If wFormatTag is WAVE_FORMAT_PCM, 
            nAvgBytesPerSec should be equal to the product of nSamplesPerSec and nBlockAlign. 
            For non-PCM formats, this member must be computed according to the manufacturer's 
            specification of the format tag. 
            When the Windows Media Audio 9 Codec is in quality-based variable-bit-rate mode, 
            the high-order bytes of this member are set to 0x7fffff and the low-order byte is set to a value 
            from one through 100 which indicates the quality level.
            <para>Typical Calculation: nSamplesPerSec * nBlockAlign</para>
            <para>Default = 176400</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.nBlockAlign">
            <summary>
            Block alignment, in bytes. The block alignment is the minimum atomic unit
            of data for the wFormatTag format type. If wFormatTag is WAVE_FORMAT_PCM,
            nBlockAlign should be equal to the product of nChannels and wBitsPerSample
            divided by 8 (bits per byte). For non-PCM formats, this member must be
            computed according to the manufacturer's specification of the format tag. 
            Playback and record software must process a multiple of nBlockAlign bytes
            of data at a time. Data written and read from a device must always start
            at the beginning of a block. For example, it is illegal to start playback
            of PCM data in the middle of a sample (that is, on a non-block-aligned boundary).
            <para>Typical Calculation: nChannels * (wBitsPerSample / 8)</para>
            <para>Default = 4</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.wBitsPerSample">
            <summary>
            Bits per sample for the wFormatTag format type. If wFormatTag is
            WAVE_FORMAT_PCM, then wBitsPerSample should be equal to 8, 16 or 32. For
            non-PCM formats, this member must be set according to the manufacturer's
            specification of the format tag. Some compression schemes cannot define
            a value for wBitsPerSample, so this member can be zero.
            <para>Default = 16</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.WAVEFORMATEX.cbSize">
            <summary>
            Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure. 
            This information can be used by non-PCM formats to store extra attributes for the wFormatTag. 
            If no extra information is required by the wFormatTag, this member must be set to zero. 
            For WAVE_FORMAT_PCM formats (and only WAVE_FORMAT_PCM formats), this member is ignored.
            <para>Default = 0</para>
            </summary>
        </member>
        <member name="M:Un4seen.Bass.WAVEFORMATEX.#ctor">
            <summary>
            Default Constructor.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.WAVEFORMATEX.#ctor(Un4seen.Bass.WAVEFormatTag,System.Int16,System.Int32,System.Int16,System.Int16)">
            <summary>
            Creates an instance setting the members to certain values.
            </summary>
            <param name="format">Waveform-audio format type (see <see cref="T:Un4seen.Bass.WAVEFormatTag"/>).</param>
            <param name="channels">Number of channels in the waveform-audio data.</param>
            <param name="samplesPerSec">Sample rate, in samples per second (hertz), that each channel should be played or recorded.</param>
            <param name="bitsPerSample">Bits per sample for the wFormatTag format type (e.g. 8, 16 or 32).</param>
            <param name="exSize">Size, in bytes, of extra format information appended to the end of the WAVEFORMATEX structure.</param>
        </member>
        <member name="M:Un4seen.Bass.WAVEFORMATEX.ToString">
            <summary>
            Returns a description string for the instance members.
            </summary>
            <returns>Returns a description string for the instance members (wFormatTag, res, nSamplesPerSec, chans).</returns>
        </member>
        <member name="T:Un4seen.Bass.STREAMPROC">
            <summary>
            User stream writing callback delegate (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/>).
            </summary>
            <param name="handle">The stream that needs writing.</param>
            <param name="buffer">The pointer to the buffer to write the sample data in. The sample data must be written in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1.</param>
            <param name="length">The number of bytes to write.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes written by the function, optionally using the BASS_STREAMPROC_END (<see cref="T:Un4seen.Bass.BASSStreamProc"/>) flag to signify that the end of the stream is reached.</returns>
            <remarks>
            <para>A stream writing function should obviously be as quick as possible, because other streams (and MOD musics) can't be updated until it's finished.</para>
            <para>It is better to return less data quickly, rather than spending a long time delivering the amount BASS requested.</para>
            <para>Although a STREAMPROC may return less data than BASS requests, be careful not to do so by too much, too often. If the buffer level gets too low, BASS will automatically stall playback of the stream, until the whole buffer has refilled.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check the buffer level, and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> can be used to check if playback has stalled.</para>
            <para>A BASS_SYNC_STALL sync can also be set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to be triggered upon playback stalling or resuming.</para>
            <para>If you do return less than the requested amount of data, the number of bytes should still equate to a whole number of samples.</para>
            <para>Some functions can cause problems if called from within a stream (or DSP) function. Do not call these functions from within a stream callback:</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> or any other stream creation functions.</para>
            <para>Also, do not call <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> with the same handle as received by the callback.</para>
            <para>When streaming multi-channel sample data, the channel order of each sample is as follows:</para>
            <para>3 channels: left-front, right-front, center.</para>
            <para>4 channels: left-front, right-front, left-rear/side, right-rear/side.</para>
            <para>6 channels(5.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side.</para>
            <para>8 channels(7.1): left-front, right-front, center, LFE, left-rear/side, right-rear/side, left-rear center, right-rear center.</para>
            <para>
            It is clever to NOT alloc buffer data (e.g. a float[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'float[] data = new float[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            However, this is not always the case, so in most examples it'll work just fine - but if you got problems - try moving any memory allocation things outside any callbacks.
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            A callback function to stream a file, in 44100hz 16-bit stereo:
            <code>
            private STREAMPROC _myStreamCreate; // make it global, so that the GC can not remove it
            private byte[] _data; // local data buffer
            ...
            _myStreamCreate = new STREAMPROC(MyFileProc);
            FileStream _fs = File.OpenRead("test.raw");
            int channel = Bass.BASS_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero);
            Bass.BASS_ChannelPlay(channel, false);
            ...
            private int MyFileProc(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	// implementing the callback for BASS_StreamCreate...
            	// here we need to deliver PCM sample data
            	// increase the data buffer as needed
            	if (_data == null || _data.Length &lt; length)
            		_data = new byte[length];
            	int bytesread = _fs.Read( _data, 0, length ); 
            	Marshal.Copy( _data, 0, buffer, bytesread );
            	if ( bytesread &lt; length )
            	{
            		bytesread |= (int)BASSStreamProc.BASS_STREAMPROC_END; // set indicator flag
            		_fs.Close();
            	}
            	return bytesread;
            }
            </code>
            <code lang="vbnet">
            Private _myStreamCreate As STREAMPROC  ' make it global, so that the GC can not remove it
            Private _data As Byte() = Nothing  ' our local buffer
            ...
            _myStreamCreate = New STREAMPROC(AddressOf MyFileProc)
            Dim fs As FileStream =  File.OpenRead("test.raw")
            Dim channel As Integer =  Bass.BASS_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT, _myStreamCreate, IntPtr.Zero) 
            Bass.BASS_ChannelPlay(channel, False)
            ...
            Private Function MyFileProc(ByVal handle As Integer, ByVal buffer As IntPtr, 
                                        ByVal length As Integer, ByVal user As IntPtr) As Integer
              ' implementing the callback for BASS_StreamCreate...
              ' here we need to deliver PCM sample data
              ' increase the data buffer as needed
              If _data = Nothing OrElse _data.Length &lt; length Then
                _data = New Byte(length) {}
              End If
              Dim bytesread As Integer = _fs.Read(_data, 0, length) 
              Marshal.Copy(_data, 0, buffer, bytesread)
              If bytesread &lt; length Then
                bytesread = bytesread Or CInt(BASSStreamProc.BASS_STREAMPROC_END) ' set indicator flag
                _fs.Close()
              EndIf
              Return bytesread
            End Function
            </code>
            If you're into C# you might also make use of native pointers in an unsafe code block:
            <code>
            unsafe private int MyFileProcUnsafe(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	// simply cast the given IntPtr to a native pointer to byte values
            	byte *data = (byte*)buffer;
            	// read the file into the data pointer directly
            	int bytesread = length;
            	for (int a=0; a &lt; length; a++)
            	{
            		int val = _fs.ReadByte();
            		if (val != -1)
            		{
            			data[a] = (byte)val;   // set the value
            		}
            		else
            		{
            			bytesread = a;
            			break;
            		}
            	}
            	// end of the file/stream?
            	if ( bytesread &lt; length )
            	{
            		bytesread |= (int)BASSStreamProc.BASS_STREAMPROC_END; // set indicator flag
            		_fs.Close();
            	}
            	return bytesread;
            }
            </code>
            However, even if we directly access memory here, this is not really faster in that case, since we read the file byte per byte and also in a way perform a copy (we just use a single int buffer called val).
            So in essence when you need to read from a file you should take care, that the file access and read operation is fast an additional Marshal.Copy wouldn't count much in terms of performance.
            The only advantage we get here is actually, that we use less memory.
            </example>
        </member>
        <member name="T:Un4seen.Bass.FILECLOSEPROC">
            <summary>
            User file stream close callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <remarks>With a buffered file stream, this function is called as soon as reading reaches the end of the file. 
            If the stream is freed before then, this function could be called while its <see cref="T:Un4seen.Bass.FILEREADPROC"/> function is in progress. 
            If that happens, the <see cref="T:Un4seen.Bass.FILEREADPROC"/> function call should be immediately cancelled.
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.FILELENPROC">
            <summary>
            User file stream length callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <returns>The length of the file in bytes. 
            Returning 0 for a buffered file stream, makes BASS stream the file in blocks, and is equivalent to using the BASS_STREAM_BLOCK flag 
            in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> call.</returns>
            <remarks>This function is called first thing, and is only used the once with buffered streams. 
            With unbuffered streams, it may be used again when testing for EOF (end of file), 
            allowing the file to grow in size.
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.FILEREADPROC">
            <summary>
            User file stream read callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="buffer">Pointer to the buffer to put the data in.</param>
            <param name="length">Maximum number of bytes to read.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes read... -1 = end of file, 0 = end of file (buffered file stream only).</returns>
            <remarks>During creation of the stream, this function should try to return the amount of data requested. 
            After that, it can just return whatever is available up to the requested amount.
            <para>For an unbuffered file stream during playback, this function should be as quick as possible - 
            any delays will not only affect the decoding of the current stream, but also all other streams and MOD musics that are playing. 
            It is better to return less data (even none) rather than wait for more data. 
            A buffered file stream isn't affected by delays like this, as this function runs in its own thread then.</para>
            </remarks>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.FILESEEKPROC">
            <summary>
            User file stream seek callback function (to be used with <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>).
            </summary>
            <param name="offset">Position in bytes to seek to.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFileUser(Un4seen.Bass.BASSStreamSystem,Un4seen.Bass.BASSFlag,Un4seen.Bass.BASS_FILEPROCS,System.IntPtr)"/> was called.</param>
            <returns><see langword="true"/> if successful, else <see langword="false"/>.</returns>
            <example>See <see cref="T:Un4seen.Bass.BASS_FILEPROCS"/>.</example>
        </member>
        <member name="T:Un4seen.Bass.DSPPROC">
            <summary>
            User defined DSP callback function (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>).
            </summary>
            <param name="handle">The DSP handle (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>).</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The pointer to the buffer to apply the DSP to. The sample data is in standard Windows PCM format - 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to 1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> was called.</param>
            <remarks>
            <para>A DSP function should obviously be as quick as possible... playing streams, MOD musics and other DSP functions can not be processed until it has finished.</para>
            <para>Some functions can cause problems if called from within a DSP (or stream) function. Do not call these functions from within a DSP callback:</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> (or any other stream creation functions).</para>
            <para>Also, do not call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/> with the same DSP handle as received by the callback, or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicFree(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> with the same channel handle as received by the callback.</para>
            <para>If the BASS_CONFIG_FLOATDSP config option is set, then DSP callback functions will always be passed 32-bit floating-point sample data, regardless of what the channels' actual sample format is.</para>
            <para>
            It is clever to NOT alloc buffer data (e.g. a float[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'float[] data = new float[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            However, this is not always the case, so in most examples it'll work just fine - but if you got problems - try moving any memory allocation things outside any callbacks.
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            You might use this code as a starting reference (it assumes 32-bit floating-point sample data):
            <code>
            private DSPPROC _myDSPAddr; // make it global, so that the GC can not remove it
            private float[] _data; // local data buffer
            ...
            _myDSPAddr = new DSPPROC(MyDSPCallback);
            Bass.BASS_ChannelSetDSP(_stream, _myDSPAddr, IntPtr.Zero, 2);
            ...
            private void MyDSPCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (length == 0 || buffer == IntPtr.Zero)
                return;
              // number of bytes in 32-bit floats, since length is in bytes
              int l4 = length/4;
              // increase the data buffer as needed
              if (_data == null || _data.Length &lt; l4)
                _data = new float[l4];
              // copy from managed to unmanaged memory
              Marshal.Copy(buffer, _data, 0, l4);
            	
              // ... do your processing here
                
              // copy back from unmanaged to managed memory
              Marshal.Copy(_data, 0, buffer, l4);
            }
            </code>
            <code lang="vbnet">
            Private _myDSPAddr As DSPPROC  ' make it global, so that the GC can not remove it
            Private _data As Single() = Nothing  ' our local buffer
            ...
            _myDSPAddr = New DSPPROC(AddressOf MyDSPCallback)
            Bass.BASS_ChannelSetDSP(_stream, _myDSPAddr, IntPtr.Zero, 2)
            ...
            Private Sub MyGain(handle As Integer, channel As Integer, 
                               buffer As IntPtr, length As Integer, user As IntPtr)
              If length = 0 OrElse buffer = IntPtr.Zero Then
                Return
              End If
              ' number of bytes in 32-bit floats, since length is in bytes
              Dim l4 As Integer = length / 4
              ' increase the data buffer as needed
              If _data Is Nothing OrElse _data.Length &lt; l4 Then
                _data = New Single(l4) {}
              End If
              ' copy from unmanaged to managed memory
              Marshal.Copy(buffer, _data, 0, l4)
              	
              // ... do your processing here
            
              ' copy back from unmanaged to managed memory
              Marshal.Copy(_data, 0, buffer, l4)
            End Sub
            </code>
            If you're using C# you might even use unsafe code blocks to directly access memory via pointers, like in C/C++:
            <para>Note: such application must be compiled using the /unsafe compiler option!</para>
            <code>
            myDSPAddr = new DSPPROC(MyDSPGainUnsafe);
            Bass.BASS_ChannelSetDSP(_stream, myDSPAddr, IntPtr.Zero, 2);
            ...
            // the unsafe callback
            private DSPPROC myDSPAddr; // make it global, so that the Garbage Collector can not remove it
            private void MyDSPGainUnsafe(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              if (_gainAmplification == 1f || length == 0 || buffer == IntPtr.Zero)
                return;
              // length is in bytes, so the number of floats to process is:
              // length/4 : byte = 8-bit, float = 32-bit
              int l4 = length/4;
              unsafe
              {
                float *data = (float*)buffer;
                for (int a=0; a&lt;l4; a++)
                {
                  data[a] *= _gainAmplification;
                }
              }
            }
            </code>
            Using unsafe code is fast and efficient (especially in DSP routines), but is not type safe (e.g. no overflow handling, no type checking etc.) - so you just need to know what you are doing.
            </example>
        </member>
        <member name="T:Un4seen.Bass.DOWNLOADPROC">
            <summary>
            Internet stream download callback function (to be used with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/>).
            </summary>
            <param name="buffer">The pointer to the buffer containing the downloaded data... <see cref="F:System.IntPtr.Zero"/> = finished downloading.</param>
            <param name="length">The number of bytes in the buffer... 0 = HTTP or ICY tags.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>The callback will be called before the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> call returns (if it's successful), with the initial downloaded data. So any initialization (eg. creating the file if writing to disk) needs to be done either before the call, or in the callback function.</para>
            <para>When the BASS_STREAM_STATUS flag is specified in the <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateURL(System.String,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.DOWNLOADPROC,System.IntPtr)"/> call, HTTP and ICY tags may be passed to the callback during connection, before any stream data is received. The tags are given exactly as would be returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetTags(System.Int32,Un4seen.Bass.BASSTag)"/>. You can destinguish between HTTP and ICY tags by checking what the first string starts with ("HTTP" or "ICY").</para>
            <para>A download callback function could be used in conjunction with a BASS_SYNC_META sync set via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>, to save individual tracks to disk from a Shoutcast stream.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            Stream an MP3 file, and save a local copy:
            <code>
            private FileStream _fs = null;
            private DOWNLOADPROC _myDownloadProc;
            private byte[] _data; // local data buffer
            ...
            _myDownloadProc = new DOWNLOADPROC(MyDownload);
            int stream = Bass.BASS_StreamCreateURL("http://www.asite.com/afile.mp3", 0, 
                              BASSFlag.BASS_DEFAULT, _myDownloadProc, IntPtr.Zero);
            ...
            private void MyDownload(IntPtr buffer, int length, IntPtr user)
            {
              if (_fs == null) 
              {
                // create the file
                _fs = File.OpenWrite( "output.mp3" );
              }
              if (buffer == IntPtr.Zero)
              {
                // finished downloading
                _fs.Flush();
                _fs.Close();
              }
              else
              {
                // increase the data buffer as needed
                if (_data == null || _data.Length &lt; length)
                  _data = new byte[length];
                // copy from managed to unmanaged memory
                Marshal.Copy(buffer, _data, 0, length);
                // write to file
                _fs.Write( _data, 0, length );
              }
            }
            </code>
            <code lang="vbnet">
            Private _fs As FileStream = Nothing
            Private _myDownloadProc As DOWNLOADPROC
            Private _data() As Byte ' local data buffer
            ...
            _myDownloadProc = New DOWNLOADPROC(AddressOf MyDownload)
            Dim stream As Integer = Bass.BASS_StreamCreateURL("http://www.asite.com/afile.mp3", 0, 
                                         BASSFlag.BASS_DEFAULT, _myDownloadProc, IntPtr.Zero)
            ...
            Private Sub MyDownload(buffer As IntPtr, length As Integer, user As IntPtr)
              If _fs Is Nothing Then
                ' create the file
                _fs = File.OpenWrite("output.mp3")
              End If
              If buffer = IntPtr.Zero Then
                ' finished downloading
                _fs.Flush()
                _fs.Close()
              Else
                ' increase the data buffer as needed
                If _data Is Nothing OrElse _data.Length &lt; length Then
                  _data = New Byte(length) {}
                End If
                ' copy from managed to unmanaged memory
                Marshal.Copy(buffer, _data, 0, length)
                ' write to file
                _fs.Write(_data, 0, length)
              End If
            End Sub
            </code>
            Note: If you are into C# the above example can also make use of usafe code blocks using native pointers to read the data from BASS and to write it to a file:
            <code>
            // within your download callback method...
            // assuming you have created a: BinaryWriter bw = new BinaryWriter(_fs);
            unsafe
            {
              // simply cast the given IntPtr to a native pointer to short values
              // assuming you receive 16-bit sample data here
              short *data = (short*)buffer;
              for (int a = 0; a &lt; length/2; a++)
              {
                // write the received sample data to a local file
                bw.Write( data[a] );
              }
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.SYNCPROC">
            <summary>
            User defined synchronizer callback function (see <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> for details).
            </summary>
            <param name="handle">The sync handle that has occured (as returned by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/>).</param>
            <param name="channel">The channel that the sync occured on.</param>
            <param name="data">Additional data associated with the sync's occurance.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            <para>BASS creates a single thread dedicated to executing sync callback functions, so a callback function should be quick as other syncs cannot be processed until it has finished. Attribute slides (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelSlideAttribute(System.Int32,Un4seen.Bass.BASSAttribute,System.Single,System.Int32)"/>) are also performed by the sync thread, so are also affected if a sync callback takes a long time.</para>
            <para>"Mixtime" syncs (BASS_SYNC_MIXTIME) are not executed in the sync thread, but immediately in whichever thread triggers them. In most cases that will be an update thread, and so the same restrictions that apply to stream callbacks (<see cref="T:Un4seen.Bass.STREAMPROC"/>) also apply here.</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/> can be used in a mixtime sync to implement custom looping, eg. set a BASS_SYNC_POS sync at the loop end position and seek to the loop start position in the callback.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            Do some processing until a MOD music reaches the 10th order
            <code>
            private volatile bool _order10 = false; // the order 10 flag
            private SYNCPROC _mySyncProc;
            ...
            // set the one-time order 10 sync
            _mySyncProc = new SYNCPROC(MySync);
            Bass.BASS_ChannelSetSync(music, BASSSync.BASS_SYNC_MUSICPOS | BASSSync.BASS_SYNC_ONETIME, 
                 Utils.MakeLong64(10,0), _mySyncProc, IntPtr.Zero);
            while (!_order10) 
            {
              // order 10 has not arrived, so do some processing
              Thread.Sleep(0);
            }
            // order 10 has arrived!
            ...
            // the sync callback
            private void MySync(int syncHandle, int channel, int data, IntPtr user) 
            {
            	_order10 = true; // set the order 10 flag
            }
            </code>
            <code lang="vbnet">
            Private _order10 As Boolean = False ' the order 10 flag
            Private _mySyncProc As SYNCPROC
            ...
            ' set the one-time order 10 sync
            _mySyncProc = New SYNCPROC(AddressOf MySync)
            Bass.BASS_ChannelSetSync(music, BASSSync.BASS_SYNC_MUSICPOS Or BASSSync.BASS_SYNC_ONETIME, 
                 Utils.MakeLong64(10, 0), _mySyncProc, IntPtr.Zero)
            While Not _order10
              ' order 10 has not arrived, so do some processing
              Thread.Sleep(0)
            End While
            ' order 10 has arrived!
            ...
            ' the sync callback
            Private Sub MySync(syncHandle As Integer, channel As Integer, data As Integer, user As IntPtr)
              _order10 = True ' set the order 10 flag
            End Sub
            </code>
            Process metadata received from an internet stream:
            <code>
            private SYNCPROC _mySync;
            ...
            int stream = Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, null, 0);
            // set a sync to get notified on stream title updates
            _mySync = new SYNCPROC(MetaSync);
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero);
            Bass.BASS_ChannelPlay(stream, false);
            ...
            private void MetaSync(int handle, int channel, int data, IntPtr user)
            {
              // BASS_SYNC_META is triggered
              string[] tags = Bass.BASS_ChannelGetTagsMETA(channel);
              foreach (string tag in tags)
                Console.WriteLine(tag);
            }
            </code>
            <code lang="vbnet">
            Private _mySync As SYNCPROC
            ...
            Dim stream As Integer =  Bass.BASS_StreamCreateURL(url, 0, BASSFlag.BASS_DEFAULT, Nothing, 0) 
            ' set a sync to get notified on stream title updates
            _mySync = New SYNCPROC(AddressOf MetaSync)
            Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_META, 0, _mySync, IntPtr.Zero)
            Bass.BASS_ChannelPlay(stream, False)
            ...
            Private Sub MetaSync(ByVal handle As Integer, ByVal channel As Integer, 
                                 ByVal data As Integer, ByVal user As IntPtr)
              ' BASS_SYNC_META is triggered
              Dim tags() As String = Bass.BASS_ChannelGetTagsMETA(channel) 
              Dim tag As String
              For Each tag In tags
                Console.WriteLine(tag)
            End Sub
            </code>
            Perform a loop between a start and end position:
            <code>
            private int _loopSync = 0;
            private SYNCPROC _loopSyncCallback;
            ...
            long loopStartPos = 1024;  // set to whatever you need
            long loopEndPos   = 20480; // set to whatever you need
            _loopSyncCallback = new SYNCPROC(LoopSync);
            _loopSync = Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_POS | BASSSync.BASS_SYNC_MIXTIME, 
                                                 loopEndPos, _loopSyncCallback, new IntPtr(loopStartPos));
            ...
            // to remove the loop call this
            Bass.Bass.BASS_ChannelRemoveSync(stream, _loopSync);
            ...
            // the sync callback
            private void LoopSync(int syncHandle, int channel, int data, IntPtr user) 
            {
                // move the position to the start (which is given in the user data)
                Bass.BASS_ChannelSetPosition(channel, user.ToInt64());
            }
            </code>
            <code lang="vbnet">
            Private _loopSync As Integer = 0 
            Private _loopSyncCallback As SYNCPROC 
            ...
            Dim loopStartPos As Long = 1024  ' set to whatever you need
            Dim loopEndPos As Long   = 20480 ' set to whatever you need
            _loopSyncCallback = New SYNCPROC(AddressOf LoopSync);
            _loopSync = Bass.BASS_ChannelSetSync(stream, BASSSync.BASS_SYNC_POS Or BASSSync.BASS_SYNC_MIXTIME, 
                                                 loopEndPos, _loopSyncCallback, New IntPtr(loopStartPos)) 
            ...
            ' to remove the loop call this
            Bass.Bass.BASS_ChannelRemoveSync(stream, _loopSync)
            ...
            ' the sync callback
            Private Sub LoopSync(ByVal handle As Integer, ByVal channel As Integer, 
                                 ByVal data As Integer, ByVal user As IntPtr)
                ' move the position to the start (which is given in the user data)
                Bass.BASS_ChannelSetPosition(channel, user.ToInt64())
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.RECORDPROC">
            <summary>
            User defined callback function to process recorded sample data.
            </summary>
            <param name="handle">The recording handle that the data is from.</param>
            <param name="buffer">The pointer to the buffer containing the recorded sample data. The sample data is in standard Windows PCM format, that is 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1.</param>
            <param name="length">The number of bytes in the buffer.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/> was called.</param>
            <returns>Return <see langword="false"/> to stop recording, and anything else to continue recording.</returns>
            <remarks>
            <see cref="M:Un4seen.Bass.Bass.BASS_RecordFree"/> should not be used to free the recording device within a recording callback function. Nor should <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/> be used to stop the recording; return <see langword="false"/> to do that instead.
            <para>
            It is clever to NOT alloc any buffer data (e.g. a byte[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'byte[] data = new byte[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...
            </para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _byteswritten = 0;
            private byte[] _recbuffer; // local recording buffer
            ...
            if ( Bass.BASS_RecordInit(-1) )
            {
              _myRecProc = new RECORDPROC(MyRecording);
              int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero);
              ...
              // start recording
              Bass.BASS_ChannelPlay(recHandle, false);
            }
            ...
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // increase the rec buffer as needed
                if (_recbuffer == null || _recbuffer.Length &lt; length)
                  _recbuffer = new byte[length];
                // copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length);
                _byteswritten += length;
                // write to file
                ...
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _byteswritten As Integer = 0
            Private _recbuffer() As Byte ' local recording buffer
            ...
            If Bass.BASS_RecordInit(-1) Then
              _myRecProc = New RECORDPROC(AddressOf MyRecording)
              Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _myRecProc, IntPtr.Zero)
              ...
              ' start recording
              Bass.BASS_ChannelPlay(recHandle, False)
            End If
            ...
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Dim cont As Boolean = True
              If length &gt; 0 AndAlso buffer &lt;&gt; IntPtr.Zero Then
                ' increase the rec buffer as needed
                If _recbuffer Is Nothing OrElse _recbuffer.Length &lt; length Then
                  _recbuffer = New Byte(length) {}
                End If
                ' copy from managed to unmanaged memory
                Marshal.Copy(buffer, _recbuffer, 0, length)
                _byteswritten += length
                ' write to file
                ...
                ' stop recording after a certain amout (just to demo)
                If _byteswritten &gt; 800000 Then
                  cont = False ' stop recording
                End If
              End If
              Return cont
            End Function
            </code>
            If you are into C# you might also use an unsafe codeblock with native pointer access 
            (which might be must faster than the above - depending on what you are doing with the data):
            <code>
            private unsafe bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
              bool cont = true;
              if (length &gt; 0 &amp;&amp; buffer != IntPtr.Zero)
              {
                // assuming 16-bit sample data here
                short *data = (short*)buffer;
                ...
            
                // stop recording after a certain amout (just to demo)
                if (_byteswritten &gt; 800000)
                  cont = false; // stop recording
              }
              return cont;
            }
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCast">
            <summary>
            Enables streaming of audio content to the internet.
            </summary>
            <remarks>
            <para>To setup broadcast streaming you first need to create an instance of a class, which is derived from the <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> class (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>).
            These classes will contain all necessary configuration data (e.g. server address an port, username and password, station description etc., as well as an <see cref="T:Un4seen.Bass.Misc.IBaseEncoder"/> instance, which defines the target broadcasting encoder format).</para>
            <para>The BroadCast class support manual streaming (e.g. in your own <see cref="T:Un4seen.Bass.DSPPROC"/> or <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>) as well as
            automatic streaming. Automatic streaming is implemented internally also via a user DSP.</para>
            <para>If you want to broadcast to multiple outputs (multiple servers) you need to create an instance for each output seperately.</para>
            </remarks>
            <example>
            The following example uses the generic Encoder-Framework with the generic StreamingServer-Framework 
            to implement streaming of any recording data (here uing LAME MP3 encoding to a SHOUTcast server):
            <code>
            private int _recHandle;
            private BroadCast _broadCast;
            ...
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, null, 0);
            ...
            // create an encoder instance (e.g. for MP3 use EncoderLAME):
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.InputFile = null;	//STDIN
            lame.OutputFile = null;	//STDOUT
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // create a StreamingServer instance (e.g. SHOUTcast) using the encoder:
            SHOUTcast shoutcast = new SHOUTcast(lame);
            shoutcast.ServerAddress = "localhost";
            shoutcast.ServerPort = 8000;
            shoutcast.Password = "changeme";
            shoutcast.PublicFlag = true;
            
            // use the BroadCast class to control streaming:
            _broadCast = new BroadCast(shoutcast);
            _broadCast.AutoReconnect = true;
            _broadCast.Notification += new BroadCastEventHandler(OnBroadCast_Notification);
            _broadCast.AutoConnect();
            
            private void OnBroadCast_Notification(object sender, BroadCastEventArgs e)
            {
              // Note: this method might be called from another thread (non UI thread)!
              if (_broadCast == null)
                return;
              if (_broadCast.IsConnected)
              {
                // we are connected...
              }
              else
              {
                // we are not connected...
              }
            }
            </code>
            <code lang="vbnet">
            Private _recHandle As Integer
            Private _broadCast As BroadCast
            ...
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, Nothing, 0)
            ...
            ' create an encoder instance (e.g. for MP3 use EncoderLAME):
            Dim lame As New EncoderLAME(_recHandle)
            lame.InputFile = Nothing 'STDIN
            lame.OutputFile = Nothing 'STDOUT
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' create a StreamingServer instance (e.g. SHOUTcast) using the encoder:
            Dim shoutcast As New SHOUTcast(lame)
            shoutcast.ServerAddress = "localhost"
            shoutcast.ServerPort = 8000
            shoutcast.Password = "changeme"
            shoutcast.PublicFlag = True
            
            ' use the BroadCast class to control streaming:
            _broadCast = New BroadCast(shoutcast)
            _broadCast.AutoReconnect = True
            AddHandler _broadCast.Notification, AddressOf OnBroadCast_Notification
            _broadCast.AutoConnect()
            
            Private Sub OnBroadCast_Notification(sender As Object, e As BroadCastEventArgs)
              ' Note: this method might be called from another thread (non UI thread)!
              If _broadCast Is Nothing Then
                Return
              End If
              If _broadCast.IsConnected Then
                ' we are connected...
              Else
                ' we are not connected...
              End If 
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.#ctor">
            <summary>
            Default constructor not allowed.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.#ctor(Un4seen.Bass.Misc.IStreamingServer)">
            <summary>
            Creates an instance of the broadcasting class using the specified streaming server.
            </summary>
            <param name="server">Instance of a streaming server class to use (containing the configuration and parameter data).</param>
            <remarks>In order to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> instance use one of the implementations (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>).</remarks>
        </member>
        <member name="E:Un4seen.Bass.Misc.BroadCast.Notification">
            <summary>
            Event handler used to notify that the BroadCast status has changed or that a BroadCast event has occurred.
            </summary>
            <remarks>It is a good idea to subscribe to this event handler before calling <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> or <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>.
            <para>The properties <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSuppressDataSend"/> and <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSuppressIsAlive"/> might be used to suppress sending certain events.</para>
            <para>The <see cref="T:Un4seen.Bass.Misc.BroadCastEventArgs"/> contains a <see cref="T:Un4seen.Bass.Misc.BroadCastEventType"/> which allows you to react to all possible scenarios and to log all these events.</para>
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            <para>When using a server whose UseBASS property is set to <see langword="true"/> (which is the default) the 'DataSend' notification will not be raised.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.Server">
            <summary>
            Returns the streaming server interface which is used with this instance.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.IsConnected">
            <summary>
            Connected to the server? (<see langword="true"/>=connected).
            </summary>
            <remarks>Sending encoded data to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> via <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/> should only be performed, if connected to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> 
            and the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag set to <see langword="false"/>!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.IsStarted">
            <summary>
            Is the server started? (<see langword="true"/>=started).
            </summary>
            <remarks>This property might also return <see langword="true"/> if the status is not connected in case you set <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> to true.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.Status">
            <summary>
            Gets the current broadcast status.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode">
            <summary>
            Gets if the automatic mode was used (<see langword="true"/>, if <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/> was called, else <see langword="false"/> meaning <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> was used instead).
            </summary>
            <remarks>When the automatic mode is used, the following is handled directly by this class and does not need to be handled manually:
            <para>Setup of an internal encoder callback procedure and sending of the encoded data to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> (either internally or via <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>).
            So the only task you need to handle is title updates manually when in automatic mode.</para>
            <para>Please note, that some methods should NOT be used, if in automatic mode: <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect">
            <summary>
            Gets or Sets if the broadcast connection should automatically be reconnected in case of a connection or encoder error (default=<see langword="false"/>).
            </summary>
            <remarks>The auto connect feature can be used for both <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>.
            <para>When AutoReconnect was set to <see langword="true"/>, the following will be checked automatically:</para>
            <para>1. Is the encoder still active? - if not, restart encoder, if in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>.</para>
            <para>2. Are we still connected to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>? - if not, reconnect to the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>.</para>
            <para>This means, that if you are NOT in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>, you need to restart your <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/> manually.
            You can do so by subscribing to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler and react on the <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderRestartRequired"/> event and then call <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> again.</para>
            <para>Please note, that the encoder will automatically be stopped, if a reconnect to the server was not successful!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout">
            <summary>
            Gets or Sets the reconnect timeout in seconds (default is 5sec.).
            </summary>
            <remarks>The auto connect feature can be used for both <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>.
            <para>The timeout period must be between 1 and 86400 seconds.</para>
            <para>Changing the reconnect timeout takes immediate effect.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.NotificationSuppressDataSend">
            <summary>
            Gets or Sets, if the <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.DataSend"/> event will be raised when subscribed to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler (default is <see langword="false"/>).
            </summary>
            <remarks>Note: If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag set to <see langword="true"/> this property will have no effect.
            A <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> with <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> will be unable to to report the number of bytes send to the server.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.NotificationSuppressIsAlive">
            <summary>
            Gets or Sets, if the <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.IsAlive"/> event will be raised when subscribed to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler and <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> is enabled (default is <see langword="false"/>).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.TotalBytesSend">
            <summary>
            Returns the total number of bytes send to the server during a broadcast.
            </summary>
            <remarks>
            If the value reaches the maximum (Int64.MaxValue) it will be wrapped around and reset to 0 (zero).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCast.TotalConnectionTime">
            <summary>
            Returns the total online connection time (for how long the broadcast is already running since it was connected).
            </summary>
            <remarks>This value is only correct, if <see cref="P:Un4seen.Bass.Misc.BroadCast.IsConnected"/> is <see langword="true"/> resp. the broadcast <see cref="P:Un4seen.Bass.Misc.BroadCast.Status"/> is CONNECTED.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.AutoConnect">
            <summary>
            Connects automatically to a broadcast server (performs a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> and <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/>).
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>
            <para>If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag to <see langword="true"/>, the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> will handle any communication via <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastInit(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.Boolean)"/>.</para>
            <para>If the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/> has set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> flag to <see langword="false"/>, the following will be handled:</para>
            <para>Prior to the <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> an internal encoder callback will be created.</para>
            <para>The internal encoder callback is created using <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.
            This internal callback will already handle the <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> automatically for you.</para>
            <para>If already connected, this method will first <see cref="M:Un4seen.Bass.Misc.BroadCast.Disconnect"/> from the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>, which might result in stopping the underlying <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/>.</para>
            <para>If the channel handle (as defined in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>) is already playing, it will be shortly paused during the setup and resumed when done.</para>
            <para>Please note, that some methods should NOT be used, if in automatic mode: <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, <see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> and <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>!</para>
            <para>Note: If you have set the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> property to <see langword="true"/> this call will automatically try to reconnect even if this method returns <see langword="false"/>!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.Connect">
            <summary>
            Connects manually to a broadcast server (performs a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> and <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/>).
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>The automatic reconnect settings (<see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> and <see cref="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout"/>) will also work with a manual connection.
            But, you must create and handle your own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback and call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> manually!
            <para>If already connected, this method will first <see cref="M:Un4seen.Bass.Misc.BroadCast.Disconnect"/> from the <see cref="P:Un4seen.Bass.Misc.BroadCast.Server"/>, which might result in stopping the underlying <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/>.</para>
            <para>If the channel handle (as defined in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>) is already playing, it will be shortly paused during the setup and resumed when done.</para>
            <para>Note: If you have set the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> property to <see langword="true"/> this call will automatically try to reconnect even if this method returns <see langword="false"/>!</para>
            </remarks>
            <example>
            This example demonstrates manual broadcasting:
            <code>
            private BroadCast _broadCast;
            private ENCODEPROC _myEncProc;
            ...
            // create your encoder (using a recording handle)
            EncoderLAME lame = new EncoderLAME(_recHandle);
            
            // create an streaming server instance
            SHOUTcast shoutcast = new SHOUTcast(lame);
            
            // create the broadcast instance
            _broadCast = new BroadCast(shoutcast);
            _broadCast.AutoReconnect = true;
            _broadCast.Notification += new BroadCastEventHandler(OnBroadCast_Notification);
            
            // create your encoder callback
            _myEncProc = new ENCODEPROC(MyEncodingCallback);
            // start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, true);
            // now connect to start your broadcast
            _broadCast.Connect();
            // and really start the encoder
            _broadCast.Server.Encoder.Pause(false);
            ...
            
            // your broadcast encoder callback implementation
            private void MyEncodingCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // here we receive the encoded data back (manual mode)
              if ( _broadCast.IsConnected )
              {
                _broadCast.SendData(buffer, length);
              }
            }
            
            private void OnBroadCast_Notification(object sender, BroadCastEventArgs e)
            {
              if (e.EventType == BroadCastEventType.EncoderRestartRequired)
                _broadCast.StartEncoder(_myEncProc, 0);
            	
              if (!_broadCast.IsConnected)
              {
                // connection lost
              }
            }
            </code>
            <code lang="vbnet">
            Private _broadCast As BroadCast
            Private _myEncProc As ENCODEPROC
            ...
            ' create your encoder (using a recording handle)
            Dim lame As New EncoderLAME(_recHandle)
            
            ' create an streaming server instance
            Dim shoutcast As New SHOUTcast(lame)
            
            ' create the broadcast instance
            _broadCast = New BroadCast(shoutcast)
            _broadCast.AutoReconnect = True
            AddHandler _broadCast.Notification, AddressOf OnBroadCast_Notification
            
            ' create your encoder callback
            _myEncProc = New ENCODEPROC(AddressOf MyEncodingCallback)
            ' start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, True)
            ' now connect to start your broadcast
            _broadCast.Connect()
            ' and really start the encoder
            _broadCast.Server.Encoder.Pause(False)
            ...
            
            ' your broadcast encoder callback implementation
            Private Sub MyEncodingCallback(handle As Integer, channel As Integer, 
                                           buffer As IntPtr, length As Integer, user As IntPtr)
              ' here we receive the encoded data back (manual mode)
              If _broadCast.IsConnected Then
                _broadCast.SendData(buffer, length)
              End If
            End Sub
            
            Private Sub OnBroadCast_Notification(sender As Object, e As BroadCastEventArgs)
              If e.EventType = BroadCastEventType.EncoderRestartRequired Then
                _broadCast.StartEncoder(_myEncProc, 0)
              End If 
            
              If Not _broadCast.IsConnected Then
                ' connection lost
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.Disconnect">
            <summary>
            Disconnects from the broadcast server calling <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/> (also stops the encoder using <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/>).
            </summary>
            <returns><see langword="true"/> on success (not connected), else <see langword="false"/> (connection status unknown, see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>This method disconnects no matter if you started broadcasting in the automatic mode (via <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>) or manually (via <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>).
            <para>Note: If you stop or free the underlying stream channel you must also call this method in order to disconnect from the server.</para>
            <para>Caution: Disconnecting will in any case also stop the underlying server encoder in use (<see cref="M:Un4seen.Bass.Misc.BroadCast.StopEncoder"/> will be called!).
            So if you started broadcasting in the manual mode (via <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>) you need to manually start your encoder again.
            If you have enabled the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> feature a <see cref="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderRestartRequired"/> event <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> will be raised.</para>
            <para>If this method returns <see langword="false"/>, check the <see cref="P:Un4seen.Bass.Misc.BroadCast.Status"/>, it might be the case, that you are still connected (e.g. if the encoder could not be stopped)!</para>
            <para>Once disconnected successfully, the <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/> feature will also be disabled (no further connect retries will be made). 
            You need to start broadcasting again via <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> or <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/> in order to restart.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.StartEncoder(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            Starts the underlying encoder (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/>).
            </summary>
            <param name="proc">Optional callback function to receive the encoded data. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If <see langword="true"/>, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Return <see langword="true"/>, if the encoder was successfully started - else <see langword="false"/> is returned (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>
            <para>Do NOT call this method, if you are in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>, since the encoder will be started automatically in this case.</para>
            <para>If the encoder was already started, this method anyhow returns <see langword="true"/> - however no <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event will be raised in this case.</para>
            <para>If you <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> manually, your <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> must call <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/> manually as well, see the example below.</para>
            </remarks>
            <example>
            This example demonstrates a user defined ENCODEPROC:
            <code>
            private BroadCast _broadCast;
            private ENCODEPROC _myEncProc;
            ...
            // create your encoder (using a recording handle)
            EncoderLAME lame = new EncoderLAME(_recHandle);
            
            // create an streaming server instance
            SHOUTcast shoutcast = new SHOUTcast(lame);
            
            // create the broadcast instance
            _broadCast = new BroadCast(shoutcast);
            _broadCast.AutoReconnect = true;
            _broadCast.Notification += new BroadCastEventHandler(OnBroadCast_Notification);
            
            // create your encoder callback
            _myEncProc = new ENCODEPROC(MyEncodingCallback);
            // start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, true);
            // now connect to start your broadcast
            _broadCast.Connect();
            // and really start the encoder
            _broadCast.Server.Encoder.Pause(false);
            ...
            
            // your broadcast encoder callback implementation
            private void MyEncodingCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // here we receive the encoded data back (manual mode)
              if ( _broadCast.IsConnected )
              {
                _broadCast.SendData(buffer, length);
              }
            }
            
            private void OnBroadCast_Notification(object sender, BroadCastEventArgs e)
            {
              if (e.EventType == BroadCastEventType.EncoderRestartRequired)
                _broadCast.StartEncoder(_myEncProc, 0);
            	
              if (!_broadCast.IsConnected)
              {
                // connection lost
              }
            }
            </code>
            <code lang="vbnet">
            Private _broadCast As BroadCast
            Private _myEncProc As ENCODEPROC
            ...
            ' create your encoder (using a recording handle)
            Dim lame As New EncoderLAME(_recHandle)
            
            ' create an streaming server instance
            Dim shoutcast As New SHOUTcast(lame)
            
            ' create the broadcast instance
            _broadCast = New BroadCast(shoutcast)
            _broadCast.AutoReconnect = True
            AddHandler _broadCast.Notification, AddressOf OnBroadCast_Notification
            
            ' create your encoder callback
            _myEncProc = New ENCODEPROC(AddressOf MyEncodingCallback)
            ' start the encoder (paused)
            _broadCast.StartEncoder(_myEncProc, IntPtr.Zero, True)
            ' now connect to start your broadcast
            _broadCast.Connect()
            ' and really start the encoder
            _broadCast.Server.Encoder.Pause(False)
            ...
            
            ' your broadcast encoder callback implementation
            Private Sub MyEncodingCallback(handle As Integer, channel As Integer, 
                                           buffer As IntPtr, length As Integer, user As IntPtr)
              ' here we receive the encoded data back (manual mode)
              If _broadCast.IsConnected Then
                _broadCast.SendData(buffer, length)
              End If
            End Sub
            
            Private Sub OnBroadCast_Notification(sender As Object, e As BroadCastEventArgs)
              If e.EventType = BroadCastEventType.EncoderRestartRequired Then
                _broadCast.StartEncoder(_myEncProc, 0)
              End If 
            
              If Not _broadCast.IsConnected Then
                ' connection lost
              End If
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.StopEncoder">
            <summary>
            Stops the <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/>
            </summary>
            <returns><see langword="true"/>, if the encoder was stopped successfully, else <see langword="false"/> is returned (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Please note that, if <see langword="false"/> is returned, the <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/> will still be active.
            <para>If you are handling broadcasting manually (by using <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/>), it is a good idea to stop the encoder whenever you are not connected anymore.
            You might check the status of the broadcast connection by asking for the <see cref="P:Un4seen.Bass.Misc.BroadCast.Status"/> or by subscribing to the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event handler.</para>
            <para>If the encoder was already stopped, this method returns <see langword="true"/> - however no <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification"/> event will be raised in this case.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data manually to the broadcast server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>).
            In this case the <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> feature (if enabled) will try a reconnect after <see cref="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the title of the playing song on a broadcast server.
            </summary>
            <param name="song">The new song title to set (if <see langword="null"/> or empty <see langword="false"/> will be returned).</param>
            <param name="url">The optional song url to go along with the title (only for SHOUTcast - else <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>This method can be used for both the manual and the automatic connection mode.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.UpdateTitle(Un4seen.Bass.AddOn.Tags.TAG_INFO,System.String)">
            <summary>
            Updates the title of the playing song on a broadcast server.
            </summary>
            <param name="tag">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance to use to set the new song title (if <see langword="null"/> or empty <see langword="false"/> will be returned).</param>
            <param name="url">The optional song url to go along with the title (only for SHOUTcast - else <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>This method can be used for both the manual and the automatic connection mode.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
            <remarks>Some <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementations might not be able to retrieve the current listener count, in which case -1 would be returned.
            However, the following servers should be supported: SHOUTcast, ICEcast, WMAcast (if not using a publishing point).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">An optional password to use (should be set to <see langword="null"/> to use the default publish password).</param>
            <returns>The string representing the XML formatted statistics (or <see langword="null"/> on error/not available).</returns>
            <remarks>Some <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementations might not be able to retrieve an XML statistic, in which case <see langword="null"/> would be returned.
            However, the following servers should be supported: SHOUTcast, ICEcast, WMAcast.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS">
            <summary>
            List of all possible broadcast status.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS.NotConnected">
            <summary>
            Not connected.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS.Connected">
            <summary>
            Connected to the broadcast server.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCast.BROADCASTSTATUS.Unknown">
            <summary>
            Connection status is unknown.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCastEventHandler">
            <summary>
            Definition of the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification" /> event handler.
            </summary>
            <param name="sender">Set to the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> object instance that raised the event.</param>
            <param name="e">An instance of the <see cref="T:Un4seen.Bass.Misc.BroadCastEventArgs"/> event args containing the event details.</param>
            <remarks>
            This definition complies with the .NET Framework's standard for event handlers.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCastEventType">
            <summary>
            Types of event that has occurred with the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>
            A variable of this type is passed inside the <see cref="T:Un4seen.Bass.Misc.BroadCastEventArgs"/> object 
            for the <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification" /> event.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.Connected">
            <summary>
            A connection to the server was successfully established.
            <para>Object data: DateTime (start of connection).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.Disconnected">
            <summary>
            The server was disconnected (either by user request or due to a connection error).
            <para>Object data: DateTime (time of disconnect).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.DisconnectError">
            <summary>
            An error occurred during the disconnect (the server might still be connected).
            <para>Object data: DateTime (time of disconnect).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.ConnectionLost">
            <summary>
            The connection was lost (can only be discovered at <see cref="M:Un4seen.Bass.Misc.BroadCast.SendData(System.IntPtr,System.Int32)"/>).
            <para>Object data: DateTime (time of lost connection).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.ConnectionError">
            <summary>
            A connection to the server could not be established (will only be raised at <see cref="M:Un4seen.Bass.Misc.BroadCast.Connect"/> or <see cref="M:Un4seen.Bass.Misc.BroadCast.AutoConnect"/>).
            <para>Object data: DateTime (time of lost connection).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.ReconnectTry">
            <summary>
            A reconnect will be tried (after the <see cref="P:Un4seen.Bass.Misc.BroadCast.ReconnectTimeout"/>).
            <para>Object data: DateTime (time of reconnect try).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.UnsuccessfulReconnectTry">
            <summary>
            A reconnect was unsuccessfully tried.
            <para>Object data: DateTime (time of unsuccessful reconnect try).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStarted">
            <summary>
            The encoder was started successfully (will only be raised in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>).
            <para>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStartError">
            <summary>
            The encoder could not be started  (will only be raised in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>).
            <para>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStopped">
            <summary>
            The encoder was stopped (will only be raised in <see cref="P:Un4seen.Bass.Misc.BroadCast.AutomaticMode"/>).
            <para>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderStopError">
            <summary>
            The encoder could not be stopped (will only be raised during <see cref="M:Un4seen.Bass.Misc.BroadCast.Disconnect"/> - the disconnect might fail and might still be connected).
            <para>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.EncoderRestartRequired">
            <summary>
            The underlying encoder is not active and needs to be started again.
            <para>Object data: <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> (the encoder instance which needs to be restarted).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.DataSend">
            <summary>
            All data was send to the server successfully (will only be raised when <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSuppressDataSend"/> is <see langword="false"/> and <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>).
            <para>Object data: long (number of bytes send).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.LessDataSend">
            <summary>
            Data was send to the server, but not all data was send (will only be raised when <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>).
            <para>Object data: int (number of bytes not send).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.IsAlive">
            <summary>
            The broadcast connection is alive and streaming is active (will only be raised when <see cref="P:Un4seen.Bass.Misc.BroadCast.AutoReconnect"/> is <see langword="true"/> and <see cref="P:Un4seen.Bass.Misc.BroadCast.NotificationSuppressIsAlive"/> is <see langword="false"/> and <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>).
            <para>Object data: DateTime (time of is alive signal).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.TitleUpdated">
            <summary>
            The song title was updated.
            <para>Object data: string (song title).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.TitleUpdateError">
            <summary>
            The song title was not updated.
            <para>Object data: string (song title).</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BroadCastEventType.Reconnected">
            <summary>
            A reconnect was successfull.
            <para>Object data: DateTime (time of reconnect).</para>
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BroadCastEventArgs">
            <summary>
            EventArgs class to be passed as the second parameter of a <see cref="E:Un4seen.Bass.Misc.BroadCast.Notification" /> event handler.
            </summary>
            <remarks>
            This class provides all the information relevant to an event which might occur to a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BroadCastEventArgs.#ctor(Un4seen.Bass.Misc.BroadCastEventType,System.Object)">
            <summary>
            Initializes a new instance of the BroadCastEventArgs class by initializing all of its properties.
            </summary>
            <param name="pEventType">The type of event which occurred (see <see cref="T:Un4seen.Bass.Misc.BroadCastEventType"/>).</param>
            <param name="pData">Some data which should be passed along with the notification event.</param>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCastEventArgs.EventType">
            <summary>
            Gets the type of event which occurred.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCastEventArgs.Data">
            <summary>
            Gets the object data which was passed along with the event.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BroadCastEventArgs.DateTime">
            <summary>
            Gets the date and time when the event occurred.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.IStreamingServer">
            <summary>
            Defines a generalized streaming server class interface that a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> class must implement.
            </summary>
            <remarks>This interface is for example used in the constructor of a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance to specify which server should be used.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.UseBASS">
            <summary>
            Gets if native BASS should be used to connect and stream to the server.
            </summary>
            <remarks>
            <para>If set to <see langword="true"/> (see constructor) native BASSenc will handle all TCP socket and cast communication.
            This should be the more secure and preferred option, however in this mode it is not possible to use the <see cref="M:Un4seen.Bass.Misc.IStreamingServer.SendData(System.IntPtr,System.Int32)"/> method manually!</para>
            <para>If set to <see langword="false"/> an internal .Net TCP socket connection will be used and manual feed of encoded sample data via <see cref="M:Un4seen.Bass.Misc.IStreamingServer.SendData(System.IntPtr,System.Int32)"/> is possible.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.IsConnected">
            <summary>
            Returns <see langword="true"/>, if connected to a streaming server - else <see langword="false"/>.
            </summary>
            <remarks>Normally it is sufficient to return <see langword="true"/> once a <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Connect"/> was successful.
            However, if the server implementation also requires a <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Login"/> this method should only return <see langword="true"/>, if also the <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Login"/> was successful.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.Encoder">
            <summary>
            Returns the encoder interface which is used with this instance.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.LastError">
            <summary>
            Gets or Sets the last streaming error.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage">
            <summary>
            Gets or Sets the last streaming error message.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.SongTitle">
            <summary>
            Gets or Sets the current/last song title.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.SongUrl">
            <summary>
            Gets or Sets the current/last song url.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IStreamingServer.ForceUTF8TitleUpdates">
            <summary>
            Gets or Sets if title updates (via <see cref="M:Un4seen.Bass.Misc.IStreamingServer.UpdateTitle(System.String,System.String)"/>) should in any case use UTF-8 (default is <see langword="false"/>).
            </summary>
            <remarks>
            Depending on the streaming server and stream format being used title updates might be performed using Windows-1252, Latin1 or UTF-8 encoding by default.
            When setting this property to <see langword="true"/> you can force title updates to be performed using UTF-8 encoding.
            <para>Note: Only set this property to <see langword="true"/> if you are sure, that the streaming server supports title updates in UTF-8!</para>
            <para>The default behaviour (when this property is set to <see langword="false"/>) is as followed:
            <list type="table">
            <listheader><term>Streaming Server</term><description>Title Updates in</description></listheader>
            <item><term>SHOUTcast</term><description>Windows-1252 codepage (Latin1)</description></item>
            <item><term>ICEcast</term><description><para>OGG streams: UTF-8</para><para>non-OGG streams: ISO-8859-1 (Latin1)</para></description></item>
            <item><term>WMAcast</term><description>UTF-8</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.Connect">
            <summary>
            Connects to a streaming server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect should only be successfull, if the underlying encoder was started.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.Disconnect">
            <summary>
            Disconnects to a streaming server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.Login">
            <summary>
            Performs a login and/or init of the streaming server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When the login was successfully made, you should set the <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> to <see cref="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Ok"/> and the <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> to String.Empty.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data (manually) to the streaming server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If an error occures the connection should be closed automatically (using <see cref="M:Un4seen.Bass.Misc.IStreamingServer.Disconnect"/>).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the title song and/or url of the streaming server.
            </summary>
            <param name="song">The title of the song which should be updated.</param>
            <param name="url">The url which should be updated along with the title (or <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.UpdateTitle(Un4seen.Bass.AddOn.Tags.TAG_INFO,System.String)">
            <summary>
            Updates the song title and/or url of the streaming server.
            </summary>
            <param name="tag">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance to use to update the song.</param>
            <param name="url">The url which should be updated along with the title (or <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.IStreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.IStreamingServer.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The string representing the XML formatted statistics (or <see langword="null"/> on error/not available).</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.StreamingServer">
            <summary>
            Base class for all streaming server classes (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>).
            </summary>
            <remarks>This base class is not intended for direct use, but defines all abstract properties and methods which needs to be implemented by an actual streaming server class.
            A derived class must implement: <see cref="P:Un4seen.Bass.Misc.StreamingServer.IsConnected"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/>, <see cref="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.Bass.Misc.StreamingServer.UpdateTitle(System.String,System.String)"/>.
            <para>The properties <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/>, <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> and <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> have been already implemented.</para>
            <para>You might use this base class to derive your own streaming server implementations.</para>
            <para>If an instance of a derived class is being disposed, an already created connection to a streaming server will automatically be closed (using <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>) and an <see cref="P:Un4seen.Bass.Misc.StreamingServer.Encoder"/> will be stopped, if active.</para>
            <para></para>
            </remarks>
            <example>
            This example shows a basic implementation of an own streaming server class:
            <code>
            public class MyOwnServer : StreamingServer
            {
            	// Constructor
            	public MyOwnServer(IBaseEncoder encoder, bool useBASS) : base(encoder, useBASS)
            	{
            	  // validity check
            	  if (encoder.EncoderType != BASSChannelType.BASS_CTYPE_STREAM_MP3 &amp;&amp;
            	      encoder.EncoderType != BASSChannelType.BASS_CTYPE_STREAM_AAC)
            	    throw new Exception( "Invalid EncoderType (only MP3 and AAC is supported)!" );
            	}
            	
            	private Socket _socket = null;
            	private bool _loggedIn = false;
            	private byte[] _data = null;
            	private object _lock = false;
            	public string ServerAddress = "localhost";
            	public int ServerPort = 8000;
            	
            	public override bool IsConnected
            	{
            	  get
            	  {
            	    if (_socket != null)
            	      return _socket.Connected &amp;&amp; _loggedIn;
            	    else
            	      return false;
            	  }
            	}
            	
            	public override bool Connect()
            	{
            	  // check the encoder
            	  if (!Encoder.IsActive)
            	  {
            	    LastError = STREAMINGERROR.Error_EncoderError;
            	    LastErrorMessage = "Encoder not active!";
            	    return false;
            	  }
            	  // close any connections, if still open
            	  if (_socket != null &amp;&amp; _socket.Connected)
            	  {
            	    _socket.Close();
            	    _socket = null;
            	  }
            	  // create a connection at port+1
            	  _socket = CreateSocket( ServerAddress, ServerPort+1 );
            	  return (_socket != null &amp;&amp; _socket.Connected);
            	}
            	
            	public override bool Disconnect()
            	{
            	  bool ok = false;
            	  try
            	  {
            	    _socket.Close();
            	  }
            	  catch { }
            	  finally
            	  {
            	    if (_socket != null &amp;&amp; _socket.Connected) 
            	    {
            	      LastError = STREAMINGERROR.Error_Disconnect;
            	      LastErrorMessage = "Winsock error: " + 
                        Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error());
            	    }
            	    else
            	    {
            	      ok = true;
            	      _socket = null;
            	      _loggedIn = false;
            	    }
            	  }
            	  return ok;
            	}
            	
            	public override bool Login()
            	{
            	  if (_socket == null)
            	  {
            	    LastError = STREAMINGERROR.Error_NotConnected;
            	    LastErrorMessage = "Not connected to server.";
            	    return false;
            	  }
            	  bool ok = false;
            	  if ( MyLogin() )
            	  {
            	    if ( MyInit() )
            	    {
            	      ok = true;
            	      _loggedIn = true;
            	      LastError = STREAMINGERROR.Ok;
            	      LastErrorMessage = String.Empty;
            	    }
            	    else
            	    {
            	      LastError = STREAMINGERROR.Error_Login;
            	      LastErrorMessage = "Server could not be initialized.";
            	    }
            	  }
            	  else
            	  {
            	    LastError = STREAMINGERROR.Error_Login;
            	    LastErrorMessage = "Invalid username or password.";
            	  }
            	  return ok;
            	}
            	
            	public override int SendData(IntPtr buffer, int length)
            	{
            	  if (buffer == IntPtr.Zero || length == 0)
            	    return 0;
            	  int sendData = -1;
            	  try
            	  {
            	    lock (_lock)
            	    {
            	      // dynamic buffer allocation
            	      if (_data == null || _data.Length &lt; length)
            	        _data = new byte[length];
            	      Marshal.Copy(buffer, _data, 0, length);
            	      sendData = _socket.Send( _data, 0, length, SocketFlags.None );
            	      if (sendData &lt; 0)
            	      {
            	        LastError = STREAMINGERROR.Error_SendingData;
            	        LastErrorMessage = String.Format( "{0} bytes not send.", length);
            	        Disconnect();
            	      }
            	      else if (sendData != length)
            	      {
            	        LastError = STREAMINGERROR.Warning_LessDataSend;
            	        LastErrorMessage = String.Format( "{0} of {1} bytes send.", sendData, length);
            	      }
            	    }
            	  }
            	  catch (Exception e)
            	  { 
            	    LastError = STREAMINGERROR.Error_SendingData;
            	    LastErrorMessage = e.Message;
            	    sendData = -1;
            	    Disconnect();
            	  }
            	  return sendData;
            	}
            	
            	public override bool UpdateTitle(string song, string url)
            	{
            	  SongTitle = song;
            	  return MyUpdateTitle(song);
            	}
            	
            	private Socket CreateSocket(string serveraddress, int port)
            	{
            	  Socket socket = null;
            	  IPHostEntry hostEntry = null;
            	  try
            	  {
            	    // Get host related information
            	    hostEntry = Dns.GetHostEntry(serveraddress);
            	    // Loop through the AddressList to obtain the supported AddressFamily.
            	    foreach(IPAddress address in hostEntry.AddressList)
            	    {
            	      try
            	      {
            	        IPEndPoint ipe = new IPEndPoint(address, port);
            	        Socket tempSocket = new Socket(ipe.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            	        tempSocket.Connect(ipe);
            	        if (tempSocket.Connected)
            	        {
            	          socket = tempSocket;
            	          break;
            	        }
            	        else
            	        {
            	          continue;
            	        }
            	      }
            	      catch (Exception e)
            	      { 
            	        LastError = STREAMINGERROR.Error_CreatingConnection;
            	        LastErrorMessage = e.Message;
            	        socket = null; 
            	      }
            	    }
            	  }
            	  catch (Exception e)
            	  { 
            	    LastError = STREAMINGERROR.Error_ResolvingServerAddress;
            	    LastErrorMessage = e.Message;
            	    socket = null;
            	  }
            	  return socket;
            	}
            	
            	private bool MyLogin() 
            	{
            	  if (_socket == null)
            	    return false;
            	  // e.g. send password here using the "_socket"
            	  ...
            	}
            	
            	private bool MyInit() 
            	{
            	  if (_socket == null)
            	    return false;
            	  // e.g. send some init data to the server here using the "_socket"
            	  ...
            	}
            	
            	private bool MyUpdateTitle(string song)
            	{
            	  bool ok = false;
            	  Socket socket = null;
            	  try
            	  {
            	    socket = CreateSocket( ServerAddress, ServerPort );
            	    if (socket != null)
            	    {
            	      // send the song title using the created "socket"
            	      ...
            	      ok = true;
            	    }
            	  }
            	  catch { }
            	  finally
            	  {
            	    // disconnect
            	    if (socket != null)
            	    {
            	      socket.Close();
            	      socket = null;
            	    }
            	  }
            	  return ok;
            	}
            }
            </code>
            <code lang="vbnet">
            Public Class MyOwnServer Inherits StreamingServer
            
                ' Constructor
                Public Sub New(encoder As IBaseEncoder, useBASS As Boolean) MyBase.New(encoder, useBASS)
                  ' validity check
                  If encoder.EncoderType &lt;&gt; BASSChannelType.BASS_CTYPE_STREAM_MP3 AndAlso 
                     encoder.EncoderType &lt;&gt; BASSChannelType.BASS_CTYPE_STREAM_AAC Then
                     Throw New Exception("Invalid EncoderType (only MP3 and AAC is supported)!")
                  End If
                End Sub
            
                Private _socket As Socket = Nothing
                Private _loggedIn As Boolean = False
                Private _data As Byte() = Nothing
                Private _lock As Object = False
                Public ServerAddress As String = "localhost"
                Public ServerPort As Integer = 8000
            
                Public Overrides ReadOnly Property IsConnected() As Boolean
                  Get
                    If Not (_socket Is Nothing) Then
                      Return _socket.Connected AndAlso _loggedIn
                    Else
                      Return False
                    End If
                  End Get
                End Property
            
                Public Overrides Function Connect() As Boolean
                  ' check the encoder
                  If Not Encoder.IsActive Then
                    LastError = STREAMINGERROR.Error_EncoderError
                    LastErrorMessage = "Encoder not active!"
                    Return False
                  End If
                  ' close any connections, if still open
                  If Not (_socket Is Nothing) AndAlso _socket.Connected Then
                    _socket.Close()
                    _socket = Nothing
                  End If
                  ' create a connection at port+1
                  _socket = CreateSocket(ServerAddress, ServerPort + 1)
                  Return Not (_socket Is Nothing) AndAlso _socket.Connected
                End Function
            
                Public Overrides Function Disconnect() As Boolean
                  Dim ok As Boolean = False
                  Try
                    _socket.Close()
                  Catch
                  Finally
                    If Not (_socket Is Nothing) AndAlso _socket.Connected Then
                      LastError = STREAMINGERROR.Error_Disconnect
                      LastErrorMessage = "Winsock error: " + 
                                         Convert.ToString(System.Runtime.InteropServices.Marshal.GetLastWin32Error())
                    Else
                      ok = True
                      _socket = Nothing
                      _loggedIn = False
                    End If
                  End Try
                  Return ok
                End Function
            
                Public Overrides Function Login() As Boolean
                  If _socket Is Nothing Then
                    LastError = STREAMINGERROR.Error_NotConnected
                    LastErrorMessage = "Not connected to server."
                    Return False
                  End If
                  Dim ok As Boolean = False
                  If MyLogin() Then
                    If MyInit() Then
                      ok = True
                      _loggedIn = True
                      LastError = STREAMINGERROR.Ok
                      LastErrorMessage = [String].Empty
                    Else
                      LastError = STREAMINGERROR.Error_Login
                      LastErrorMessage = "Server could not be initialized."
                    End If
                  Else
                    LastError = STREAMINGERROR.Error_Login
                    LastErrorMessage = "Invalid username or password."
                  End If
                  Return ok
                End Function
            
                Public Overrides Function SendData(buffer As IntPtr, length As Integer) As Integer
                  If buffer = IntPtr.Zero OrElse length = 0 Then
                    Return 0
                  End If
                  Dim sendData As Integer = -1
                  Try
                    SyncLock _lock
                    ' dynamic buffer allocation
                    If _data Is Nothing OrElse _data.Length &lt; length Then
                      _data = New Byte(length) {}
                    End If
                    Marshal.Copy(buffer, _data, 0, length)
                    sendData = _socket.Send(_data, 0, length, SocketFlags.None)
                    If sendData &lt; 0 Then
                      LastError = STREAMINGERROR.Error_SendingData
                      LastErrorMessage = [String].Format("{0} bytes not send.", length)
                      Disconnect()
                    Else
                      If sendData &lt;&gt; length Then
                        LastError = STREAMINGERROR.Warning_LessDataSend
                        LastErrorMessage = [String].Format("{0} of {1} bytes send.", sendData, length)
                      End If
                    End If
                  End SyncLock
                  Catch e As Exception
                    LastError = STREAMINGERROR.Error_SendingData
                    LastErrorMessage = e.Message
                    sendData = -1
                    Disconnect()
                  End Try
                  Return sendData
                End Function
            
                Public Overrides Function UpdateTitle(song As String) As Boolean
                  SongTitle = song
                  Return MyUpdateTitle(song)
                End Function
            
                Private Function CreateSocket(serveraddress As String, port As Integer) As Socket
                  Dim socket As Socket = Nothing
                  Dim hostEntry As IPHostEntry = Nothing
                  Try
                    ' Get host related information
                    hostEntry = Dns.GetHostEntry(serveraddress)
                    ' Loop through the AddressList to obtain the supported AddressFamily.
                    Dim address As IPAddress
                    For Each address In hostEntry.AddressList
                      Try
                        Dim ipe As New IPEndPoint(address, port)
                        Dim tempSocket As New Socket(ipe.AddressFamily, SocketType.Stream, ProtocolType.Tcp)
                        tempSocket.Connect(ipe)
                        If tempSocket.Connected Then
                          socket = tempSocket
                          Exit ForEach
                        Else
                          GoTo ContinueForEach1
                        End If
                      Catch e As Exception
                        LastError = STREAMINGERROR.Error_CreatingConnection
                        LastErrorMessage = e.Message
                        socket = Nothing
                      End Try
                      ContinueForEach1:
                    Next address
                  Catch e As Exception
                    LastError = STREAMINGERROR.Error_ResolvingServerAddress
                    LastErrorMessage = e.Message
                    socket = Nothing
                  End Try
                  Return socket
                End Function
            
                Private Function MyLogin() As Boolean
                  If _socket Is Nothing Then
                    Return False
                  End If 
                  ' e.g. send password here using the "_socket"
                  ...
                End Function
            
                Private Function MyInit() As Boolean
                  If _socket Is Nothing Then
                    Return False
                  End If 
                  ' e.g. send some init data to the server here using the "_socket"
                  ...
                End Function
            
                Private Function MyUpdateTitle(song As String) As Boolean
                  Dim ok As Boolean = False
                  Dim socket As Socket = Nothing
                  Try
                    socket = CreateSocket(ServerAddress, ServerPort)
                    If Not (socket Is Nothing) Then
                      ' send the song title using the created "socket"
                      ...
                      ok = True
                    End If
                  Catch
                  Finally
                    ' disconnect
                    If Not (socket Is Nothing) Then
                      socket.Close()
                      socket = Nothing
                    End If
                  End Try
                  Return ok
                End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Default constructor, creating an instance for a streaming server implementation (using BASSenc as the default processor).
            </summary>
            <param name="encoder">The encoder interface which should be used with this streaming server.</param>
            <remarks>This overload will set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to <see langword="true"/>.</remarks>
            <exception cref="T:System.ArgumentNullException">No <paramref name="encoder"/> specified.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="encoder"/> could not be found. Make sure the encoder (.exe) is present.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.#ctor(Un4seen.Bass.Misc.IBaseEncoder,System.Boolean)">
            <summary>
            Default constructor, creating an instance for a streaming server implementation.
            </summary>
            <param name="encoder">The encoder interface which should be used with this streaming server.</param>
            <param name="useBASS"><see langword="true"/>, if BASSenc should be used to handle all cast server handling. <see langword="false"/>, if the internal implementation should be used.</param>
            <exception cref="T:System.ArgumentNullException">No <paramref name="encoder"/> specified.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="encoder"/> could not be found. Make sure the encoder (.exe) is present.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.GetIPfromHost(System.String)">
            <summary>
            Resolved a given host name (DNS or IP) to its possible IP addesses.
            </summary>
            <param name="hostname">The host name to resolve.</param>
            <returns>A list of IP addresses that are associated with a host - or <see langword="null"/> on error.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.UseBASS">
            <summary>
            Gets if native BASSenc should be used to connect and stream to the server (as specified in the constructor).
            </summary>
            <remarks>
            <para>If set to <see langword="true"/> native BASSenc will handle all TCP socket and cast communication.
            This should be the more secure and preferred option, however in this mode it is not possible to use the <see cref="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)"/> method manually!</para>
            <para>If set to <see langword="false"/> an internal .Net TCP socket connection will be used and manual feed of encoded sample data via <see cref="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)"/> is possible.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.SongTitle">
            <summary>
            The current/last song title.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.SongUrl">
            <summary>
            The current/last song url.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.ForceUTF8TitleUpdates">
            <summary>
            Gets or Sets if title updates (via <see cref="M:Un4seen.Bass.Misc.StreamingServer.UpdateTitle(System.String,System.String)"/>) should in any case use UTF-8 (default is <see langword="false"/>).
            </summary>
            <remarks>
            Depending on the streaming server and stream format being used title updates might be performed using Windows-1252, Latin1 or UTF-8 encoding by default.
            When setting this property to <see langword="true"/> you can force title updates to be performed using UTF-8 encoding.
            <para>Note: Only set this property to <see langword="true"/> if you are sure, that the streaming server supports title updates in UTF-8!</para>
            <para>The default behaviour (when this property is set to <see langword="false"/>) is as followed:
            <list type="table">
            <listheader><term>Streaming Server</term><description>Title Updates in</description></listheader>
            <item><term>SHOUTcast</term><description>Windows-1252 codepage (Latin1)</description></item>
            <item><term>ICEcast</term><description><para>OGG streams: UTF-8</para><para>non-OGG streams: ISO-8859-1 (Latin1)</para></description></item>
            <item><term>WMAcast</term><description>UTF-8</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.IsConnected">
            <summary>
            Returns <see langword="true"/>, if connected to a boadcast server - else <see langword="false"/>.
            </summary>
            <remarks>Normally it is sufficient to return <see langword="true"/> once a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Connect"/> was successful.
            However, if the server implementation also requires a <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/> this method should only return <see langword="true"/>, if also the <see cref="M:Un4seen.Bass.Misc.StreamingServer.Login"/> was successful.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.Encoder">
            <summary>
            Returns the encoder interface which is used with this instance.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.LastError">
            <summary>
            Gets or Sets the last streaming error.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage">
            <summary>
            Gets or Sets the last streaming error message.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Connect">
            <summary>
            Connects to a streaming server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Disconnect">
            <summary>
            Disconnects from a streaming server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect should only be successfull, if the underlying encoder was started.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.Login">
            <summary>
            Performs a login to and/or initializes the streaming server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If a server doesn't not need to handle a particular login or initialization, you might simply return <see langword="true"/> in the implementation.
            However, when the login was successfully made, you should set the <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> to <see cref="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Ok"/> and the <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> to String.Empty.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data (manually) to the streaming server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.StreamingServer.Disconnect"/>).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The song title to use.</param>
            <param name="url">The url which should be updated along with the title (or <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.UpdateTitle(Un4seen.Bass.AddOn.Tags.TAG_INFO,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="tag">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance to use to update the song title.</param>
            <param name="url">The url which should be updated along with the title (or <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.StreamingServer.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The string representing the XML formatted statistics (or <see langword="null"/> on error/not available).</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR">
            <summary>
            List of all possible streaming errors.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Ok">
            <summary>
            All OK.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_ResolvingServerAddress">
            <summary>
            The server address could not be resolved (DNS error).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_CreatingConnection">
            <summary>
            A TCP socket connection to the server could not be established (TCP error).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_SendingData">
            <summary>
            The data could not be send to the server (TCP error).
            <para>The server will automatically be disconnected.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_EncoderError">
            <summary>
            The encoder could not be started or is inactive.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_Login">
            <summary>
            Access was denied (check username and password).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_Disconnect">
            <summary>
            An error occurred during a disconnect (disconnect failed, still connected).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Error_NotConnected">
            <summary>
            A connection to the server was not established.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Warning_LessDataSend">
            <summary>
            Not all data could not be send to the server (less data send).
            <para>The server will automatically be disconnected.</para>
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.StreamingServer.STREAMINGERROR.Unknown">
            <summary>
            An unknown error occurred.
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.SHOUTcast">
            <summary>
            SHOUTcast streaming parameter class.
            To be used when creating an instance of the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>An instance of the class will providing all necessary setup and configuration data in order to connect to a SHOUTcast v1 or v2 server.
            <para>For more information about the SHOUTcast streaming parameters take a look to the <a href="http://www.shoutcast.com">www.shoutcast.com</a> documentation.</para>
            <para>Note: in order to use the SHOUTcast v2 protocol the <see cref="F:Un4seen.Bass.Misc.SHOUTcast.SID"/> property must be set!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Creates an instance for a SHOUTcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for SHOUTcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="!:EncoderLAME"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - you might use the 'enc_aacPlus.exe' (see <see cref="!:EncoderWinampAACplus"/>) or 'fhgaacenc.exe' (see <see cref="!:EncoderFHGAACplus"/>) with it.</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.SHOUTcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only MP3 and AAC is supported)!</exception>
            <example>
            Creates a SHOUTcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the SHOUTcast instance using LAME
            SHOUTcast shoutcast = new SHOUTcast(lame);
            shoutcast.ServerAddress = "http://serveraddress.com";
            shoutcast.ServerPort = 8000;
            shoutcast.Password = "password";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the SHOUTcast instance using LAME
            Dim shoutcast As New SHOUTcast(lame)
            shoutcast.ServerAddress = "http://serveraddress.com"
            shoutcast.ServerPort = 8000
            shoutcast.Password = "password"
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder,System.Boolean)">
            <summary>
            Creates an instance for a SHOUTcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <param name="useBASS"><see langword="true"/>, if BASSenc should be used to handle all cast server handling. <see langword="false"/>, if the internal implementation should be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for SHOUTcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="!:EncoderLAME"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - you might use the 'enc_aacPlus.exe' (see <see cref="!:EncoderWinampAACplus"/>) or 'fhgaacenc.exe' (see <see cref="!:EncoderFHGAACplus"/>) with it.</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.SHOUTcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only MP3 and AAC is supported)!</exception>
            <example>
            Creates a SHOUTcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the SHOUTcast instance using LAME
            SHOUTcast shoutcast = new SHOUTcast(lame, true);
            shoutcast.ServerAddress = "http://serveraddress.com";
            shoutcast.ServerPort = 8000;
            shoutcast.Password = "password";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the SHOUTcast instance using LAME
            Dim shoutcast As New SHOUTcast(lame, True)
            shoutcast.ServerAddress = "http://serveraddress.com"
            shoutcast.ServerPort = 8000
            shoutcast.Password = "password"
            ...
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.ServerAddress">
            <summary>
            SHOUTcast server address (of the form 192.168.1.100 or shoutcast-server.domain.com).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.ServerPort">
            <summary>
            SHOUTcast server TCP port (usually 8000).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.SID">
            <summary>
            SHOUTcast v2 SID.
            </summary>
            <remarks>This property determines if the SHOUTcast v1 or v2 protocol is used!
            If this property is set (not an empty string) the SHOUTcast v2 protocol is used - else the SHOUTcast v1 protocol is used!
            By default this property is empty (and the SHOUTcast v1 protocol is used).
            <para>Note:
            The SHOUTcast v2 protocol can ONLY be used, if the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property is set to <see langword="true"/> -
            else this property is ignored and the SHOUTcast v1 protocol is used!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.SHOUTcast.UseSHOUTcastv2">
            <summary>
            Gets or sets, if the SHOUTcast v2 protocol should be used?
            </summary>
            <remarks>The SHOUTcast v2 protocol is used, if the <see cref="F:Un4seen.Bass.Misc.SHOUTcast.SID"/> property is set (not empty) and the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property is set to <see langword="true"/>!
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.v2SendSongTitleOnly">
            <summary>
            Should SHOUTcast v2 metadata updates only use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> value?
            </summary>
            <remarks>Only applies to the SHOUTcast v2 protocol.
            Only used with the <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/> overload taking a <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> parameter.
            <para>If this property is set to <see langword="true"/> only the 'TIT2' metadata tag is send to the server using the current <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> value.
            Else (default) the full <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> members are evaluated and the <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> value is ignorred.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.v2SendArtwork">
            <summary>
            Should in-stream artwork be send to a SHOUTcast v2 server?
            </summary>
            <remarks>Only applies to the SHOUTcast v2 protocol. Only images up to 511KB will be send. 
            Only used with the <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/> overload taking a <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> parameter.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.v2StreamArtwork">
            <summary>
            Fully qualified path and file name of an alternative artwork picture.
            </summary>
            <remarks>
            <para>Allows you to specify an alternative stream/brand artwork to use, if the playling file doesn't contain one.</para>
            <para>Only applies to the SHOUTcast v2 protocol and the <see cref="F:Un4seen.Bass.Misc.SHOUTcast.v2SendArtwork"/> property is set to <see langword="true"/>.
            Only images up to 511KB will be send. 
            Only used with the <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/> overload taking a <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> parameter.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.v2StationArtwork">
            <summary>
            Fully qualified path and file name of the station logo picture.
            </summary>
            <remarks>
            <para>Allows you to specify a station logo picture to use.</para>
            <para>Only applies to the SHOUTcast v2 protocol and the <see cref="F:Un4seen.Bass.Misc.SHOUTcast.v2SendArtwork"/> property is set to <see langword="true"/>.
            Only images up to 511KB will be send.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.v2SongTitleNext">
            <summary>
            The next song title ('artist - title') to report within the SHOUTcast v2 metadata.
            </summary>
            <remarks>
            <para>Allows you to specify an 'extension'-'soon' block within the v2 metadata. If empty no 'soon' block (next, upcomming song title) will be reported. Must be specified before a call to <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/>.</para>
            <para>Only applies to the SHOUTcast v2 protocol.</para>
            <para>Note: This property will be cleared after each <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/> call and needs to be set again prior to it.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Username">
            <summary>
            SHOUTcast server broadcast user name (the "source" username which should be used).
            </summary>
            <remarks>If empty (default), the default "source" username is used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Password">
            <summary>
            SHOUTcast server broadcast password (the "Password" config item on the server's config file).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.SHOUTcast.AdminUsername">
            <summary>
            SHOUTcast server admin user name (the "admin" username which should be used for certain actions).
            </summary>
            <remarks>If empty (default), the "admin" username is used.
            <para>This property is evaluated in the following methods: <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/>, <see cref="M:Un4seen.Bass.Misc.SHOUTcast.GetListeners(System.String)"/> and <see cref="M:Un4seen.Bass.Misc.SHOUTcast.GetStats(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.SHOUTcast.AdminPassword">
            <summary>
            SHOUTcast server admin password (the "AdminPassword" config item on the server's config file).
            </summary>
            <remarks>If empty (default), the <see cref="F:Un4seen.Bass.Misc.SHOUTcast.Password"/> is used.
            <para>This property is evaluated in the following methods: <see cref="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)"/>, <see cref="M:Un4seen.Bass.Misc.SHOUTcast.GetListeners(System.String)"/> and <see cref="M:Un4seen.Bass.Misc.SHOUTcast.GetStats(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.StationName">
            <summary>
            A brief description of your station or of what content you'll be broadcasting (usually 10-20 words).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Genre">
            <summary>
            A genre list of the variety of content you're providing (usually 1-3 words like Rock, 80s, etc.)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.PublicFlag">
            <summary>
            <see langword="true"/>, if you want your broadcast to be listed in the public directory of SHOUTcast broadcasts (default).
            Else <see langword="false"/>, which means private.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Url">
            <summary>
            A URL of a website that contains information about your broadcast.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Irc">
            <summary>
            A channel on Efnet IRC for your listeners to interact with (don't worry if you don't understand this).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Icq">
            <summary>
            If you have one, your ICQ number for listeners to interact with you through. (www.icq.com)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.SHOUTcast.Aim">
            <summary>
            Your AOL Instant Messenger (AIM) name for listeners to interact with you. (aim.aol.com)
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.SHOUTcast.IsConnected">
            <summary>
            Returns <see langword="true"/>, if connected and logged into the SHOUTcast server - else <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.Connect">
            <summary>
            Establishes a TCP socket connection to the SHOUTcast server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect will only be successfull, if the underlying <see cref="T:System.Text.Encoder"/> was started and is active.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.Disconnect">
            <summary>
            Disconnects from a SHOUTcast server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Disconnecting from the server will also STOP the underlying encoder by calling the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.Login">
            <summary>
            Performs a login and initializes the SHOUTcast server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="true"/>, nothing will happen here and <see langword="true"/> is returned in any case.
            So this method is only effective, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data to the SHOUTcast server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>NOTE: Only possible, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>.
            <para>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.SHOUTcast.Disconnect"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The new song title to use.</param>
            <param name="url">The url which should be updated along with the title (or <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="true"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)"/> will be used internally -
            else an internal implementation will be used.
            <para>Calling this method also sets the <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> property accordingly.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.UpdateTitle(Un4seen.Bass.AddOn.Tags.TAG_INFO,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="tag">The <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance to use to set the new song title.</param>
            <param name="url">The url which should be updated along with the title (or <see langword="null"/>).</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="true"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)"/> will be used internally -
            else an internal implementation will be used.
            <para>Calling this method does NOT sets the <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> property - but will use it in case of <see cref="P:Un4seen.Bass.Misc.SHOUTcast.UseSHOUTcastv2"/>=<see langword="true"/> as the TIT2 metadata value (see <see cref="F:Un4seen.Bass.Misc.SHOUTcast.v2SendSongTitleOnly"/>)!
            If the <see cref="P:Un4seen.Bass.Misc.StreamingServer.SongTitle"/> property is <see langword="null"/> or empty the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> data will be used instead.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.UpdateStationArtwork(System.String)">
            <summary>
            Updates the station logo picture of the streaming server.
            </summary>
            <param name="stationArtwork">The fully qualified path and file name of the station logo picture to use.</param>
            <remarks>The <see cref="F:Un4seen.Bass.Misc.SHOUTcast.v2StationArtwork"/> property will be updated accordingly and the new station logo will be send to the SHOUTcastv2 server (if connected).
            <para>Only applies to the SHOUTcast v2 protocol and the <see cref="F:Un4seen.Bass.Misc.SHOUTcast.v2SendArtwork"/> property must be set to <see langword="true"/>.
            Only images up to 511KB will be send.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.SHOUTcast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The string representing the XML formatted statistics (or <see langword="null"/> on error/not available).</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.ICEcast">
            <summary>
            ICEcast streaming parameter class.
            To be used when creating an instance of the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.
            </summary>
            <remarks>An instance of the class will providing all necessary setup and configuration data in order to connect to an ICEcast server.
            <para>For more information about the ICEcast streaming parameters take a look to the <a href="http://www.icecast.org">www.icecast.org</a> documentation.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder)">
            <summary>
            Creates an instance for an ICEcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for ICEcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="!:EncoderLAME"/>). For OGG streaming we recommend using the latest stable version of oggenc2 (see <see cref="!:EncoderOGG"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - you might use the 'enc_aacPlus.exe' (see <see cref="!:EncoderWinampAACplus"/>) or 'fhgaacenc.exe' (see <see cref="!:EncoderFHGAACplus"/>) with it.</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.ICEcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only OGG, MP3, AAC or FLAC_OGG is supported)!</exception>
            <example>
            Creates an ICEcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the ICEcast instance using LAME
            ICEcast icecast = new ICEcast(lame);
            icecast.ServerAddress = "http://serveraddress.com";
            icecast.ServerPort = 8000;
            icecast.Password = "password";
            icecast.Mountpoint = "/mystream";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the ICEcast instance using LAME
            Dim icecast As New ICEcast(lame)
            icecast.ServerAddress = "http://serveraddress.com"
            icecast.ServerPort = 8000
            icecast.Password = "password"
            icecast.Mountpoint = "/mystream"
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.#ctor(Un4seen.Bass.Misc.IBaseEncoder,System.Boolean)">
            <summary>
            Creates an instance for an ICEcast configuration parameter setting.
            </summary>
            <param name="encoder">The output encoder instance to be used.</param>
            <param name="useBASS"><see langword="true"/>, if BASSenc should be used to handle all cast server handling. <see langword="false"/>, if the internal implementation should be used.</param>
            <remarks>An instance of this class is needed in order to create a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> instance.
            <para>Please note, that you need an appropriate encoder for ICEcast streaming. For MP3 streaming we recommend using the latest stable version of LAME (see <see cref="!:EncoderLAME"/>). For OGG streaming we recommend using the latest stable version of oggenc2 (see <see cref="!:EncoderOGG"/>).</para>
            <para>When streaming in AACplus format an external encoder is needed as well, which accepts pcm data from STDIN and is able to send it's encoded data to STDOUT.
            As of today the only 'free' AACplus encoders comes with Winamp - you might use the 'enc_aacPlus.exe' (see <see cref="!:EncoderWinampAACplus"/>) or 'fhgaacenc.exe' (see <see cref="!:EncoderFHGAACplus"/>) with it.</para>
            <para>Also take care of all neccessary patent and license issues when streaming or broadcasting!</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> property to decide, whether you want to use the BASS build-in streaming support (default) or if you want to use the BASS.NET internal implementation.
            The major difference is, that the BASS.NET implementation allows you to use <see cref="M:Un4seen.Bass.Misc.ICEcast.SendData(System.IntPtr,System.Int32)"/> manually.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid EncoderType (only OGG, MP3 and AAC is supported)!</exception>
            <example>
            Creates an ICEcast configuration instance.
            <code>
            // create an encoder instance
            EncoderLAME lame = new EncoderLAME(_recHandle);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_56;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono;
            lame.LAME_TargetSampleRate = (int)EncoderLAME.SAMPLERATE.Hz_22050;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            
            // now create the ICEcast instance using LAME
            ICEcast icecast = new ICEcast(lame, true);
            icecast.ServerAddress = "http://serveraddress.com";
            icecast.ServerPort = 8000;
            icecast.Password = "password";
            icecast.Mountpoint = "/mystream";
            ...
            </code>
            <code lang="vbnet">
            ' create an encoder instance
            Dim lame As New EncoderLAME(_recHandle)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_56)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Mono
            lame.LAME_TargetSampleRate = CInt(EncoderLAME.SAMPLERATE.Hz_22050)
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            
            ' now create the ICEcast instance using LAME
            Dim icecast As New ICEcast(lame, True)
            icecast.ServerAddress = "http://serveraddress.com"
            icecast.ServerPort = 8000
            icecast.Password = "password"
            icecast.Mountpoint = "/mystream"
            ...
            </code>
            </example>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.ServerAddress">
            <summary>
            ICEcast server address (hostname, in the form 192.168.1.100 or icecast-server.domain.com).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.ServerPort">
            <summary>
            ICEcast server TCP port (usually 8000).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.MountPoint">
            <summary>
            The ICEcast mountpoint you want to use.
            </summary>
            <remarks>All Ogg Vorbis streams should have mountpoints that end in .ogg (i.e. "/mystream.ogg"). 
            This is due to the lazy way most media players infer the type of stream. 
            MP3 streams usually do not contain an extension (e.g. "/mystream"). 
            Mount points also should not contain any spaces or odd characters (again due to the lazy way many of the media players are coded) and MUST start with a slash ('/')!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.Username">
            <summary>
            ICEcast server user name (the "source" username which should be used).
            </summary>
            <remarks>If empty (default), the default "source" username is used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.Password">
            <summary>
            ICEcast server broadcast password (the "source-password" config item on the server's config file).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.ICEcast.AdminUsername">
            <summary>
            ICEcast server admin user name (the "admin-user" which should be used for certain actions).
            </summary>
            <remarks>If empty (default), the <see cref="F:Un4seen.Bass.Misc.ICEcast.Username"/> is used (and if that is empty too, the "admin" username is used).
            <para>This property is evaluated in the following methods: <see cref="M:Un4seen.Bass.Misc.ICEcast.UpdateTitle(System.String,System.String)"/>, <see cref="M:Un4seen.Bass.Misc.ICEcast.GetListeners(System.String)"/> and <see cref="M:Un4seen.Bass.Misc.ICEcast.GetStats(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.ICEcast.AdminPassword">
            <summary>
            ICEcast server admin password (the "admin-password" which should be used for certain actions).
            </summary>
            <remarks>If empty (default), the <see cref="F:Un4seen.Bass.Misc.ICEcast.Password"/> is used.
            <para>This property is evaluated in the following methods: <see cref="M:Un4seen.Bass.Misc.ICEcast.UpdateTitle(System.String,System.String)"/>, <see cref="M:Un4seen.Bass.Misc.ICEcast.GetListeners(System.String)"/> and <see cref="M:Un4seen.Bass.Misc.ICEcast.GetStats(System.String)"/>.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamName">
            <summary>
            The name of your stream or station (usually 1-5 words).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamDescription">
            <summary>
            A description of your stream or station or of what content you'll be broadcasting (usually 10-20 words).
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamUrl">
            <summary>
            A URL of a website that contains information about your broadcast.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.StreamGenre">
            <summary>
            A genre list of the variety of content you're providing (usually 1-3 words like Rock, 80s, etc.)
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.PublicFlag">
            <summary>
            <see langword="true"/>, if you want your broadcast to be listed in the public directory of ICEcast broadcasts (default).
            Else <see langword="false"/>, which means private.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.ICEcast.Quality">
            <summary>
            The bitrate quality name (e.g. "Quality").
            </summary>
            <remarks>Set to <see langword="null"/> (default), if you want to use the effective bitrate (in kbps) of the encoder instead.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.ICEcast.IsConnected">
            <summary>
            Returns <see langword="true"/>, if connected and logged into the ICEcast server - else <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.Connect">
            <summary>
            Establishes a TCP socket connection to the ICEcast server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>A server connect will only be successfull, if the underlying <see cref="T:System.Text.Encoder"/> was started and is active.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.Disconnect">
            <summary>
            Disconnects from an ICEcast server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>Disconnecting from the server will also STOP the underlying encoder by calling the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.Login">
            <summary>
            Performs a login and initializes the ICEcast server.
            </summary>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>If <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="true"/>, nothing will happen here and <see langword="true"/> is returned in any case.
            So this method is only effective, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.SendData(System.IntPtr,System.Int32)">
            <summary>
            Sends encoded sample data to the ICEcast server (e.g. the data as received in an own <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/>).
            </summary>
            <param name="buffer">The pointer to the encoded buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <param name="length">The length of the buffer data (as given by to <see cref="T:Un4seen.Bass.AddOn.Enc.ENCODEPROC"/> callback).</param>
            <returns>The number of bytes send to the server (or -1, if no bytes could be send (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>NOTE: Only possible, if <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="false"/>.
            <para>If an error occures the connection will be closed automatically (using <see cref="M:Un4seen.Bass.Misc.ICEcast.Disconnect"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.UpdateTitle(System.String,System.String)">
            <summary>
            Updates the song title of the streaming server.
            </summary>
            <param name="song">The new song title to use.</param>
            <param name="url"><see langword="null"/> - not supported for ICEcast.</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>When <see cref="P:Un4seen.Bass.Misc.StreamingServer.UseBASS"/> is set to <see langword="true"/>, <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_CastSetTitle(System.Int32,System.String,System.String)"/> will be used internally -
            else an internal implementation will be used.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.UpdateArtistTitle(System.String,System.String)">
            <summary>
            Updates the artist and title of the streaming server.
            </summary>
            <param name="artist">The new artist name to use.</param>
            <param name="title">The new title name to use.</param>
            <returns><see langword="true"/> on success, else <see langword="false"/> (see <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastError"/> or <see cref="P:Un4seen.Bass.Misc.StreamingServer.LastErrorMessage"/> for details).</returns>
            <remarks>An internal implementation will be used to set the artist and title.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.GetListeners(System.String)">
            <summary>
            Returns the number of listeners currently connected.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The current number of listeners (or -1 if not available).</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.ICEcast.GetStats(System.String)">
            <summary>
            Returns the XML stats of the server.
            </summary>
            <param name="password">The optional admin password to use (<see langword="null"/>=use default).</param>
            <returns>The string representing the XML formatted statistics (or <see langword="null"/> on error/not available).</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.IBaseEncoder">
            <summary>
            Defines a generalized encoder class interface that a <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> class must implement.
            </summary>
            <remarks>This interface is for example used in the constructor of a streaming server parameter class (e.g. <see cref="T:Un4seen.Bass.Misc.SHOUTcast"/> or <see cref="T:Un4seen.Bass.Misc.ICEcast"/>) 
            to specify which encoder settings should be used.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelHandle">
            <summary>
            This property should get or sets the channel handle which will be used to create the broadcast encoder class.
            </summary>
            <remarks>Only set this member to a new channel, if the encoder is not active (otherwise the channel will not be changed)!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelBitwidth">
            <summary>
            This property should return the actual bitwidth of the sample data BASS is using with the channel (e.g. 8, 16, 32).
            </summary>
            <remarks>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            This bitwidth represents the bitwidth which is used by BASS (e.g. in a DSP callback delegate) and does not represent the original bitwidth of the stream.
            The bitwidth used by BASS is determined how the underlying channel handle was created (e.g. using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag)
            and if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> option has been set.
            If non of the above was used, by default 16 bits per sample are used.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelSampleRate">
            <summary>
            This property should return the actual sample rate in Hz of the sample data BASS is using with the channel (e.g. 44100).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.ChannelNumChans">
            <summary>
            This property should return the actual number of channles of the sample data BASS is using with the channel (e.g. 1=mono, 2=stereo, etc.).
            </summary>
            <remarks>BASS supports multi-channel sample data, so make sure the actual encoder implementation supports multi-channel too.
            If the encoder does not support multi-channel make sure that you are using non-multi-channel hanles only.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderType">
            <summary>
            This property should return a value indicating which type of content the broadcast encoder implements.
            </summary>
            <remarks>For example: If the implementation of the broadcast encoder implements an MP3 encoder, you should return BASS_CTYPE_STREAM_MP3.
            For a complete list see <see cref="T:Un4seen.Bass.BASSChannelType"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.DefaultOutputExtension">
            <summary>
            This property should return the default extension of an output file for this encoder (e.g. ".mp3" or ".ogg" etc.).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.SupportsSTDOUT">
            <summary>
            This property should return <see langword="true"/>, if the base encoder implementation (resp. the underlying command-line tool being used) support STDOUT for output of the encoded data - else <see langword="false"/> must be returned.
            </summary>
            <remarks>In order to support broadcast streaming with an encoder command-line tool,
            the encoded data needs to be received back by a callback function, so the encoder needs to be told to output to STDOUT (instead of a file).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle">
            <summary>
            This property should get and set a HENCODE encoder handle as returned by the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> method if the the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) or 0 (zero), if the encoder has not been started or was stopped (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Stop"/>).
            </summary>
            <remarks>Take note of the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.IsActive"/> member, which might need to use the the encoder handle in order to retrieve the encoder state.
            <para>If the encoder is not started or not started successfully (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) or is stopped this property must return 0 (zero)!</para>
            <para>If the encoder is started and is active this property must return the valid HENCODE handle (non-zero)!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.IsActive">
            <summary>
            This property should return <see langword="true"/>, if the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) and is active - else <see langword="false"/> must be returned.
            </summary>
            <remarks>An implementation should first get the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the implementation might use the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method in order to check it's state.
            If the state is not BASS_ACTIVE_STOPPED this property should return <see langword="true"/>.
            In all other cases this property should return <see langword="false"/> (not started, paused, stopped etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.IsPaused">
            <summary>
            This property should return <see langword="true"/>, only if the encoder has been paused (see <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Pause(System.Boolean)"/>) - else <see langword="false"/> must be returned.
            </summary>
            <remarks>An implementation should first get the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the implementation might use the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method in order to check it's state.
            Only if the state is BASS_ACTIVE_PAUSED this property should return <see langword="true"/>.
            In all other cases this property should return <see langword="false"/> (not started, active, playing etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine">
            <summary>
            This property should return an encoder command-line string, 
            which might be used with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> method in order to create and start the encoder.
            </summary>
            <remarks>Make sure, that the encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.OutputFile"/> members correctly.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderDirectory">
            <summary>
            This property should get and set the encoder's base directory.
            It might be used in the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> implementation to return a fully qualified encoder command-line.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderExists">
            <summary>
            This property should return <see langword="true"/>, if the encoder exists and is available - else <see langword="false"/> should be returned.
            </summary>
            <remarks>When using a command-line encoder this method might check, if the executable file exists in the specified <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderDirectory"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.InputFile">
            <summary>
            Specifies the input file name to be processed by the encoder (null = STDIN).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> property.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.Force16Bit">
            <summary>
            Gets or Sets if a encoding in 16-bit sample data should be forced (default is <see langword="false"/>).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> property.
            <para>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use this flags to have the sample data converted to 16 bit integer data before it's passed on to the encoder.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.NoLimit">
            <summary>
            Gets or Sets if encoding should use the CAST_NOLIMIT flag (which is only needed, if the encoder is used for streaming).
            </summary>
            <remarks>With this option you might disable the rate limiting during casting (as it'll be limited by the playback rate anyway if the source channel is being played).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.UseAsyncQueue">
            <summary>
            Gets or Sets if encoding should use an async queue (i.e. the BASS_ENCODE_QUEUE flag).
            </summary>
            <remarks>
            With this option you might enable queueing of sample data and feeding it to the encoder asynchronously in another thread,
            so that any update thread isn't delayed by the encoding.
            <para>This might be usefull when encoding a playback stream or a recording stream which is feeding playback.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.OutputFile">
            <summary>
            Specifies the output file name to be processed by the encoder (null = STDOUT).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> property.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.EffectiveBitrate">
            <summary>
            Specifies the target effective bitrate of the encoder output (in kbps, e.g. 128 kbps).
            </summary>
            <remarks>This member must return a valid bitrate, if you are using the encoder in a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> implementation.
            If you are encoding in VBR or ABR this member must also return a valid bitrate (e.g. approximated). 
            You might use one of the <see cref="T:Un4seen.Bass.Misc.BaseEncoder.BITRATE"/> constants in order to set a valid effective bitrate.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.IBaseEncoder.TAGs">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure associated with the encoder.
            </summary>
            <remarks>By default this member is <see langword="null"/> - meaning no Tag info is used with the encoder.
            <para>If you set this property to a valid <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance before you call <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, this will be used (when supported by the encoder) to automatically write the respective tag info to the output.
            Meaning the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/> will be modified accordingly.</para>
            <para>The TAGs will only be used, if you have specified an <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.OutputFile"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IBaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method must implement the actual start of the encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If <see langword="true"/>, you might use <see cref="M:Un4seen.Bass.Misc.IBaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Should return <see langword="true"/>, if the encoder was successfully started - else <see langword="false"/> must be returned.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IBaseEncoder.Stop">
            <summary>
            This method must implement the actual stop of the encoder. 
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero).
            </summary>
            <returns>Should return <see langword="true"/>, if the encoder was successfully stopped - else <see langword="false"/> must be returned and an <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must stay as before.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero). 
            If the encoder was not stopped and is still active or simply paused <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return a valid HENCODE (non-zero).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.IBaseEncoder.Pause(System.Boolean)">
            <summary>
            This method must implement the actual pauseing of the encoder. 
            After the encoder was paused successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must still return a valid HENCODE handle (non-zero).
            </summary>
            <param name="paused">Pause the encoder (<see langword="true"/>) or unpause (<see langword="false"/>).</param>
            <returns>Should return <see langword="true"/>, if the encoder was successfully paused - else <see langword="false"/> must be returned and an <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must stay as before.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/>.
            After the encoder was paused successfully the <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must still return a valid HENCODE handle (non-zero).
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.IBaseEncoder.EncoderHandle"/> must return 0 (zero).</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder">
            <summary>
            Base class for all encoder implementation classes (e.g. <see cref="!:EncoderLAME"/>, <see cref="!:EncoderWMA"/> or <see cref="!:EncoderOGG"/>).
            </summary>
            <remarks>This base class is not intended for direct use, but defines all abstract properties and methods which needs to be implemented by an actual broadcast encoder class.
            <para>Internally, the sending of sample data to the encoder is implemented via a DSP callback on the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>. That means when you play the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> (or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> if it's a decoding channel), the sample data will be sent to the encoder at the same time. 
            It also means that if the <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)">BASS_CONFIG_FLOATDSP</see> option is enabled, the sample data will be 32-bit floating-point.</para>
            <para>A derived class must implement: <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderType"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EffectiveBitrate"/> and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/>.</para>
            <para>The properties <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.IsActive"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.IsPaused"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>
            as well as the methods <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> have been already implemented.</para>
            <para>You might use this base class to derive your own Encoder implementations.
            In this case a derived class must only implement the following members: <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderType"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/>.</para>
            <para>If an instance of a derived class is being disposed, an already assigned Encoder will automatically be stopped.</para>
            <para>How to use an encoder implementation:
            <list type="table">
            <listheader><term>Scenario:</term><description>How-To:</description></listheader>
            <item><term>"Recording" To "Streaming":</term>
            <description>Create a recording handle with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to <see langword="null"/> (STDIN, STDOUT).</para>
            <para>Use the encoder instance to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>, which is then used by the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.</para>
            </description></item>
            <item><term>"Recording" To "File":</term>
            <description>Create a recording handle with <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to <see langword="null"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (STDIN, file).</para>
            <para>Call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> to start encoding and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> to stop the live recording encoding.</para>
            <code>
            EncoderNeroAAC n = new EncoderNeroAAC(_recHandle);
            n.InputFile = null;
            n.OutputFile = "test.m4a";
            n.NERO_Bitrate = 48;
            n.Start(null, IntPtr.Zero, false);
            // your recording will be encoded until you call...
            n.Stop();
            </code>
            <code lang="vbnet">
            Dim n As New EncoderNeroAAC(_recHandle)
            n.InputFile = Nothing
            n.OutputFile = "test.m4a"
            n.NERO_Bitrate = 48
            n.Start(Nothing, IntPtr.Zero, False)
            ' your recording will be encoded until you call...
            n.Stop()
            </code>
            </description></item>
            <item><term>"Stream" To "Streaming":</term>
            <description>Create a stream handle e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> (either normal or decoding).
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to <see langword="null"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (STDIN, file).</para>
            <para>Use the encoder instance to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>, which is then used by the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.</para>
            <para>Call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> resp. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if using a decoding stream) to play resp. decode the stream and actually feed the encoder and therewith the broadcasting server.</para>
            <para>Hint: You might use <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/> to create a continues mixer output stream channel for streaming.</para>
            </description></item>
            <item><term>"Stream" To "File":</term>
            <description>Create a stream handle e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> (either normal or decoding).
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to <see langword="null"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (STDIN, file).</para>
            <para>Call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/> resp. <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if using a decoding stream) to play resp. decode the stream and actually feed the encoder.</para>
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_STREAM_DECODE);
            EncoderLAME l = new EncoderLAME(stream);
            l.InputFile = null;	//STDIN
            l.OutputFile = "test.mp3";
            l.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_64;
            l.LAME_Mode = EncoderLAME.LAMEMode.Default;
            l.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            l.Start(null, IntPtr.Zero, false);
            // decode the stream (if not using a decoding channel, simply call "Bass.BASS_ChannelPlay" here)
            byte[] encBuffer = new byte[65536]; // our dummy encoder buffer
            while (Bass.BASS_ChannelIsActive(stream) == BASSActive.BASS_ACTIVE_PLAYING)
            {
            	// getting sample data will automatically feed the encoder
            	int len = Bass.BASS_ChannelGetData(_stream, encBuffer, encBuffer.Length);
            }
            l.Stop();  // finish
            Bass.BASS_StreamFree(stream);
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.wav", 0, 0, BASSFlag.BASS_STREAM_DECODE)
            Dim l As New EncoderLAME(stream)
            l.InputFile = Nothing 'STDIN
            l.OutputFile = "test.mp3"
            l.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_64)
            l.LAME_Mode = EncoderLAME.LAMEMode.Default
            l.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            l.Start(Nothing, IntPtr.Zero, False)
            ' decode the stream (if not using a decoding channel, simply call "Bass.BASS_ChannelPlay" here)
            Dim encBuffer(65536) As Byte ' our dummy encoder buffer
            While Bass.BASS_ChannelIsActive(stream) = BASSActive.BASS_ACTIVE_PLAYING
              ' getting sample data will automatically feed the encoder
              Dim len As Integer = Bass.BASS_ChannelGetData(_stream, encBuffer, encBuffer.Length)
            End While
            l.Stop() ' finish
            Bass.BASS_StreamFree(stream)
            </code>
            </description></item>
            <item><term>"File" To "Streaming":</term>
            <description>Create a stream handle e.g. with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> (either normal or decoding).
            Just like the above example. And use the stream handle to create the encoder instance.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> to <see langword="null"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to <see langword="null"/> (STDIN, STDOUT).</para>
            <para>Use the encoder instance to create a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>, which is then used by the <see cref="T:Un4seen.Bass.Misc.BroadCast"/> class.</para>
            </description></item>
            <item><term>"File" To "File":</term>
            <description>No stream handle is actually needed.
            <para>Set <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> to a file name (file, file).</para>
            <para>Call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> to start encoding and <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> to stop encoding.</para>
            <para>Or simply use the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/> method instead.</para>
            <code>
            EncoderOGG o = new EncoderOGG(0);
            o.InputFile = "test.wav";
            o.OutputFile = "test.ogg";
            o.OGG_UseQualityMode = true;
            o.OGG_Quality = 4;
            BaseEncoder.EncodeFile(o, null, true, false, true);
            </code>
            <code lang="vbnet">
            Dim o As New EncoderOGG(0)
            o.InputFile = "test.wav"
            o.OutputFile = "test.ogg"
            o.OGG_UseQualityMode = True
            o.OGG_Quality = 4
            BaseEncoder.EncodeFile(o, Nothing, True, False, True)
            </code>
            </description></item>
            </list>
            </para>
            </remarks>
            <example>
            This example shows a basic implementation of an own Encoder class:
            <code>
            public class MyOwnEncoder : BaseEncoder
            {
            	// Constructor
            	public MyOwnEncoder(int channel) : base(channel)
            	{
            	}
            	
            	public override string ToString()
            	{
            	  return "My Encoder (BASS_CTYPE_STREAM_MP3)";
            	}
            	
            	public override string DefaultOutputExtension
            	{
            	  get { return ".mp3"; }
            	}
            	
            	public override BASSChannelType EncoderType
            	{
            	  get { return BASSChannelType.BASS_CTYPE_STREAM_MP3; }
            	}
            	
            	public override bool SupportsSTDOUT
            	{
            	  get { return true; }
            	}
            	
            	public override string EncoderCommandLine
            	{
            	  get { return BuildEncoderCommandLine(); }
            	}
            
            	public override int EffectiveBitrate
            	{
            	  get { return My_Bitrate; }	
            	}
            	
            	public override bool Start(ENCODEPROC proc, IntPtr user, bool paused)
            	{
            	  if (EncoderHandle != 0 || (proc != null &amp;&amp; !SupportsSTDOUT))
            	    return false;
            	  // start the encoder
                  BASSEncode flag = BASSEncode.BASS_ENCODE_NOHEAD;
                  if (Force16Bit)
                    flag |= BASSEncode.BASS_ENCODE_FP_16BIT;
                  if (paused)
                    flag |= BASSEncode.BASS_ENCODE_PAUSE;
            	  EncoderHandle = BassEnc.BASS_Encode_Start(ChannelHandle, EncoderCommandLine, 
            	                                            flag, proc, user);
            	  if (EncoderHandle == 0)
            	    return false;
            	  else
            	    return true;
            	}
            	
            	// local members for setting individual parameters
            	public int My_Bitrate = 128; 
            	
            	// just an example here!
            	private string BuildEncoderCommandLine()
            	{
            	  CultureInfo enCI = new CultureInfo("en-US", false);
            	  StringBuilder sb = new StringBuilder();
            	  // the file name and path
            	  sb.Append( Path.Combine( EncoderDirectory, "myencoder.exe" ) );
            	  // raw input?
            	  if (InputFile == null) // STDIN: add the raw pcm header data
            	    sb.Append( String.Format( enCI, " -r -x -s {0:##0.0##} --bitwidth {1}", 
                               ChannelSampleRate/1000f, ChannelBitwidth > 16 ? 16 : ChannelBitwidth ) );
            	  // ...more options here...
            	  sb.Append( String.Format( enCI, " -b {0} -h", My_Bitrate ) );
            	  // STDIN or filename
            	  if (InputFile != null)
            	    sb.Append( " \""+InputFile+"\"" );
            	  else
            	    sb.Append( " -" );
            	  // STDOUT or filename
            	  if (OutputFile != null)
            	    sb.Append( " \""+OutputFile+"\"" );
            	  else
            	    sb.Append( " -" );
            	  return sb.ToString();	
            	}
            }
            </code>
            <code lang="vbnet">
            Public Class MyOwnEncoder Inherits BaseEncoder
            
                ' Constructor
                Public Sub New(channel As Integer) MyBase.New(channel)
                End Sub
            
                Public Overrides Function ToString() As String
                  Return "My Encoder (BASS_CTYPE_STREAM_MP3)"
                End Function
            
                Public Overrides ReadOnly Property DefaultOutputExtension() As String
                  Get
                    Return ".mp3"
                  End Get
                End Property 
            
                Public Overrides ReadOnly Property EncoderType() As BASSChannelType
                  Get
                    Return BASSChannelType.BASS_CTYPE_STREAM_MP3
                  End Get
                End Property
            
                Public Overrides ReadOnly Property SupportsSTDOUT() As Boolean
                  Get
                    Return True
                  End Get
                End Property 
            
                Public Overrides ReadOnly Property EncoderCommandLine() As String
                  Get
                    Return BuildEncoderCommandLine()
                  End Get
                End Property 
            
                Public Overrides ReadOnly Property EffectiveBitrate() As Integer
                  Get
                    Return My_Bitrate
                  End Get
                End Property
            
                Public Overrides Function Start(proc As ENCODEPROC, user As IntPtr, paused As Boolean) As Boolean
                  If EncoderHandle &lt;&gt; 0 OrElse (Not (proc Is Nothing) AndAlso Not SupportsSTDOUT) Then
                    Return False
                  End If 
                  ' start the encoder
                  Dim flag As BASSEncode = BASSEncode.BASS_ENCODE_NOHEAD
                  If Force16Bit Then
                    flag = flag Or BASSEncode.BASS_ENCODE_FP_16BIT
                  End If
                  If paused Then
                    flag = flag Or BASSEncode.BASS_ENCODE_PAUSE
                  End If
                  EncoderHandle = BassEnc.BASS_Encode_Start(ChannelHandle, EncoderCommandLine, 
                                                            flag, proc, user)
                  End If
                  If EncoderHandle = 0 Then
                    Return False
                  Else
                    Return True
                  End If
                End Function
            
                ' local members for setting individual parameters
                Public My_Bitrate As Integer = 128
            
                ' just an example here!
                Private Function BuildEncoderCommandLine() As String
                  Dim enCI As New CultureInfo("en-US", False)
                  Dim sb As New StringBuilder()
                  ' the file name and path
                  sb.Append(Path.Combine(EncoderDirectory, "myencoder.exe"))
                  ' raw input?
                  If InputFile Is Nothing Then ' STDIN: add the raw pcm header data
                    sb.Append([String].Format(enCI, " -r -x -s {0:##0.0##} --bitwidth {1}", 
                              ChannelSampleRate / 1000F,(If ChannelBitwidth > 16 Then 16 Else ChannelBitwidth))) 'ToDo: Unsupported feature: conditional (?) operator.
                  End If ' ...more options here...
                  sb.Append([String].Format(enCI, " -b {0} -h", My_Bitrate))
                  ' STDIN or filename
                  If Not (InputFile Is Nothing) Then
                    sb.Append((" """ + InputFile + """"))
                  Else
                    sb.Append(" -")
                  End If ' STDOUT or filename
                  If Not (OutputFile Is Nothing) Then
                    sb.Append((" """ + OutputFile + """"))
                  Else
                    sb.Append(" -")
                  End If
                  Return sb.ToString()
                End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.#ctor(System.Int32)">
            <summary>
            Default constructor, which already evaluates the channel handle and evaluates the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/>.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>If you pass 0 (zero) as a channel handle, all members are initialized with some default values.
            You can change the channel handle by assigning a new value to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> property.
            A channel handle can only be changed, if the encoder is not active (see <see cref="P:Un4seen.Bass.Misc.BaseEncoder.IsActive"/>).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle">
            <summary>
            Gets or Sets the channel handle which is used to create the broadcast encoder class.
            </summary>
            <remarks>This allows you to move the encoder to another channel on the fly.
            <para>The new channel must have the same sample format (rate, channels, resolution) as the old channel, as that is what the encoder is expecting!</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelInfo">
            <summary>
            Returns the general channel info.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth">
            <summary>
            This property returns the actual bitwidth of the sample data of the channel (e.g. 8, 16, 32).
            </summary>
            <remarks>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            This bitwidth represents the bitwidth which is used by BASS (e.g. in a DSP callback delegate) and does not represent the original bitwidth of the stream.
            The bitwidth used by BASS is determined how the underlying channel handle was created (e.g. using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag)
            and if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> option has been set.
            If non of the above was used, by default 16 bits per sample are used.
            <para>However this bitwidth is the bitwidth in use when sending sample data to an encoder.
            If for example the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> or the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> option have been used,
            the encoder would receive 32-bit float samples. If the derived encoder implementation does not support floating-point sample data, 
            the encoder implementation should use one of the <see cref="T:Un4seen.Bass.AddOn.Enc.BASSEncode"/> flags: BASS_ENCODE_FP_8BIT, BASS_ENCODE_FP_16BIT, BASS_ENCODE_FP_24BIT, BASS_ENCODE_FP_32BIT.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate">
            <summary>
            This property returns the actual sample rate in Hz of the sample data BASS is using with the channel (e.g. 44100).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans">
            <summary>
            This property returns the actual number of channles of the sample data BASS is using with the channel (e.g. 1=mono, 2=stereo, etc.).
            </summary>
            <remarks>BASS supports multi-channel sample data, so make sure the actual encoder implementation supports multi-channel too.
            If the encoder does not support multi-channel make sure that you are using non-multi-channel hanles only.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT">
            <summary>
            This property should return <see langword="true"/>, if the base encoder implementation (resp. the underlying command-line tool being used) support STDOUT for output of the encoded data - else <see langword="false"/> must be returned.
            </summary>
            <remarks>In order to support broadcast streaming with an encoder command-line tool,
            the encoded data needs to be received back by a callback function, so the encoder needs to be told to output to STDOUT (instead of a file).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderType">
            <summary>
            This property should return a value indicating which type of content the broadcast encoder implements.
            </summary>
            <remarks>For example: If the implementation of the broadcast encoder implements an MP3 encoder, you should return BASS_CTYPE_STREAM_MP3.
            For a complete list see <see cref="T:Un4seen.Bass.BASSChannelType"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension">
            <summary>
            This property should return the default extension of an output file for this encoder (e.g. ".mp3" or ".ogg" etc.).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle">
            <summary>
            Gets or sets the current HENCODE encoder handle.
            </summary>
            <remarks>The encoder handle will be set to a valid HENCODE handle, when the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> method was successfully called.
            The encoder hande will be set to 0 (zero) when <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> is called.
            <para>It is not advised to modify the encoder handle except in the actual implementation of the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/> method.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.IsActive">
            <summary>
            Gets a value indicating if the encoder has been started (see <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>) and is active - else <see langword="false"/> will be returned.
            </summary>
            <remarks>This implementation first gets the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method is used to check the state.
            If the state is not BASS_ACTIVE_STOPPED <see langword="true"/> is returned.
            In all other cases <see langword="false"/> is returned (not started, paused, stopped etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.IsPaused">
            <summary>
            Gets a value indicating if the encoder has been paused (see <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/>) - else <see langword="false"/> must be returned.
            </summary>
            <remarks>This implementation first gets the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            If the encoder handle is valid (non-zero) the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_IsActive(System.Int32)"/> method is used to check the state.
            Only if the state is BASS_ACTIVE_PAUSED this property returns <see langword="true"/>.
            In all other cases <see langword="false"/> is returned (not started, active, playing etc.)</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory">
            <summary>
            Gets or Sets the encoder's base directory.
            </summary>
            <remarks>This property might be used in the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> implementation to return a fully qualified path to the encoder executable within the command-line.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine">
            <summary>
            This property should return an encoder command-line string, 
            which might be used with the <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> method in order to create and start the encoder.
            </summary>
            <remarks>Make sure, that the encoder command-line is evaluating the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> and <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> members correctly.
            Derived classes might also intruduce additional members which will have a direct impact of the command-line string.
            Therefore the actual implementation of this property should always generate the command-line dynamically when this property is accessed.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EncoderExists">
            <summary>
            This property should return <see langword="true"/>, if the encoder exists and is available - else <see langword="false"/> should be returned.
            </summary>
            <remarks>When using a command-line encoder this method might check, if the executable file exists in the specified <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderDirectory"/>.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.InputFile">
            <summary>
            Gets or Sets the input file name to be processed by the encoder (null = STDIN, default).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> property.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.Force16Bit">
            <summary>
            Gets or Sets if a encoding in 16-bit sample data should be forced (default is <see langword="false"/>).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> property.
            <para>When you want to encode a floating-point channel, but the encoder does not support 32-bit floating-point sample data, then you can use this flags to have the sample data converted to 16 bit integer data before it's passed on to the encoder.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.NoLimit">
            <summary>
            Gets or Sets if encoding should use the CAST_NOLIMIT flag (which is only needed, if the encoder is used for streaming).
            </summary>
            <remarks>With this option you might disable the rate limiting during casting (as it'll be limited by the playback rate anyway if the source channel is being played).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.UseAsyncQueue">
            <summary>
            Gets or Sets if encoding should use an async queue (i.e. the BASS_ENCODE_QUEUE flag).
            </summary>
            <remarks>
            With this option you might enable queueing of sample data and feeding it to the encoder asynchronously in another thread,
            so that any update thread isn't delayed by the encoding.
            <para>This might be usefull when encoding a playback stream or a recording stream which is feeding playback.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile">
            <summary>
            Gets or Sets the output file name to be processed by the encoder (null = STDOUT, default).
            </summary>
            <remarks>This member should be used when implementing the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> property.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.EffectiveBitrate">
            <summary>
            This property should return the target effective bitrate of the encoder output (in kbps, e.g. 128 kbps).
            </summary>
            <remarks>This member must return a valid bitrate (in kbps), if you are using the encoder in a <see cref="T:Un4seen.Bass.Misc.BroadCast"/> implementation (i.e. the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> is set to <see langword="true"/>).
            If an encoder implementation will never be used for broadcast streaming (or the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> is set to <see langword="false"/>) this property will not be used and mihgt not be overridden therefore.
            <para>If you are encoding in VBR or ABR this member must also return a valid bitrate (e.g. an approximated average). 
            You might use one of the <see cref="T:Un4seen.Bass.Misc.BaseEncoder.BITRATE"/> constants in order to set a valid effective bitrate.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseEncoder.TAGs">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> structure associated with the encoder.
            </summary>
            <remarks>By default this member is <see langword="null"/> - meaning no Tag info is used with the encoder.
            <para>If you set this property to a valid <see cref="T:Un4seen.Bass.AddOn.Tags.TAG_INFO"/> instance before you call <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>, this will be used (when supported by the encoder) to automatically write the respective tag info to the output.
            Meaning the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/> will be modified accordingly.</para>
            <para>The TAGs will only be used, if you have specified an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method must implement the actual start of the encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must return a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data... <see langword="null"/> = no callback. 
            To have the encoded data received by a callback function, the encoder needs to be told to output to STDOUT (instead of a file), so <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> must return true.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If <see langword="true"/>, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Should return <see langword="true"/>, if the encoder was successfully started - else <see langword="false"/> must be returned.</returns>
            <remarks>An imlementation of this method should internally call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderCommandLine"/>.
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must return a valid HENCODE handle. 
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must return 0 (zero).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Stop">
            <summary>
            Stops the encoder (if started).
            </summary>
            <returns>Returns <see langword="true"/>, if the encoder was successfully stopped - else <see langword="false"/> is returned.</returns>
            <remarks>Internally <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Stop(System.Int32)"/> is called using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is set to 0 (zero). 
            If the encoder was not stopped the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is left unchanged.
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Stop(System.Boolean)">
            <summary>
            Stops the encoder (if started).
            </summary>
            <param name="queue"><see langword="true"/> to tell BASSenc to wait for the async queue to be processed (the function will still return immediately but the encoder won't be freed yet).</param>
            <returns>Returns <see langword="true"/>, if the encoder was successfully stopped - else <see langword="false"/> is returned.</returns>
            <remarks>This overload is only in effect, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.UseAsyncQueue"/> is set (to <see langword="true"/>).
            Internally <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_StopEx(System.Int32,System.Boolean)"/> is called using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            After the encoder was stopped successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is set to 0 (zero). 
            If the encoder was not stopped the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> is left unchanged.
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)">
            <summary>
            Pauses or resumes an encoder. 
            </summary>
            <param name="paused"><see langword="true"/> = pause the encoder, <see langword="false"/> = resume the encoder.</param>
            <returns>Returns <see langword="true"/>, if the encoder was successfully paused/resumed - else <see langword="false"/> must be returned and an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must stay as before.</returns>
            <remarks>
            After the encoder was paused/resumed successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> must still return a valid HENCODE handle (non-zero).
            <para>The default imlementation of this method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_SetPaused(System.Int32,System.Boolean)"/> accordingly using the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/>.
            So normally there is no need to override this method.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.SettingsString">
            <summary>
            Returns the string representation of the current encoder settings.
            </summary>
            <returns>The descriptive settings string.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder.BITRATE">
            <summary>
            List of supported encoding bitrates (kbps).
            </summary>
            <remarks>Not all bitrates are supported for all sample frequencies. See the following table for an overview:
            <list type="table">
            <item><term>MPEG-1 layer III sample frequencies (kHz):  32  44.1  48</term>
            <description>bitrates (kbps): 32 40 48 56 64 80 96 112 128 160 192 224 256 320</description></item>
            <item><term>MPEG-2 layer III sample frequencies (kHz):  16  22.05  24</term>
            <description>bitrates (kbps):  8 16 24 32 40 48 56 64 80 96 112 128 144 160</description></item>
            <item><term>MPEG-2.5 layer III sample frequencies (kHz):   8  11.025  12</term>
            <description>bitrates (kbps):  8 16 24 32 40 48 56 64 80 96 112 128 144 160</description></item>
            <item><term>AACplus sample frequencies (kHz):  32  44.1  48</term>
            <description>bitrates (kbps): 16 20 24 28 32 40 48 56 64 80 96 112 128
            <para>aacPlusHigh additional bitrates (kbps): 160 192 224 256 320</para></description></item>
            <item><term>OGG sample frequencies (kHz):   all from 8  to 96</term>
            <description>bitrates (kbps): 8 16 24 32 40 48 56 64 80 96 112 128 144 160 192 224 256 320</description></item>
            <item><term>WMA sample frequencies (kHz):  8  11.025  16  22  32  44.1  48</term>
            <description>bitrates (kbps): 6 8 10 12 16 20 22 32 40 48 64 80 96 128 160 192 256 320</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_6">
            <summary>
            6kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_8">
            <summary>
            8kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_10">
            <summary>
            10kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_12">
            <summary>
            12kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_16">
            <summary>
            16kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_20">
            <summary>
            20kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_22">
            <summary>
            22kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_24">
            <summary>
            24kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_32">
            <summary>
            32kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_40">
            <summary>
            40kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_48">
            <summary>
            48kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_56">
            <summary>
            56kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_64">
            <summary>
            64kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_80">
            <summary>
            80kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_96">
            <summary>
            96kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_112">
            <summary>
            112kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_128">
            <summary>
            128kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_144">
            <summary>
            144kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_160">
            <summary>
            160kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_192">
            <summary>
            192kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_224">
            <summary>
            224kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_256">
            <summary>
            256kbps
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.BITRATE.kbps_320">
            <summary>
            320kbps
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE">
            <summary>
            List of supported broadcast sample rates.
            </summary>
            <remarks>Make sure this samplerate matches your encoder settings.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_8000">
            <summary>
            8 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_11025">
            <summary>
            11.025 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_16000">
            <summary>
            16 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_22050">
            <summary>
            22.05 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_32000">
            <summary>
            32 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_44100">
            <summary>
            44.1 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_48000">
            <summary>
            48 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_96000">
            <summary>
            96 kHz
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.BaseEncoder.SAMPLERATE.Hz_192000">
            <summary>
            192 kHz
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC">
            <summary>
            This delegate might be used in the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/> method.
            </summary>
            <param name="bytesTotal">The total number of bytes to be encode.</param>
            <param name="bytesDone">The number of bytes already encoded.</param>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if <see langword="null"/>, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Encodes a file using the EncoderWMA (CBR at 128 kbps):
            <code>
            EncoderWMA wma = new EncoderWMA(0);
            wma.WMA_Bitrate = 128;
            BaseEncoder.EncodeFile("test.wav", null, wma, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), true, false);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
              Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim wma As New EncoderWMA(0)
            wma.WMA_Bitrate = 128
            BaseEncoder.EncodeFile("test.wav", Nothing, wma, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), True, False)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            Encodes OGG input to an MP3 output using EncoderLAME (with the 'standard' preset):
            <code>
            EncoderLAME enc = new EncoderLAME(0);
            enc.LAME_PresetName = "standard";
            BaseEncoder.EncodeFile("test.ogg", null, enc, null, true, false);
            </code>
            <code lang="vbnet">
            Dim enc As New EncoderLAME(0)
            enc.LAME_PresetName = "standard"
            BaseEncoder.EncodeFile("test.ogg", Nothing, enc, Nothing, True, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Encodes a file using the EncoderWMA (using CBR at 128 kbps Pro):
            <code>
            EncoderWMA wma = new EncoderWMA(0);
            wma.InputFile = "testin.ogg";
            wma.OutputFile = "testout.wma";
            wma.WMA_Bitrate = 128;
            wma.WMA_UsePro = true;
            BaseEncoder.EncodeFile(wma, new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), true, false);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim wma As New EncoderWMA(0)
            wma.InputFile = "testin.ogg"
            wma.OutputFile = "testout.wma"
            wma.WMA_Bitrate = 128
            wma.WMA_UsePro = True
            BaseEncoder.EncodeFile(wma, New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), True, False)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if <see langword="null"/>, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to <see langword="true"/>, if you want to use the TAGs from the input file and write them also to the output file. <see langword="false"/> will write the output without any TAGs.</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file to MP3 using the EncoderLAME (no notification, but copying the TAGs):
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            lame.TAGs = BassTags.BASS_TAG_GetFromFile("testin.ogg", true, false);;
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, null, true, false, true);
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            lame.TAGs = BassTags.BASS_TAG_GetFromFile("testin.ogg", True, False)
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, Nothing, True, False, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to <see langword="true"/>, if you want to use the TAGs from the input file and write them also to the output file. <see langword="false"/> will write the output without any TAGs.</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file to MP3 using the EncoderLAME (manual tagging):
            <code>
            TAG_INFO tags = new TAG_INFO();
            tags.artist = "The Artist";
            tags.title = "The Title";
            
            EncoderLAME lame = new EncoderLAME(0);
            lame.InputFile = "test.ogg";
            lame.TAGs = tags;
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile(lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), true, false, true);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim tags As New TAG_INFO()
            tags.artist = "The Artist"
            tags.title = "The Title"
            
            Dim lame As New EncoderLAME(0)
            lame.InputFile = "test.ogg"
            lame.TAGs = tags
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile(lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), True, False, True)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if <see langword="null"/>, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to <see langword="true"/>, if you want to use the TAGs from the input file and write them also to the output file. <see langword="false"/> will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in bytes from where to start encoding or -1 to encode from the beginning.</param>
            <param name="toPos">Sets the end position in bytes til where want to encode or -1 to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file partially to MP3 using the EncoderLAME:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, null, true, false, true, 4096, 61440);
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, Nothing, True, False, True, 4096, 61440)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Int64)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to <see langword="true"/>, if you want to use the TAGs from the input file and write them also to the output file. <see langword="false"/> will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in bytes from where to start encoding or -1 to encode from the beginning.</param>
            <param name="toPos">Sets the end position in bytes til where want to encode or -1 to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file partially to MP3 using the EncoderLAME:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.InputFile = "testin.ogg";
            lame.OutputFile = "testout.mp3";
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile(lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   true, false, true, 4096, 61440);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.InputFile = "testin.ogg"
            lame.OutputFile = "testout.mp3"
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile(lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   True, False, True, 4096, 61440)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="inputFile">The input filename to encode (must exist).</param>
            <param name="outputFile">The target output filename (if <see langword="null"/>, the filename will be composed by changing the file extension to the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/>).</param>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to <see langword="true"/>, if you want to use the TAGs from the input file and write them also to the output file. <see langword="false"/> will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in seconds (incl. fractions) from where to start encoding or -1.0f to encode from the beginning.</param>
            <param name="toPos">Sets the end position in seconds (incl. fractions) til where want to encode or -1.0f to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file partially to MP3 using the EncoderLAME:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   true, false, true, 5.1f, 25.3f);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile("testin.ogg", "testout.mp3", lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification),
                                   True, False, True, 5.1F, 25.3F)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>
            Encodes a given input file to a given output file using the specified encoder.
            </summary>
            <param name="encoder">The encoder to be used (make sure you set all the parameter members of the encoder before).</param>
            <param name="proc">An optional callback procedure which should be called during the encoding process in order to inform you about the encoding progress (<see langword="null"/> = no notifcation).</param>
            <param name="overwriteOutput">Set to <see langword="true"/>, if you want to force to overwrite any already existing output file (will delete the existing file). If set to <see langword="false"/> and the output file already exists the method will fail, but the existing file will not be deleted.</param>
            <param name="deleteInput">Set to <see langword="true"/>, if you want to delete the input file after the encoding has been successfully completed.</param>
            <param name="updateTags">Set to <see langword="true"/>, if you want to use the TAGs from the input file and write them also to the output file. <see langword="false"/> will write the output without any TAGs.</param>
            <param name="fromPos">Sets the start position in seconds (incl. fractions) from where to start encoding or -1.0f to encode from the beginning.</param>
            <param name="toPos">Sets the end position in seconds (incl. fractions) til where want to encode or -1.0f to encode til the end. toPos must be greater than fromPos!</param>
            <returns>Returns <see langword="true"/>, if the input file was successfully encoded. Returns <see langword="false"/> if any error occured.</returns>
            <remarks>The InputFile and OutputFile will be taken from the encoder settings!
            <para>The method will use <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> in order to open the input file for encoding. 16-bit will always be used here to read the inputFile.
            So any file format supported by BASS or the BASS plugin system might be used.</para>
            </remarks>
            <exception cref="T:System.IO.IOException">The output file already exists (only raised when the <paramref name="overwriteOutput"/> is not used).</exception>
            <example>
            Re-Encodes an OGG file to MP3 using the EncoderLAME partially:
            <code>
            EncoderLAME lame = new EncoderLAME(0);
            lame.InputFile = "testin.ogg";
            lame.OutputFile = "testout.mp3";
            lame.LAME_Bitrate = (int)EncoderLAME.BITRATE.kbps_192;
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default;
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality;
            BaseEncoder.EncodeFile(lame, 
                                   new BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   true, false, true,
                                   5.1f, 25.3f);
            
            public void FileEncodingNotification(long bytesTotal, long bytesDone)
            {
            	Console.Write("Encoding: {0:P}\r", Math.Round((double)bytesDone/(double)bytesTotal, 2));
            }
            </code>
            <code lang="vbnet">
            Dim lame As New EncoderLAME(0)
            lame.InputFile = "testin.ogg"
            lame.OutputFile = "testout.mp3"
            lame.LAME_Bitrate = CInt(EncoderLAME.BITRATE.kbps_192)
            lame.LAME_Mode = EncoderLAME.LAMEMode.Default
            lame.LAME_Quality = EncoderLAME.LAMEQuality.Quality
            BaseEncoder.EncodeFile(lame, 
                                   New BaseEncoder.ENCODEFILEPROC(FileEncodingNotification), 
                                   True, False, True, 5.1F, 25.3F)
            
            Public Sub FileEncodingNotification(bytesTotal As Long, bytesDone As Long)
              Console.Write("Encoding: {0:P}\r", Math.Round(CDbl(bytesDone) / CDbl(bytesTotal), 2))
            End Sub
            </code>
            </example>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderWAV">
            <summary>
            Encoder class implementation for the RIFF WAVE format using raw PCM sample data with no real encoder.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV"/> encoder type.
            <para>This format supports 8-, 16- and 32-bit(IEEE float) sample data as input.</para>
            <para>Make sure to set the WAV_xxx and/or BWF_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderWAV.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>TAG writing is supported by saving appropriate RIFF LIST INFO chunks.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
            <example>
            Manual encoding "File" To "File" in 32-bit:
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            EncoderWAV w = new EncoderWAV(stream);
            w.InputFile = null;
            w.OutputFile = "test.wav";  // will be a 32-bit IEEE float WAVE file, since the stream is float
            w.Start(null, IntPtr.Zero, false);
            // do the encoding
            Utils.DecodeAllData(stream, true);
            w.Stop();
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim w As New EncoderWAV(stream)
            w.InputFile = Nothing
            w.OutputFile = "test.wav" ' will be a 32-bit IEEE float WAVE file, since the stream is float
            w.Start(Nothing, IntPtr.Zero, False)
            ' do the encoding
            Utils.DecodeAllData(stream, True)
            w.Stop()
            </code>
            Manual encoding "File" To "File" in 24-bit:
            <code>
            EncoderWAV w = new EncoderWAV(0);
            w.InputFile = "testIn.wav";
            w.OutputFile = "testOut.wav";
            w.WAV_BitsPerSample = 24;
            w.Start(null, IntPtr.Zero, false);
            w.Stop();
            </code>
            <code lang="vbnet">
            Dim w As New EncoderWAV(0)
            w.InputFile = "testIn.wav"
            w.OutputFile = "testOut.wav"
            w.WAV_BitsPerSample = 24
            w.Start(Nothing, IntPtr.Zero, False)
            w.Stop()
            </code>
            "Recording" To "File" in 16-bit:
            <code>
            private RECORDPROC _recProc;
            
            // init your recording device (we use the default device)
            if ( !Bass.BASS_RecordInit(-1) )
              MessageBox.Show(this, "Bass_RecordInit error!" );
            _recProc = new RECORDPROC(RecordingHandler);
            // start recording at 44.1kHz, stereo (paused)
            int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _recProc, IntPtr.Zero);
            if (recHandle == Bass.FALSE)
              MessageBox.Show(this, "BASS_RecordStart error!" );
            
            // setup the encoder
            EncoderWAV w = new EncoderWAV(recHandle);
            w.InputFile = null;
            w.OutputFile = "testrec.wav";
            w.Start(null, IntPtr.Zero, true); // start encoder paused
            ...
            // now really start recording and encoding
            w.Pause(false);
            Bass.BASS_ChannelPlay(recHandle, false);
            ...
            // your recording will be encoded until you call
            w.Stop();
            
            private bool RecordingHandler(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            private RECORDPROC _recProc;
            
            ' init your recording device (we use the default device)
            If Not Bass.BASS_RecordInit(- 1) Then
              MessageBox.Show(Me, "Bass_RecordInit error!")
            End If
            _recProc = New RECORDPROC(AddressOf RecordingHandler)
            ' start recording at 44.1kHz, stereo (paused)
            Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _recProc, IntPtr.Zero)
            If recHandle = Bass.FALSE Then
              MessageBox.Show(Me, "BASS_RecordStart error!")
            End If 
            
            ' setup the encoder
            Dim w As New EncoderWAV(recHandle)
            w.InputFile = Nothing
            w.OutputFile = "testrec.wav"
            w.Start(Nothing, IntPtr.Zero, True) ' start encoder paused
            ...
            ' now really start recording and encoding
            w.Pause(False)
            Bass.BASS_ChannelPlay(recHandle, False)
            ...
            ' your recording will be encoded until you call
            w.Stop()
            
            Private Function RecordingHandler(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.#ctor(System.Int32)">
            <summary>
            Creates an instance of a RIFF WAVE implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements RIFF WAVE encoding.
            <pata>This encoder might be used for streaming, since it does support STDOUT.</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>E.g. returns "RIFF WAVE (BASS_CTYPE_STREAM_WAV)" or "AIFF Encoder (BASS_CTYPE_STREAM_AIFF)".</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here the <see cref="F:Un4seen.Bass.Misc.EncoderWAV.WAV_EncoderType"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (e.g. ".wav"). Here the <see cref="F:Un4seen.Bass.Misc.EncoderWAV.WAV_DefaultOutputExtension"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.SupportsSTDOUT">
            <summary>
            WAV does not implement STDOUT, so <see langword="false"/> is always returned.
            </summary>
            <remarks>This encoder might not be used for streaming, since it does not support STDOUT.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.EncoderCommandLine">
            <summary>
            Returns the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>, since WAV does not use any command-line tool.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>This implementation evaluates the original <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/> in order to calculate the effective bitrate.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual WAV encoder. 
            </summary>
            <param name="proc">Must be <see langword="null"/> = no callback, since EncoderWAV does not support STDOUT.</param>
            <param name="user">Must be <see cref="F:System.IntPtr.Zero"/>, since EncoderWAV does not support STDOUT.</param>
            <param name="paused">Start the encoder paused? If <see langword="true"/>, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns <see langword="true"/>, if the encoder was successfully started - else <see langword="false"/> is returned.</returns>
            <remarks>This method uses the BASS_ENCODE_PCM flag to write plain PCM sample data to a file (if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> has been specified), without an encoder.
            If no <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> has been specified (<see langword="null"/>) - nothing will actually happen.
            <para>If you have specified a file name for <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> (instead of <see langword="null"/>), a default stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> will be created internally and all it's data will immediately be encoded (meaning the <paramref name="paused"/> flag will have no effect),
            else the data from the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> will be encoded.</para>
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.Force16Bit">
            <summary>
            Always returns false, since this encoder doesn't supports this flag. The target format can be set via the <see cref="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample"/> property.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderWAV.SettingsString">
            <summary>
            Returns the string representation of the current encoder settings.
            </summary>
            <returns>The descriptive settings string.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample">
            <summary>
            Gets or Sets the target resolution (number of bits per sample) of the Wave file to create -
            (by default the original resolution will be used).
            </summary>
            <remarks>This property is only evaluated, if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> has been specified or the BASS_CONFIG_FLOATDSP option is set!
            NOTE: In all other cases the original resolution will be used!
            <para>This property should be either 8, 16, 24 or 32.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.WAV_Use32BitInteger">
            <summary>
            Gets or Sets, if 32bit integer (instead of 32bit IEEE float) should be used when setting <see cref="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample"/> to 32 (default is <see langword="false"/>)?
            </summary>
            <remarks>When seeting this property to <see langword="true"/> and setting the <see cref="P:Un4seen.Bass.Misc.EncoderWAV.WAV_BitsPerSample"/> property to 32, the 32bit integer wave format is used - 
            else the 32bit IEEE float is used as the default 32bit format.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.WAV_AddRiffInfo">
            <summary>
            Gets or Sets, if a RIFF INFO LIST chunk should be written to the file (default is <see langword="false"/>)?
            </summary>
            <remarks>The presense of a <see cref="P:Un4seen.Bass.Misc.BaseEncoder.TAGs"/> structure is required to write the RIFF INFO LIST chunk to the file.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.WAV_UseAIFF">
            <summary>
            Gets or Sets, if the AIFF format should be used instead of the WAVE format (default is <see langword="false"/>)?
            </summary>
            <remarks>The AIFF format doesn't support the RIFF INFO or BWF options, but its format is compatible on Windows and Mac.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.BWF_UseRF64">
            <summary>
            Gets or Sets, if a BWF RF64 WAVE header should be used instead of a regular WAVE header (default is <see langword="false"/>)?
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.BWF_AddBEXT">
            <summary>
            Gets or Sets, if a BWF BEXT chunk should be written to the file (default is <see langword="false"/>)?
            </summary>
            <remarks>The presense of a <see cref="P:Un4seen.Bass.Misc.BaseEncoder.TAGs"/> structure is required to write the BEXT chunk to the file.
            <para>When writing a BWF BEXT chunk to the file, the native tags with the prefix BWF are being used.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderWAV.BWF_AddCART">
            <summary>
            Gets or Sets, if a BWF CART chunk should be written to the file (default is <see langword="false"/>)?
            </summary>
            <remarks>The presense of a <see cref="P:Un4seen.Bass.Misc.BaseEncoder.TAGs"/> structure is required to write the CART chunk to the file.
            <para>When writing a BWF BEXT chunk to the file, the native tags with the prefix BWF are being used.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWAV.WAV_EncoderType">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSChannelType"/> which will be supported by the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderWAV.WAV_DefaultOutputExtension">
            <summary>
            Gets or Sets the default output extension to be used by the encoder (e.g. ".wav").
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderAIFF">
            <summary>
            Encoder class implementation for the Audio Interchange File Format (AIFF) using raw PCM sample data with no real encoder.
            </summary>
            <remarks>This class uses the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_AIFF"/> encoder type.
            <para>This format supports 8-, 16- and 32-bit(IEEE float) sample data as input.</para>
            <para>Make sure to set the AIFF_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderAIFF.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>TAG writing is not supported.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
            <example>
            Manual encoding "File" To "File" in 32-bit:
            <code>
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            EncoderAIFF a = new EncoderAIFF(stream);
            a.InputFile = null;
            a.OutputFile = "test.aif";  // will be a 32-bit IEEE float file, since the stream is float
            a.Start(null, IntPtr.Zero, false);
            // do the encoding
            Utils.DecodeAllData(stream, true);
            a.Stop();
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            Dim a As New EncoderAIFF(stream)
            a.InputFile = Nothing
            a.OutputFile = "test.aif" ' will be a 32-bit IEEE float file, since the stream is float
            a.Start(Nothing, IntPtr.Zero, False)
            ' do the encoding
            Utils.DecodeAllData(stream, True)
            a.Stop()
            </code>
            Manual encoding "File" To "File" in 24-bit:
            <code>
            EncoderAIFF w = new EncoderAIFF(0);
            a.InputFile = "testIn.wav";
            a.OutputFile = "testOut.aif";
            a.WAV_BitsPerSample = 24;
            a.Start(null, IntPtr.Zero, false);
            a.Stop();
            </code>
            <code lang="vbnet">
            Dim a As New EncoderAIFF(0)
            a.InputFile = "testIn.wav"
            a.OutputFile = "testOut.aif"
            a.WAV_BitsPerSample = 24
            a.Start(Nothing, IntPtr.Zero, False)
            a.Stop()
            </code>
            "Recording" To "File" in 16-bit:
            <code>
            private RECORDPROC _recProc;
            
            // init your recording device (we use the default device)
            if ( !Bass.BASS_RecordInit(-1) )
              MessageBox.Show(this, "Bass_RecordInit error!" );
            _recProc = new RECORDPROC(RecordingHandler);
            // start recording at 44.1kHz, stereo (paused)
            int recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _recProc, IntPtr.Zero);
            if (recHandle == Bass.FALSE)
              MessageBox.Show(this, "BASS_RecordStart error!" );
            
            // setup the encoder
            EncoderAIFF a = new EncoderAIFF(recHandle);
            a.InputFile = null;
            a.OutputFile = "testrec.aif";
            a.Start(null, IntPtr.Zero, true); // start encoder paused
            ...
            // now really start recording and encoding
            a.Pause(false);
            Bass.BASS_ChannelPlay(recHandle, false);
            ...
            // your recording will be encoded until you call
            a.Stop();
            
            private bool RecordingHandler(int handle, IntPtr buffer, int length, IntPtr user)
            {
              return true;
            }
            </code>
            <code lang="vbnet">
            private RECORDPROC _recProc;
            
            ' init your recording device (we use the default device)
            If Not Bass.BASS_RecordInit(- 1) Then
              MessageBox.Show(Me, "Bass_RecordInit error!")
            End If
            _recProc = New RECORDPROC(AddressOf RecordingHandler)
            ' start recording at 44.1kHz, stereo (paused)
            Dim recHandle As Integer = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_RECORD_PAUSE, _recProc, IntPtr.Zero)
            If recHandle = Bass.FALSE Then
              MessageBox.Show(Me, "BASS_RecordStart error!")
            End If 
            
            ' setup the encoder
            Dim a As New EncoderAIFF(recHandle)
            a.InputFile = Nothing
            a.OutputFile = "testrec.aif"
            a.Start(Nothing, IntPtr.Zero, True) ' start encoder paused
            ...
            ' now really start recording and encoding
            a.Pause(False)
            Bass.BASS_ChannelPlay(recHandle, False)
            ...
            ' your recording will be encoded until you call
            a.Stop()
            
            Private Function RecordingHandler(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              Return True
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderAIFF.#ctor(System.Int32)">
            <summary>
            Creates an instance of a Audio Interchange File Format (AIFF) implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements Audio Interchange File Format (AIFF) encoding.
            <pata>This encoder might be used for streaming, since it does support STDOUT.</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderAIFF.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>E.g. returns "AIFF Encoder (BASS_CTYPE_STREAM_AIFF)".</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here the <see cref="F:Un4seen.Bass.Misc.EncoderAIFF.AIFF_EncoderType"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (e.g. ".aif"). Here the <see cref="F:Un4seen.Bass.Misc.EncoderAIFF.AIFF_DefaultOutputExtension"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.SupportsSTDOUT">
            <summary>
            AIFF does not implement STDOUT, so <see langword="false"/> is always returned.
            </summary>
            <remarks>This encoder might not be used for streaming, since it does not support STDOUT.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.EncoderCommandLine">
            <summary>
            Returns the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/>, since WAV does not use any command-line tool.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output.
            </summary>
            <remarks>This implementation evaluates the original <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelBitwidth"/> and the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelNumChans"/> in order to calculate the effective bitrate.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderAIFF.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual AIFF encoder. 
            </summary>
            <param name="proc">Must be <see langword="null"/> = no callback, since EncoderAIFF does not support STDOUT.</param>
            <param name="user">Must be <see cref="F:System.IntPtr.Zero"/>, since EncoderAIFF does not support STDOUT.</param>
            <param name="paused">Start the encoder paused? If <see langword="true"/>, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns <see langword="true"/>, if the encoder was successfully started - else <see langword="false"/> is returned.</returns>
            <remarks>This method uses the BASS_ENCODE_AIFF flag to write plain PCM sample data to a file (if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> has been specified), without an encoder.
            If no <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> has been specified (<see langword="null"/>) - nothing will actually happen.
            <para>If you have specified a file name for <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> (instead of <see langword="null"/>), a default stream using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> will be created internally and all it's data will immediately be encoded (meaning the <paramref name="paused"/> flag will have no effect),
            else the data from the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.ChannelHandle"/> will be encoded.</para>
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.Force16Bit">
            <summary>
            Always returns false, since this encoder doesn't supports this flag. The target format can be set via the <see cref="P:Un4seen.Bass.Misc.EncoderAIFF.AIFF_BitsPerSample"/> property.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderAIFF.SettingsString">
            <summary>
            Returns the string representation of the current encoder settings.
            </summary>
            <returns>The descriptive settings string.</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.AIFF_BitsPerSample">
            <summary>
            Gets or Sets the target resolution (number of bits per sample) of the AIFF file to create -
            (by default the original resolution will be used).
            </summary>
            <remarks>This property is only evaluated, if an <see cref="P:Un4seen.Bass.Misc.BaseEncoder.InputFile"/> has been specified or the BASS_CONFIG_FLOATDSP option is set!
            NOTE: In all other cases the original resolution will be used!
            <para>This property should be either 8, 16, 24 or 32.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderAIFF.AIFF_Use32BitInteger">
            <summary>
            Gets or Sets, if 32bit integer (instead of 32bit IEEE float) should be used when setting <see cref="P:Un4seen.Bass.Misc.EncoderAIFF.AIFF_BitsPerSample"/> to 32 (default is <see langword="false"/>)?
            </summary>
            <remarks>When seeting this property to <see langword="true"/> and setting the <see cref="P:Un4seen.Bass.Misc.EncoderAIFF.AIFF_BitsPerSample"/> property to 32, the 32bit integer format is used - 
            else the 32bit IEEE float is used as the default 32bit format.
            </remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderAIFF.AIFF_EncoderType">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSChannelType"/> which will be supported by the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderAIFF.AIFF_DefaultOutputExtension">
            <summary>
            Gets or Sets the default output extension to be used by the encoder (e.g. ".aif").
            </summary>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderCMDLN">
            <summary>
            Encoder class implementation for any generic Command-Line encoder tool using <see cref="N:Un4seen.Bass.AddOn.Enc"/>.
            </summary>
            <remarks>This class uses by default the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_WAV"/> encoder type (even if other types might be more propper) - so make sure to set the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_EncoderType"/> property accordingly.
            Also the <see cref="P:Un4seen.Bass.Misc.EncoderCMDLN.DefaultOutputExtension"/> is by default set to ".wav" and needs to be changed if needed (see all CMDLN_xxx properties).
            <para>Since this is a generic implementation this encoder will try to use either 32-bit float, 24-bit, 16-bit or 8-bit sample data (depending on the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.Force16Bit"/> and the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseFP_32BIT"/> or <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseFP_24BIT"/> property).
            The <see cref="F:Un4seen.Bass.AddOn.Enc.BASSEncode.BASS_ENCODE_NOHEAD"/> flags will be used, if you set the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseNOHEAD"/> flag.
            You MUST set the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Executable"/> property to the executable name you want to use. Also make sure that the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> and the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/> are configured accordingly.
            The encoder will receive, raw PCM sample data in little endian.</para>
            <para>Make sure to set the CMDLN_xxx flags before calling <see cref="M:Un4seen.Bass.Misc.EncoderCMDLN.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)"/>.</para>
            <para>This implementation uses the automatic DSP system for encoding. 
            Meaning the sending of sample data to the encoder is done automatically when you play the channel (<see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) or call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> (if it's a decoding channel).
            So there is no need to call <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Write(System.Int32,System.IntPtr,System.Int32)"/> manually!
            </para>
            <para>If you simply want to encode a physical file please also take a look to the <see cref="M:Un4seen.Bass.Misc.BaseEncoder.EncodeFile(System.String,System.String,Un4seen.Bass.Misc.BaseEncoder,Un4seen.Bass.Misc.BaseEncoder.ENCODEFILEPROC,System.Boolean,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.#ctor(System.Int32)">
            <summary>
            Creates an instance of the generic command-line encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements generic command-line encoding.
            <pata>This encoder might be used for streaming only if the <see cref="P:Un4seen.Bass.Misc.EncoderCMDLN.SupportsSTDOUT"/> property is set to true and the underlying executable does support STDOUT as well - however make sure to select a command-line tool matching your <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>!</pata>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderExists">
            <summary>
            This property return <see langword="true"/>, if the specifiec command-line tool is availabel - else <see langword="false"/>.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Eg.: returns "Generic Command-Line Encoder".</returns>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderType">
            <summary>
            Gets a value indicating the type of content. Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_EncoderType"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.DefaultOutputExtension">
            <summary>
            This return the default extension of an output file for this encoder (e.g. ".wav"). Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_DefaultOutputExtension"/> value is returned.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.SupportsSTDOUT">
            <summary>
            A command-line encoder might implement STDOUT, so here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_SupportsSTDOUT"/> value is returned.
            </summary>
            <remarks>This encoder might be used for streaming, since it might support STDOUT. 
            However, the selected command-line encoder must match the <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> implementation!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EncoderCommandLine">
            <summary>
            Returns the specified command-line string to use. Depending on the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseVBR"/> property the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/> or the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> value is evaluated and all contained macros are replaced.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.EncoderCMDLN.EffectiveBitrate">
            <summary>
            Returns the effective encoder bitrate (in kbps) of the output. Here the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Bitrate"/> value is returned.
            </summary>
            <remarks>The effective bitrate value is only needed, if the encoder is used for a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>. This member otherwise will never be really used.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.Start(Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr,System.Boolean)">
            <summary>
            This method starts the actual command-line encoder. 
            After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            </summary>
            <param name="proc">Optional callback function to receive the encoded data (only valid, if <see cref="P:Un4seen.Bass.Misc.BaseEncoder.OutputFile"/> is set to <see langword="null"/>)... <see langword="null"/> = no callback.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <param name="paused">Start the encoder paused? If <see langword="true"/>, you might use <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Pause(System.Boolean)"/> to unpause (and really start the encoder).</param>
            <returns>Returns <see langword="true"/>, if the encoder was successfully started - else <see langword="false"/> is returned.</returns>
            <remarks>This method calls <see cref="M:Un4seen.Bass.AddOn.Enc.BassEnc.BASS_Encode_Start(System.Int32,System.String,Un4seen.Bass.AddOn.Enc.BASSEncode,Un4seen.Bass.AddOn.Enc.ENCODEPROC,System.IntPtr)"/> internally!
            <para>After the encoder was started successfully the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns a valid HENCODE handle.
            If the encoder was not started successfully or was stopped <see cref="P:Un4seen.Bass.Misc.BaseEncoder.EncoderHandle"/> returns 0 (zero).</para>
            <para>If an encoder stops running prematurely, <see cref="M:Un4seen.Bass.Misc.BaseEncoder.Stop"/> should still be called to release resources that were allocated for the encoding.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderCMDLN.SettingsString">
            <summary>
            Returns the string representation of the current encoder settings.
            </summary>
            <returns>The descriptive settings string.</returns>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseNOHEAD">
            <summary>
            Gets or Sets if the encoder should be started using the NOHEAD flag.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseFP_32BIT">
            <summary>
            Gets or Sets if the encoder should be started using the FP_32BIT flag.
            </summary>
            <remarks>The <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseFP_24BIT"/> flag will only be evaluated, if this flag is not set (<see langword="false"/>).</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseFP_24BIT">
            <summary>
            Gets or Sets if the encoder should be started using the FP_24BIT flag.
            </summary>
            <remarks>If the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseFP_32BIT"/> flag is set (<see langword="true"/>) this flag will be ignored.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Executable">
            <summary>
            Gets or Sets the command-line executable name to be used with the encoder (not containing the path, e.g. "encoder.exe").
            </summary>
            <remarks>You MUST set this parameter!</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_ParamSTDOUT">
            <summary>
            Gets or sets the ${output} parameter to be used with STDOUT.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_ParamSTDIN">
            <summary>
            Gets or sets the ${input} parameter to be used with STDIN.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_EncoderType">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSChannelType"/> which will be supported by the encoder.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_DefaultOutputExtension">
            <summary>
            Gets or Sets the default output extension to be used by the encoder (e.g. ".mp3").
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_SupportsSTDOUT">
            <summary>
            Gets or Sets if the encoder supports output of the encoded data to STDOUT.
            </summary>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseVBR">
            <summary>
            Gets or Sets, if the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> or the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/> command-line string should be used.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString">
            <summary>
            Gets or Sets the constant bitrate (CBR) command-line string to be used with the encoder (not containing the executable to be used, e.g. "-b ${bps} - output.xyz").
            </summary>
            <remarks>This command-line string is used, if <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseVBR"/> is set to <see langword="false"/>.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString">
            <summary>
            Gets or Sets the variable bitrate (VBR) command-line string to be used with the encoder (not containing the executable to be used, e.g. "-b ${bps} - output.xyz").
            </summary>
            <remarks>This command-line string is used, if <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseVBR"/> is set to <see langword="true"/>.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Bitrate">
            <summary>
            Gets or Sets the effective bitrate (in kbps) for the ${bps} and ${kbps} macro to be used with the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.
            </summary>
            <remarks>Only needed when this encoder will be used for a <see cref="T:Un4seen.Bass.Misc.StreamingServer"/> or if you use the ${kbps} or ${bps} macro in <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> or <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Quality">
            <summary>
            Gets or Sets the ${quality} macro value to be used in the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.
            </summary>
            <remarks>Might e.g. contain the encoding quality level to be used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Mode">
            <summary>
            Gets or Sets the ${mode} macro value to be used in the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.
            </summary>
            <remarks>Might e.g. contain the stereo mode (joint-stereo, mono, dual channel, independent stereo etc.) to be used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_Option">
            <summary>
            Gets or Sets the ${option} macro value to be used in the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.
            </summary>
            <remarks>Might e.g. contain any other optional value to be used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseA">
            <summary>
            Gets or Sets, if the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UserA"/> or the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UserB"/> macro string should be used.
            </summary>
            <remarks>If set to <see langword="true"/> the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UserA"/> macro value is used - else the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UserB"/> macro value is used.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UserA">
            <summary>
            Gets or Sets the ${user} macro value to be used in the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.
            </summary>
            <remarks>This is a general purpose macro placeholder, which is only used, if the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseA"/> property is set to <see langword="true"/>.</remarks>
        </member>
        <member name="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UserB">
            <summary>
            Gets or Sets the ${user} macro value to be used in the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_CBRString"/> resp. <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_VBRString"/>.
            </summary>
            <remarks>This is a general purpose macro placeholder, which is only used, if the <see cref="F:Un4seen.Bass.Misc.EncoderCMDLN.CMDLN_UseA"/> property is set to <see langword="false"/>.</remarks>
        </member>
        <member name="T:Un4seen.Bass.Misc.EncoderMP3">
            <summary>
            Encoder class implementation for any generic MP3 command-line encoder tool using <see cref="N:Un4seen.Bass.AddOn.Enc"/>.
            </summary>
            <remarks>This class uses by default the <see cref="F:Un4seen.Bass.BASSChannelType.BASS_CTYPE_STREAM_MP3"/> encoder type (<see cref="P:Un4seen.Bass.Misc.BaseEncoder.DefaultOutputExtension"/> is set to ".mp3").
            <para>This encoder is directly derived from <see cref="T:Un4seen.Bass.Misc.EncoderCMDLN"/> - so please take a look there for all other details.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderMP3.#ctor(System.Int32)">
            <summary>
            Creates an instance of the generic MP3 command-line encoder implementation.
            </summary>
            <param name="channel">The channel handle... a HSTREAM, HMUSIC, or HRECORD.</param>
            <remarks>Implements generic command-line encoding.
            <pata>This encoder might be used for streaming only if the <see cref="P:Un4seen.Bass.Misc.BaseEncoder.SupportsSTDOUT"/> property is set to true (which is by default the case) and the underlying executable does support STDOUT as well - however make sure to select a command-line tool matching your <see cref="T:Un4seen.Bass.Misc.StreamingServer"/>!</pata>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderMP3.SettingsString">
            <summary>
            Returns the string representation of the current encoder settings.
            </summary>
            <returns>The descriptive settings string.</returns>
        </member>
        <member name="M:Un4seen.Bass.Misc.EncoderMP3.ToString">
            <summary>
            Returns the name of the Encoder.
            </summary>
            <returns>Eg.: returns "Generic MP3 Encoder".</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.BaseDSP">
            <summary>
            Base class for all user defined DSP classes (e.g. <see cref="T:Un4seen.Bass.Misc.DSP_PeakLevelMeter"/>, <see cref="T:Un4seen.Bass.Misc.DSP_Gain"/> or your own DSP implementations).
            </summary>
            <remarks>This base class is not intended for direct use, but defines all abstract properties and methods which needs to be implemented by an actual DSP class.
            A derived class must implement: <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>.
            <para>The properties <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelBitwidth"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelSampleRate"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelNumChans"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPProc"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsAssigned"/>
            as well as the methods <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>, <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> and <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> have been already implemented.</para>
            <para>You might use this base class to derive your own DSP implementations.
            In this case a derived class must implement the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> method and might override the <see cref="M:Un4seen.Bass.Misc.BaseDSP.OnChannelChanged"/> method (e.g. in order to reset an internal buffer etc.).</para>
            <para>The whole DSP framework is based on the standard BASS DSP functionality.
            So as with all DSP's - the DSP is automatically freed whenever the source stream is freed, e.g. when calling <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> or when using the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_AUTOFREE"/> flag.</para>
            </remarks>
            <example>
            This example shows a basic implementation of an own DSP class:
            <code>
            public class DSP_MyDsp : BaseDSP
            {
            	// First Constructor overload
            	public DSP_MyDsp() : base()
            	{
            	}
            	// Second Constructor overload
            	public DSP_MyDsp(int channel, int priority) : base(channel, priority, 0)
            	{
            	}
            	
            	// example implementation of the DSPCallback method
            	unsafe public override void DSPCallback(int handle, int channel, IntPtr buffer, int length, IntPtr user)
            	{
            		if (IsBypassed)
            			return;
            			
            		if (ChannelBitwidth == 16)
            		{
            			// process the data
            			short *data = (short*)buffer;
            			for (int a = 0; a &lt; length/2; a++)
            			{
            				// your work goes here (16-bit sample data)
            			}
            		}
            		else if (ChannelBitwidth == 32)
            		{
            			// process the data
            			float *data = (float*)buffer;
            			for (int a = 0; a &lt; length/4; a++)
            			{
            				// your work goes here (32-bit sample data)
            			}
            		}
            		else
            		{
            			// process the data
            			byte *data = (byte*)buffer;
            			for (int a = 0; a &lt; length; a++)
            			{
            				// your work goes here (8-bit sample data)
            			}
            		}
            		// if you have calculated UI relevant data you might raise the event
            		// else comment out the following line
            		RaiseNotification();
            	}
            	
            	public override void OnChannelChanged()
            	{
            		// override this method if you need to react on channel changes
            		// e.g. usefull, if an internal buffer needs to be reset etc.
            	}
            	
            	public override string ToString()
            	{
            		return "My DSP";
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.#ctor">
            <summary>
            Default constructor. Not assigning a DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            <para>If an instance of a derived class s being disposed, an already assigned DSP will automatically be removed from the channel.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Default constructor, which already evaluates the channel handle and assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>If an instance of a derived class s being disposed, an already assigned DSP will automatically be removed from the channel.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel used.</exception>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="E:Un4seen.Bass.Misc.BaseDSP.Notification">
            <summary>
            Event handler used to notify that the DSP has processed some data.
            </summary>
            <remarks>This event might be used to get notified, that the DSP has processed some data and that for example a UI needs to be updated in order to reflect this.
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            <para>In a DSP implementation you need to call <see cref="M:Un4seen.Bass.Misc.BaseDSP.RaiseNotification"/> in order to fire this event.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle">
            <summary>
            Gets or Sets the channel that the DSP is being applied to.
            </summary>
            <remarks>If the DSP has already been assigned, changing the channel will automatically reassign the DSP to the new channel.
            <para>A DSP will automatically be removed, if the channel is being freed.
            Therefore this member might return a channel handle which is not active anymore. You might use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> to check, if a channel is still active.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel used.</exception>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelInfo">
            <summary>
            Gets the <see cref="T:Un4seen.Bass.BASS_CHANNELINFO"/> of the assigned <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelBitwidth">
            <summary>
            This property returns the actual bitwidth of the sample data of the channel (e.g. 8, 16, 32).
            </summary>
            <remarks>BASS supports 8/16/32-bit sample data, so if a WAV file, for example, uses another sample resolution, it'll have to be converted by BASS.
            This bitwidth represents the bitwidth which is used by BASS (e.g. in a DSP callback delegate) and does not represent the original bitwidth of the channel.
            The bitwidth used by BASS is determined how the underlying channel handle was created (e.g. using <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreateFile(System.String,System.Int64,System.Int64,Un4seen.Bass.BASSFlag)"/> with the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_8BITS"/> or <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> flag)
            and if the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> option has been set.
            If non of the above was used, by default 16 bits per sample are used.
            <para>However this bitwidth is the bitwidth in use when sending sample data to the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>.
            If for example the <see cref="F:Un4seen.Bass.BASSConfig.BASS_CONFIG_FLOATDSP"/> or the <see cref="F:Un4seen.Bass.BASSFlag.BASS_SAMPLE_FLOAT"/> option have been used, the DSP would receive 32-bit float samples.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelSampleRate">
            <summary>
            This property returns the actual sample rate in Hz of the sample data BASS is using with the channel (e.g. 44100).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.ChannelNumChans">
            <summary>
            This property returns the actual number of channles of the sample data BASS is using with the channel (e.g. 1=mono, 2=stereo, etc.).
            </summary>
            <remarks>BASS supports multi-channel sample data, so make sure the actual DSP implementation supports multi-channel too.
            If the DSP does not support multi-channel make sure that you are using non-multi-channel handles only.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority">
            <summary>
            Sets or reassigns the priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.
            </summary>
            <remarks>If the DSP has already been assigned, changing the priority will immediately reassig the DSP to the new priority.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.User">
            <summary>
            Gets or Sets the value of the user instance data to pass to the callback function (see <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.DSPHandle">
            <summary>
            Returns the actual DSP handle (or 0, if the DSP has not been assigned to the channel).
            </summary>
            <remarks>Caution: This member is not intended for direct use - but has more of an informal character.
            <para>A DSP will automatically be removed, if the channel is being freed.
            Therefore this member might return a dsp handle which is not active anymore. You might use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> to check, if a channel is still active.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.DSPProc">
            <summary>
            Returns the actual <see cref="T:Un4seen.Bass.DSPPROC"/> (callback delegate) which is used by the DSP.
            </summary>
            <remarks>This callback delegate is being created when a DSP instance is being created.
            <para>Caution: This member is not intended for direct use - but has more of an informal character.
            However, you might use the delegate, if you want to manually make use of the implementation of the DSP, but want to handle the entire DSP assignement yourself.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed">
            <summary>
            Returns if the DSP is currently bypassed (<see langword="true"/>=bypass).
            </summary>
            <remarks>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> to change the current bypass mode.
            <para>Bypassing a DSP is not done automatically! 
            The actual implementation of the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> method in a derived class must support this feature (e.g. the <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> member has to be evaluated there).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.BaseDSP.IsAssigned">
            <summary>
            Is the DSP assigned to an active channel? (<see langword="true"/>=assigned, <see langword="false"/>=not assigned).
            </summary>
            <remarks>This property will also return <see langword="false"/>, if the underlying <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> has been freed in the meantime.
            In this case the DSP will be removed automatically.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Start">
            <summary>
            Assigns the DSP to the channel (actually starts using the DSP).
            </summary>
            <returns><see langword="true"/>, if started successfully - else <see langword="false"/> will be returned.</returns>
            <remarks>
            <para>Depending on which constructor you used to create an instance of the DSP, this method might have already being called.</para>
            <para>Calling this method again, if the DSP has already being assigned will have no effect. You must call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> before you can call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> again.</para>
            <para>Internally this method simply calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> and thereby uses the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPProc"/>, <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> members.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.Stop">
            <summary>
            Stops (removes) the DSP from the channel.
            </summary>
            <returns><see langword="true"/>, if the DSP was removed successfully - else <see langword="false"/> will be returned (e.g. in case that the DSP has already been removed).</returns>
            <remarks>
            <para>A DSP will automatically be removed, if the channel is being freed. So there is not an explicit need of calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> at the end of stream.
            However, the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPHandle"/> might return invalid handle in such case. You might use <see cref="M:Un4seen.Bass.Bass.BASS_ChannelIsActive(System.Int32)"/> to check, if a channel is still active.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)">
            <summary>
            Sets the Bypass mode.
            </summary>
            <param name="bypass">Bypass?</param>
            <remarks>If Bypass is set, a DSP function should actually return immediately and not process the sample data. 
            You might check the actual Bypass mode with the <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> property.
            <para>If the DSP function should be bypassed, this needs to be implemented in the <see cref="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> function of a derived class.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnChannelChanged">
            <summary>
            This method will be called every time the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> changed.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to reflect a channel change, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnStarted">
            <summary>
            This method will be called every time the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> method had been called.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to perform some addition setup calculations whenever the DSP was started, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnStopped">
            <summary>
            This method will be called every time the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method had been called.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to perform some addition cleanup calculations whenever the DSP was stopped, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.OnBypassChanged">
            <summary>
            This method will be called every time the <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> method had been called.
            </summary>
            <remarks>In the default implementation this method does nothing. 
            It might be overridden in a derived class to reflect a change of the bypass status, e.g. to reset an internal buffer etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which needs to be implemented in the derived class.
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>A DSP function should obviously be as quick as possible... playing streams, MOD musics and other DSP functions can not be processed until it has finished.
            <para>You might use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelBitwidth"/> to determine if the sample data received is 8-, 16- or 32-bit. <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelNumChans"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelSampleRate"/> might be used to retrieve additional information about the channel being used.</para>
            <para>Make sure to handle the <see cref="P:Un4seen.Bass.Misc.BaseDSP.IsBypassed"/> property in order to support a bypass feature.</para>
            <para>Some functions can cause problems if called from within a DSP (or stream) function. Do not call these functions from within a DSP callback:</para>
            <para><see cref="M:Un4seen.Bass.Bass.BASS_Stop"/>, <see cref="M:Un4seen.Bass.Bass.BASS_Free"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicLoad(System.String,System.Int64,System.Int32,Un4seen.Bass.BASSFlag,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.STREAMPROC,System.IntPtr)"/> (or any other stream creation functions).</para>
            <para>Also, do not call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelRemoveDSP(System.Int32,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_ChannelStop(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_MusicFree(System.Int32)"/>, <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/> with the same channel handle as received by the callback.</para>
            <para>
            It is clever to NOT alloc buffer data (e.g. a float[]) everytime within the callback method, since ALL callbacks should be really fast!
            And if you would do a 'float[] data = new float[]' every time here...the GarbageCollector would never really clean up that memory.
            Sideeffects might occure, due to the fact, that BASS will call this callback too fast and too often...you might also declare the callback function as 'unsafe' and use native pointer assignements for fast processing.
            However, this is not always the case, so in most examples it'll work just fine - but if you got problems - try moving any memory allocation things outside any callbacks.
            </para>
            <para>In a derived class you might call <see cref="M:Un4seen.Bass.Misc.BaseDSP.RaiseNotification"/> at the end of your processing, in order to fire the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/>.
            By doing so all subscribers will get notified, that the DSP processing has been done - e.g. in order to update a UI thread.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.RaiseNotification">
            <summary>
            Fires the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event.
            </summary>
            <remarks>Call this method to fire the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event.
            <para>This event might be used to notified the subscriber, that the DSP has processed some data and that for an example a UI needs to be updated in order to reflect this.
            However, if a DSP implementation does not have any UI relevant data to show, there will be no need to call this method in your DSP implementation and can simply be omitted.</para>
            <para>Note: On Windows this implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.
            On other platforms it might be invoked from within the DSP thread!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.BaseDSP.ToString">
            <summary>
            Returns the name of the DSP implementation.
            </summary>
            <returns>Returns the name of the DSP implementation.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_PeakLevelMeter">
            <summary>
            Peak Level Meter DSP.
            </summary>
            <remarks>Calculates the volume (amplitude) of the channel signal in volts or dB.
            <para>The DSP automatically converts 8-, 16- or 32-bit sample data accordingly.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>The peak levels (Left channel=<see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL"/> and Right channel=<see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR"/>) are integer values between 0 (-inf.dB) and 32768 (0dB) - or higher, if the channel is floating-point.
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL_dBV"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR_dBV"/> properties, if you want these integer peak values already converted into dBV values (to a reference voltage of 1.0).</para>
            </remarks>
            <example>
            Set up a PeakLevelMeter DSP on a recording channel:
            <code>
            private DSP_PeakLevelMeter _plm;
            public delegate void UpdatePeakMeterCallback();
            ...
            Bass.BASS_RecordInit(-1);
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, _recProc, 0);
            ...
            // set up a ready-made DSP (here the PeakLevelMeter)
            _plm = new DSP_PeakLevelMeter(_recHandle, 1);
            _plm.CalcRMS = true;
            _plm.Notification += new EventHandler(UpdatePeakMeterDisplay);
            ...
            private void UpdatePeakMeterDisplay(object sender, EventArgs e)
            {
            	this.progressBarRecL.Value = _plm.LevelL;
            	this.progressBarRecR.Value = _plm.LevelR;
            	this.labelRMS.Text = String.Format( "RMS: {0:#00.0} dB - AVG: {1:#00.0} dB - Peak: {2:#00.0} dB", 
            				_plm.RMS_dBV, 
            				_plm.AVG_dBV, 
            				Math.Max(_plm.PeakHoldLevelL_dBV, _plm.PeakHoldLevelR_dBV) );
            }
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.#ctor">
            <summary>
            Creates a new instance of the PeakMeterLevel DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the PeakMeterLevel DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL">
            <summary>
            Returns the current level signal (in linear voltage steps) of the left-channel as an integer value (between 0 and 32768, or above, if a floating-point channel was selected).
            </summary>
            <remarks>The voltage steps are between 0 and 32768 or above.
            Meaning a level signal of 1.0 volt is equivalent to a value of 32768 which means 0 dBV. A level signal of 0.0 volt is equivalent to 0 which means -Infinity dBV (-0.5 volt is approx. 16384 as an integer value or -6 dbV).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL">
            <summary>
            Returns the peak level signal (in linear voltage steps) of the left-channel since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelL_dBV">
            <summary>
            Returns the current level signal of the left-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected).
            </summary>
            <remarks>The reference voltage for dBV is exactly 1.0 volt.
            <para>Meaning a level signal of 0.0 dbV is equivalent to 1.0 volt or a level signal of -Infinity dBV is equivalent to 0.0 volt (and -6 dBV is approx. -0.5 volt).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL_dBV">
            <summary>
            Returns the peak level signal of the left-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected) since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR">
            <summary>
            Returns the current level signal (in linear voltage steps) of the right-channel as an integer value (between 0 and 32768, or above, if a floating-point channel was selected).
            </summary>
            <remarks>The voltage steps are between 0 and 32768 or above.
            Meaning a level signal of 1.0 volt is equivalent to a value of 32768 which means 0 dBV. A level signal of 0.0 volt is equivalent to 0 which means -Infinity dBV (-0.5 volt is approx. 16384 as an integer value or -6 dbV).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR">
            <summary>
            Returns the peak level signal (in linear voltage steps) of the right-channel since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.LevelR_dBV">
            <summary>
            Returns the current level signal of the right-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR_dBV">
            <summary>
            Returns the peak level signal of the right-channel as a dBV value (between -Infinity and 0.0 - or above, if a floating-point channel was selected) since the last channel change or <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/>.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS">
            <summary>
            Gets or Sets if the AVG and RMS values should be calculated.
            </summary>
            <remarks>The AVG (average value) and RMS (root mean square error) might be retrieved using the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS"/> property.
            If CalcRMS is turned off (<see langword="false"/>, default) the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS"/> property would always return 0.0.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG">
            <summary>
            Returns the current AVG value (average, in linear voltage steps, between 0...32768...N) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (<see langword="false"/>, default) this property would always return 0.0.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn AVG calculation on or off.
            <para>The AVG is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG_dBV">
            <summary>
            Returns the current AVG value (average, in dBV) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (<see langword="false"/>, default) this property would always return -Infinity.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn AVG calculation on or off.
            <para>The reference voltage for dBV is exactly 1.0 volt.</para>
            <para>The AVG is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS">
            <summary>
            Returns the current RMS value (root mean square, in voltage steps, between 0...32768...N) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (<see langword="false"/>, default) this property would always return 0.0.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn RMS calculation on or off.
            <para>The RMS is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS_dBV">
            <summary>
            Returns the current RMS value (root mean square, in dBV) of the signal.
            </summary>
            <remarks>If CalcRMS is turned off (<see langword="false"/>, default) this property would always return -Infinity.
            Use <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.CalcRMS"/> to turn RMS calculation on or off.
            <para>The reference voltage for dBV is exactly 1.0 volt.</para>
            <para>The RMS is calculated based on the samples received in each DSP call.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.UpdateTime">
            <summary>
            Gets or Sets the update time in seconds (default is 0.1 = 100ms, max. is 60 seconds) which is the timespan being used to measure RMS and PeakLevels and is also used for Notification trigges.
            </summary>
            <remarks>This timespan controls the following:
            <para>1. How often the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event should be raised.</para>
            <para>2. How many samples should be used to calculate the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.RMS"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.AVG"/> values.</para>
            <para>3. How many samples should be used to calculate the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR"/> values.</para>
            <para>If you set the value to 0.0 (zero) immediate update is triggered, meaning with each DSP processing step the above is being triggered/calculated.</para>
            <para>Depending on what you want to do, good values are between 0.02 (20ms, realtime), 0.08 (80ms, user-interface) and 0.5 (500ms, RMS).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.OnChannelChanged">
            <summary>
            Resets the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR"/> values when a channel change occurred.
            </summary>
            <remarks>If you want to reset the peak hold values more ofen, call the <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/> method manually.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold">
            <summary>
            Resets the <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelL"/> and <see cref="P:Un4seen.Bass.Misc.DSP_PeakLevelMeter.PeakHoldLevelR"/> values when a channel change occurred.
            </summary>
            <remarks>If you want to reset the peak hold values more ofen, call the <see cref="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ResetPeakHold"/> method manually.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the peak level calculation. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_PeakLevelMeter.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_Gain">
            <summary>
            Gain DSP (amplification).
            </summary>
            <remarks>Amplifies the channel signal by a given factor (either specified as a double <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> factor or in dB via the <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV"/> property).
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>The gain to be applied is defined via <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> (factor, Min.: 0.0, Max.: 1024.0, no amplification at a value of 1.0) or <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV"/> (dB, Min.: -Infinity, Max.: +60, no amplification at a value of 0.0).</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.#ctor">
            <summary>
            Creates a new instance of the Gain DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Gain DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.Gain">
            <summary>
            Gets or Sets the amplification level (factor, Min.: 0.0, Max.: 1024.0, no amplification at 1.0).
            </summary>
            <remarks>The sample data is actually multiplied by this factory. 
            <para>Values between 0.0 and less than 1.0 will actually be an attenuation of the signal level.</para>
            <para>Values above 1.0 will actually be an amplification of the signal level, whereas a value of exactly 1.0 will leave the signal level unmodified.</para>
            <para>The gain can also be applied via <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV"/> (dB, Min.: -Infinity, Max.: +60, no amplification at a value of 0.0).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.Gain_dBV">
            <summary>
            Gets or Sets the amplification level (in dBV, Min.: -Infinity, Max.: +60, no amplification at a value of 0.0 dB).
            </summary>
            <remarks>Using this property will actually convert the specified dB value into a factor (see <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/>) internally. 
            The sample data is then multiplied by this factory. The reference voltage for dBV is exactly 1.0 volt.
            <para>Values between -Infinity and less than 0.0 dB will actually be an attenuation of the signal level.</para>
            <para>Values above 0.0 dB will actually be an amplification of the signal level, whereas a value of exactly 0.0 will leave the signal level unmodified.</para>
            <para>The gain can also be applied directly via <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> (factor, Min.: 0.0, Max.: 1024.0, no amplification at 1.0).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is <see langword="false"/>).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the <see cref="P:Un4seen.Bass.Misc.DSP_Gain.Gain"/> factor might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_Gain.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Gain.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_Gain.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_Gain.UseDithering"/> property has been set to <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the gain amplification. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Gain.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_Pan">
            <summary>
            Stereo Panning DSP (balance).
            </summary>
            <remarks>A stereo Panning DSP. Panning is controlled via the <see cref="P:Un4seen.Bass.Misc.DSP_Pan.Pan"/> property.
            <para>Note: This DSP only works on streams with a multiple of 2 channels (e.g. stereo, quadro, etc.).</para>
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.#ctor">
            <summary>
            Creates a new instance of the Panning DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Panning DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Pan.Pan">
            <summary>
            Defines the panning factor between -1.0 (pan left) and 1.0 (pan right), center is at 0.0 (default).
            </summary>
            <remarks>Assigning values outside the valid range [-1..1] will be capped automatically.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Pan.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is <see langword="false"/>).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the <see cref="P:Un4seen.Bass.Misc.DSP_Pan.Pan"/> factor might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_Pan.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Pan.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_Pan.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_Pan.UseDithering"/> property has been set to <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the panning. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Pan.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_Mono">
            <summary>
            Mono DSP (converts a stereo signal to a mono signal).
            </summary>
            <remarks>A stereo to mono DSP.
            <para>Note: This DSP only works on streams with a multiple of 2 channels (e.g. stereo, quadro, etc.).</para>
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.#ctor">
            <summary>
            Creates a new instance of the Mono DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Mono DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Mono.Invert">
            <summary>
            Gets or Sets, if the stereo signal should be inverted (forces inverted stereo information to be removed - default is <see langword="false"/>).
            </summary>
            <remarks>Forcing to remove any stereo information which often results in a kind of karaoce effect. Also might be used, if there is an inverted phase in the stereo signal, if a mono signal had been recorded in stereo.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Mono.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is <see langword="false"/>).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the mono calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_Mono.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_Mono.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_Mono.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_Mono.UseDithering"/> property has been set to <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the mono conversion. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_Mono.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_StereoEnhancer">
            <summary>
            Stereo Enhancer DSP (actually also removes mono signals).
            </summary>
            <remarks>A simple stereo enhancer. Use the <see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WideCoeff"/> property to contol the wideness of the stereo effect and the <see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WetDry"/> property to control how much the effect should impact the original signal.
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.#ctor">
            <summary>
            Creates a new instance of the Stereo Enhancer DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Stereo Enhancer DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WideCoeff">
            <summary>
            Gets or Sets the stereo wide (coefficient) controling the stereo enhancement between 0.0 (narrow, mono signal) and 10.0 (wide, enhanced stereo signal) - default is 2.0.
            </summary>
            <remarks>A values of 0.0 will result in a narrow mono signal and a value of 1.0 in a original stereo, whereas values above 1.0 will provide an enhanced wide stereo signal.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.WetDry">
            <summary>
            Gets or Sets the Wet/Dry ratio between 0.0 (dry, unprocessed signal only) and 1.0 (wet, processed signal only) - default is 0.5.
            </summary>
            <remarks>This property defines how much of the effect signal will be mixed into the original signal.
            <para>A values of 0.0 means, that only the dry (unprocessed, original) signal is used. A value of 1.0 means, that only the wet (processed) signal is used.</para>
            <para>If you assign values outside this range they will actually be capped to [0.0...1.0].</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is <see langword="false"/>).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the effect calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_StereoEnhancer.UseDithering"/> property has been set to <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the stereo enhancement. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StereoEnhancer.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_IIRDelay">
            <summary>
            IIR Delay Filter DSP.
            </summary>
            <remarks>An IIR Delay filer (flexible-time, non-sample quantized delay). Use the <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.Delay"/> resp. the <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.DelaySeconds"/> property to control the delay time. The <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.WetDry"/> and <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.Feedback"/> properties conrol the ratio between the original signal and the processed effect signal as well as the ratio of the processed delay which will be mixed into the delay buffer.
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.#ctor(System.Single)">
            <summary>
            Creates a new instance of the IIR Delay Filter DSP, not assigning the DSP yet.
            </summary>
            <param name="maxDelay">The maximum delay buffer size in seconds.</param>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Creates a new instance of the IIR Delay Filter DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <param name="maxDelay">The maximum delay buffer size in seconds (between 0.001 and 60.0).</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.WetDry">
            <summary>
            Gets or Sets the Wet/Dry ratio between 0.0 (dry, unprocessed signal only) and 1.0 (wet, processed signal only) - default is 0.5.
            </summary>
            <remarks>This property defines how much of the effect signal will be mixed into the original signal.
            <para>A values of 0.0 means, that only the dry (unprocessed, original) signal is used. A value of 1.0 means, that only the wet (processed) signal is used.</para>
            <para>If you assign values outside this range they will actually be capped to [0.0...1.0].</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.Feedback">
            <summary>
            Gets or Sets the feedback factor of the processed signal between 0.0 (none) and 1.0 (full) which should be stored in the delay buffer - default is 0.5.
            </summary>
            <remarks>This property defines how much of the processed signal will be feed back to the delay buffer.
            <para>A values of 0.0 means, that only the original signal is used and stored in the delay buffer. 
            A value of 1.0 means, that only the processed signal is used and stored in the delay buffer.</para>
            <para>If you assign values outside this range they will actually be capped to [0.0...1.0].</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.Delay">
            <summary>
            Gets or Sets the Delay in number of samples (default is 4096).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.DelaySeconds">
            <summary>
            Gets or Sets the Delay in seconds (e.g. 0.01 for 10ms - between 0.0 and 60.0).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Preset_Default">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Preset_Metallic">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Preset_Echo">
            <summary>
            Sets the instance members to a preset.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.Reset">
            <summary>
            Clears the internal buffer.
            </summary>
            <remarks>It is a good idea to call this method whenever you change the position of the stream.
            <para>This will also automatically be called <see cref="M:Un4seen.Bass.Misc.DSP_IIRDelay.OnChannelChanged"/>.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is <see langword="false"/>).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the effect calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_IIRDelay.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_IIRDelay.UseDithering"/> property has been set to <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.OnChannelChanged">
            <summary>
            This method will be called every time the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> changed.
            </summary>
            <remarks>It resets the internal buffer.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which adds the delay effect. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_IIRDelay.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_SoftSaturation">
            <summary>
            Soft Saturation DSP (a waveshaper).
            </summary>
            <remarks>A Soft Saturation DSP doing some wave sharping. Use the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor"/> property to play around with sharping effect.
            Basically it reduces/modifies the level signal, if above the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor"/> value. If the signal is below the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor"/> the signal will be left unchanged.
            The effect is a good combination with a gain effect to minimize distortion or clipping which might happen with loud signal peaks.
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.#ctor">
            <summary>
            Creates a new instance of the Soft Saturation DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Soft Saturation DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Depth">
            <summary>
            Gets or Sets the Depth between 0.0 and 1.0 (default is 0.5, 0.0=off).
            </summary>
            <remarks>The signal will be warmed when set above 0.0.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor">
            <summary>
            Gets or Sets the Soft Saturation factor between 0.0 and 0.99998848714 (default is 0.5).
            </summary>
            <remarks>The signal will be dynamically sharped, if the signal amplitude is above this given factor.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.Factor_dBV">
            <summary>
            Gets or Sets the Soft Saturation factor in dBV between NegativeInfinity and -0.0001 (default is -6 dB).
            </summary>
            <remarks>The signal will be dynamically sharped, if the signal amplitude is above this given factor.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.UseDithering">
            <summary>
            Gets or Sets, if Dithering should be used (default is <see langword="false"/>).
            </summary>
            <remarks>
            Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dither only applies when processing 8- or 16-bit sample data (since here the mono calculation might result in computation 'errors') - for 32-bit (float) sample data dither will never be applied here.</para>
            <para>Dithering is implemented here as a triangular probability density function (TPDF), actually a "<see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.DitherFactor"/> bit triangular dither" (default is 0.7).</para>
            <para>If Dithering is disabled, the sample value will be rounded to the nearest value.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_SoftSaturation.DitherFactor">
            <summary>
            Gets or Sets the dithering bitdepth of the triangular probability density function (TPDF) - default is 0.7.
            </summary>
            <remarks>The TPDF is implemented as a "<see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.DitherFactor"/> bit triangular dither", ie. by default a "0.7 bit triangular dither" is used.
            <para>Dithering only applies here when processing 8- or 16-bit sample data and when the <see cref="P:Un4seen.Bass.Misc.DSP_SoftSaturation.UseDithering"/> property has been set to <see langword="true"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the soft saturation wave sharping. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_SoftSaturation.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_StreamCopy">
            <summary>
            Stream Copy DSP (to clone any BASS stream).
            </summary>
            <remarks>A Stream Copy DSP actually provides a synchronized clone of the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> which can for example be used to playout the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> to another device or spreakers.
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice"/> property to specify the BASS device which should be used for the stream copy.
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/> property to specify additional flags which should be used create the stream copy.
            <para>The <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handles will be linked.
            So the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> channel will be started/stopped/paused/resumed together with the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.</para>
            <para>When using with a mixer stream (see <see cref="N:Un4seen.Bass.AddOn.Mix"/>) you need to set the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.SourceMixerStream"/> and <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> properties accordingly.
            It is possible to copy either a mixer source stream or the mixer stream itself (in both cases the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.SourceMixerStream"/> handle must be set - so the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> might be equal to the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>).
            If you specify a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle will automatically be add as a new source channel to that mixer (in such case make sure to use BASS_STREAM_DECODE as a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/>).
            The <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered"/> property will define, if the final output is a buffered stream or not (so if using with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> you might still need to set this to <see langword="true"/>).
            </para>
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the original channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            <para>Internally the <see cref="T:Un4seen.Bass.Misc.DSP_StreamCopy"/> implementation uses <see cref="M:Un4seen.Bass.Bass.BASS_StreamPutData(System.Int32,System.IntPtr,System.Int32)"/> to keep the sample data of the original stream in sync with the custom created push stream (the 'StreamCopy' is created via <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/> 
            and linked to the source stream via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetLink(System.Int32,System.Int32)"/>). 
            It is not recommended to use this DSP with ASIO sources (use the <see cref="T:Un4seen.Bass.Misc.DSP_BufferStream"/> DSP instead).</para>
            <para>So when you now call the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method on the DSP_StreamCopy instance the copied-stream will be freed (but not the source stream).
            The same is true, if the GarbageCollector disposes your DSP_StreamCopy instance, since within the dispose implementation the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method will be called.</para>
            <para>However, stopping the source stream will not reset the copied-stream! Also the copied-stream will not be freed automatically, if you simply free the original stream (only the DSP will be removed from it).</para>
            <para>So when you free your source stream (or the playback ends) it is advised to call the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method on your DSP_StreamCopy method as well. So that the DSP is removed and the copied-stream will be removed/freed!
            When you need to start the original stream again, simply call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> again.</para>
            <para>Here is a full overview of all possible scenarios:</para>
            <para>A) Stopping/Releasing the source stream:
            -> call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to also free the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (and internal DSP).</para>
            <para>A.1) Restarting the same source stream:
            -> call <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> if you need to start the source stream again.</para>
            <para>A.2) Assigning a new source stream:
            -> set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> to the new source stream (see B).</para>
            <para>B) Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> of the DSP_StreamCopy instance:
            -> the current <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (if existing) will be freed automatically (and internal DSP).
            A new <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> is created automatically for the new source stream.</para>
            <para>C) Changing the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice"/> of the DSP_StreamCopy instance:
            -> the current <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (if existing) will be freed automatically.
            A new <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> is created automatically on the new device.</para>
            <para>D) Disposing of the DSP_StreamCopy instance (e.g. via GC):
            -> the current <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> (if existing) will be freed automatically (and internal DSP).</para>
            </remarks>
            <example>
            Create a copy of a regular BASS stream and play it on another BASS device:
            <code>
            private DSP_StreamCopy _streamCopy;
            ...
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            ...
            // create the original stream (on device 1)
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT);
            // start playing it...
            Bass.BASS_ChannelPlay(stream, false);
            ...
            _streamCopy = new DSP_StreamCopy();
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            // the stream to copy
            _streamCopy.ChannelHandle = stream;
            _streamCopy.DSPPriority = -1000;
            // use device 2 to create the copy on
            _streamCopy.StreamCopyDevice = 2;
            // use the exact same stream flags for the stream copy
            _streamCopy.StreamCopyFlags = _streamCopy.ChannelInfo.flags;
            _streamCopy.Start();
            </code>
            <code lang="vbnet">
            Private _streamCopy As DSP_StreamCopy
            ...
            Bass.BASS_Init(2, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            Bass.BASS_Init(1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            ...
            ' create the original stream (on device 1)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_SAMPLE_FLOAT)
            ' start playing it...
            Bass.BASS_ChannelPlay(stream, False)
            ...
            _streamCopy = New DSP_StreamCopy()
            BASS_INFO info = Bass.BASS_GetInfo()
            _streamCopy.OutputLatency = info.latency
            ' the stream to copy
            _streamCopy.ChannelHandle = stream
            _streamCopy.DSPPriority = -1000
            ' use device 2 to create the copy on
            _streamCopy.StreamCopyDevice = 2
            ' use the exact same stream flags for the stream copy
            _streamCopy.StreamCopyFlags = _streamCopy.ChannelInfo.flags
            _streamCopy.Start()
            </code>
            Create a copy of a regular BASS stream and play it on other speakers:
            <code>
            private DSP_StreamCopy _streamCopy;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_SPEAKERS, IntPtr.Zero);
            ...
            // create the original stream (using front speakers)
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_SPEAKER_FRONT);
            // start playing it...
            Bass.BASS_ChannelPlay(stream, false);
            ...
            _streamCopy = new DSP_StreamCopy();
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            // the stream to copy
            _streamCopy.ChannelHandle = stream;
            _streamCopy.DSPPriority = -1000;
            // use different speaker flags for the stream copy
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_SAMPLE_FLOAT | BASSFlag.BASS_SPEAKER_REAR;
            _streamCopy.Start();
            </code>
            <code lang="vbnet">
            Private _streamCopy As DSP_StreamCopy
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_SPEAKERS, IntPtr.Zero)
            ...
            ' create the original stream (using front speakers)
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_SPEAKER_FRONT)
            ' start playing it...
            Bass.BASS_ChannelPlay(stream, False)
            ...
            _streamCopy = New DSP_StreamCopy()
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            ' the stream to copy
            _streamCopy.ChannelHandle = stream
            _streamCopy.DSPPriority = -1000
            ' use different speaker flags for the stream copy
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_SAMPLE_FLOAT Or BASSFlag.BASS_SPEAKER_REAR
            _streamCopy.Start()
            </code>
            Create a copy of a BASSmix source mixer stream and copy it to another BASSmix mixer as a source:
            <code>
            private DSP_StreamCopy _streamCopy;
            ...
            _streamCopy = new DSP_StreamCopy();
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            _streamCopy.DSPPriority = -9000;
            ...
            // assign the copy
            _streamCopy.ChannelHandle = _mixerSourceStream; // the stream to copy
            _streamCopy.StreamCopyDevice = 0;
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_STREAM_DECODE;
            _streamCopy.SourceMixerStream = MixerStreamA;
            _streamCopy.TargetMixerStream = MixerStreamB;
            _streamCopy.IsOutputBuffered = true;
            _streamCopy.Start();
            ...
            // start playing the original source
            BassMix.BASS_Mixer_ChannelPlay(_mixerSourceStream);
            if (_streamCopy.IsAssigned)
              _streamCopy.ReSync();
            ...
            // pausing the original source
            BassMix.BASS_Mixer_ChannelPause(_mixerSourceStream);
            ...
            </code>
            <code lang="vbnet">
            Private _streamCopy As DSP_StreamCopy
            ...
            _streamCopy = New DSP_StreamCopy()
            BASS_INFO info = Bass.BASS_GetInfo();
            _streamCopy.OutputLatency = info.latency;
            _streamCopy.DSPPriority = -9000
            ...
            ' assign the copy
            _streamCopy.ChannelHandle = _mixerSourceStream ' the stream to copy
            _streamCopy.StreamCopyDevice = 0
            _streamCopy.StreamCopyFlags = BASSFlag.BASS_STREAM_DECODE
            _streamCopy.SourceMixerStream = MixerStreamA
            _streamCopy.TargetMixerStream = MixerStreamB
            _streamCopy.IsOutputBuffered = true
            _streamCopy.Start()
            ...
            ' start playing the original source
            BassMix.BASS_Mixer_ChannelPlay(_mixerSourceStream)
            If _streamCopy.IsAssigned Then
              _streamCopy.ReSync();
            End If
            ...
            ' pausing the original source
            BassMix.BASS_Mixer_ChannelPause(_mixerSourceStream)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.#ctor">
            <summary>
            Creates a new instance of the Stream Copy DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Stream Copy DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy">
            <summary>
            Gets the copied BASS stream (the created custom push stream).
            </summary>
            <remarks>Note: The <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handles will be linked.
            So the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> channel will be started/stopped/paused/resumed together with the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            <para>Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice"/> property to specify the BASS device which should be used for the stream copy. Use the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/> property to specify additional flags which should be used create the stream copy.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags">
            <summary>
            Gets or Sets the <see cref="T:Un4seen.Bass.BASSFlag"/> flags which should be used to create the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/>.
            </summary>
            <remarks>Note: Setting the stream copy flags while the DSP_StreamCopy is already assigned will automatically (re)start it.
            <para>By default no flags are used with the stream copy, so make sure to set these flags accordingly to your scenario.
            E.g. add a BASS_STREAM_DECODE flag, if you want to create a decoding copy which you might add to a mixer stream.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyDevice">
            <summary>
            Gets or Sets the BASS device, which should be used for the stream copy.
            </summary>
            <remarks>Note: Setting the BASS device while the DSP_StreamCopy is already assigned will automatically (re)start it.
            By default the current device is being used.
            <para>Make also sure, that the BASS device has been initializes (see <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>) before.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.OutputLatency">
            <summary>
            Gets or Sets the output latency in milliseconds (default = 0).
            </summary>
            <remarks>The output latency compensates for an additional delay of the DirectSound buffer.
            You should initialize this property with the <see cref="M:Un4seen.Bass.Bass.BASS_GetInfo(Un4seen.Bass.BASS_INFO)">BASS_INFO.latency</see> member when using with a buffered output.</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered">
            <summary>
            Gets or Sets, if the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> should be buffered or not (default is <see langword="true"/>).
            </summary>
            <remarks>If set to <see langword="true"/>, the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> will be (pre)buffered with the data available from the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>. 
            This option is useful, if you want to use this instance with a buffered output stream.
            If set to <see langword="false"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> will not be (pre)buffered, which is usefull when used with unbuffered outputs (e.g. ASIO).
            <para>Note: Setting this member while the DSP_StreamCopy is already assigned will automatically (re)start it.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.SourceMixerStream">
            <summary>
            Gets or Sets the mixer handle of the mixer from which you are cloning (see <see cref="N:Un4seen.Bass.AddOn.Mix">BASSmix</see> addon).
            </summary>
            <remarks>
            It is possible to copy either a mixer's source stream or the mixer stream itself.
            In both cases you must specify the mixers channel handle - so if you clone the mixer itself the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> will be equal to this property.
            If you specify a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle will automatically be add as a new source channel to that mixer (in such case make sure to use BASS_STREAM_DECODE as a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/>).
            The <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered"/> property will define, if the final output is a buffered stream or not (so if using with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> you might still need to set it to <see langword="true"/>).
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream">
            <summary>
            Gets or Sets the mixer handle of the mixer to which the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle should be added (see <see cref="N:Un4seen.Bass.AddOn.Mix">BASSmix</see> addon).
            </summary>
            <remarks>
            If you specify a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> handle will automatically be add as a new source channel to that mixer 
            (the BASS_STREAM_DECODE flag will automatically be added to the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopyFlags"/>).
            The <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.IsOutputBuffered"/> property will define, if the final output is a buffered stream or not (so if using with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> you might still need to set it to <see langword="true"/>).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.ReSync">
            <summary>
            Re-Synchronizes the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> with the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> when using BASSmix mixer channels.
            </summary>
            <remarks>
            Call this method right after you unpaused or start playing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, and if you are using this instance with a <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.TargetMixerStream"/> in order to resync the stream copy after it was paused.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnChannelChanged">
            <summary>
            Occures when the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> has been changed. 
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnBypassChanged">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> method was called.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnStarted">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> method was called.
            Actually creates the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> custom push stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.OnStopped">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method was called.
            Actually frees the <see cref="P:Un4seen.Bass.Misc.DSP_StreamCopy.StreamCopy"/> custom stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the stream copy operation. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_StreamCopy.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Misc.DSP_BufferStream">
            <summary>
            Stream Buffer DSP (to clone a BASS stream's current sample data to a decoding stream).
            </summary>
            <remarks>A Stream Buffer DSP actually provides a synchronized clone of the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>'s sample data in a new decoding channel which can for example be used to get FFT or level data. 
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> decoding channel with the <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> methods to do retrieve the cloned sample data.
            This DSP will always provide a decoding channel (<see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/>).
            <para>The DSP automatically handles 8-, 16- or 32-bit sample data accordingly. 8- and 16-bit sample data will be clipped if needed, 32-bit floating-point values will not be clipped.
            Note: The channel flags of the <seealso cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> being used are actually the same as from the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, but if you have FLOATDSP enabled the FLOAT flag will be added automatically.</para>
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).
            Changing the <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> when the DSP is already assigned will automatically reassign the DSP.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> property to change the channel assignment at any time. If the DSP has already been assigned, the DSP will immediately be reassigned to the new channel.</para>
            <para>Use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> property (which represents a custom decoding stream) to get the level or FFT data from it. 
            If the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> is attached to a buffered output stream (e.g. via BASSmix to a mixer stream) there will be a delay due to the additional output buffer. 
            Use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.OutputHandle"/> property in order to compensate for that (or leave to it's default 0 value in order to simply use a non-synchronized direct buffer - in such case the internal buffer will return the data as being heard).</para>
            <para>In addition you might use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.IsOutputBuffered"/> property to specify, if the created <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> will be used with a buffered output stream. 
            In such case the decoding <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> position will be aligned to the output buffer (default is <see langword="true"/>).</para>
            <para>By default the internal buffer size is determined from the current BASS_CONFIG_BUFFER setting. 
            However, that might not always be correct, since the buffer size must also be equal to the one used with the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            So you might change that using the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBuffer"/> property.</para>
            <para>NOTE: This DSP does NOT support the <see cref="E:Un4seen.Bass.Misc.BaseDSP.Notification"/> event!</para>
            </remarks>
            <example>
            Create an exact shadow copy of a decoding stream:
            <code>
            private DSP_BufferStream _bufferStream;
            ...
            // create a mixer outout stream
            _mixer1 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(_mixer1, false);
            _mixer2 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(_mixer2, false);
            // create a source stream and add it to the mixer1
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT | 
                                                                  BASSFlag.BASS_STREAM_DECODE);
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _stream, BASSFlag.BASS_DEFAULT);
            ...
            // create a clone of the source stream to add it to mixer2
            _bufferStream = new DSP_BufferStream();
            _bufferStream.ChannelHandle = _stream; // the stream to copy
            _bufferStream.DSPPriority = -4000;
            _bufferStream.Start();
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _bufferStream.BufferStream, BASSFlag.BASS_DEFAULT);
            </code>
            <code lang="vbnet">
            Private _bufferStream As DSP_BufferStream
            ...
            ' create a mixer outout stream
            _mixer1 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(_mixer1, False)
            _mixer2 = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(_mixer2, False)
            ' create a source stream and add it to the mixer1
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT Or 
                                                                  BASSFlag.BASS_STREAM_DECODE)
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _stream, BASSFlag.BASS_DEFAULT)
            ...
            ' create a clone of the source stream to add it to mixer2
            _bufferStream = New DSP_BufferStream()
            _bufferStream.ChannelHandle = _stream ' the stream to copy
            _bufferStream.DSPPriority = - 4000
            _bufferStream.Start()
            BassMix.BASS_Mixer_StreamAddChannel(_mixer1, _bufferStream.BufferStream, BASSFlag.BASS_DEFAULT)
            </code>
            Create a buffered stream copy to sync a FFT or GetLevel call:
            <code>
            private DSP_BufferStream _bufferStream;
            ...
            // create a mixer outout stream
            _mixer = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT);
            Bass.BASS_ChannelPlay(BASSFlag.BASS_DEFAULT, false);
            // create a source stream and add it to the mixer
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT | 
                                                                  BASSFlag.BASS_STREAM_DECODE);
            BassMix.BASS_Mixer_StreamAddChannel(_mixer, _stream, BASSFlag.BASS_DEFAULT);
            ...
            // create a buffer of the source stream for level and/or FFT data retrival in sync with the mixer output
            _bufferStream = new DSP_BufferStream();
            _bufferStream.ChannelHandle = _stream; // the stream to copy
            _bufferStream.OutputHandle = _mixer; // the stream to sync with (what's being heard)
            _bufferStream.DSPPriority = -4000;
            _bufferStream.Start();
            ...
            float[] fft = new float[2048];
            Bass.BASS_ChannelGetData(_bufferStream.BufferStream, fft, (int)BASSData.BASS_DATA_FFT4096);
            </code>
            <code lang="vbnet">
            Private _bufferStream As DSP_BufferStream
            ...
            ' create a mixer outout stream
            _mixer = BassMix.BASS_MIXER_StreamCreate(44100, 2, BASSFlag.BASS_DEFAULT)
            Bass.BASS_ChannelPlay(BASSFlag.BASS_DEFAULT, False)
            ' create a source stream and add it to the mixer
            _stream = Bass.BASS_StreamCreateFile(_fileName, 0, 0, BASSFlag.BASS_SAMPLE_FLOAT Or 
                                                                  BASSFlag.BASS_STREAM_DECODE)
            BassMix.BASS_Mixer_StreamAddChannel(_mixer, _stream, BASSFlag.BASS_DEFAULT)
            ...
            ' create a buffer of the source stream for level and/or FFT data retrival in sync with the mixer output
            _bufferStream = New DSP_BufferStream()
            _bufferStream.ChannelHandle = _stream ' the stream to copy
            _bufferStream.OutputHandle = _mixer ' the stream to sync with (what's being heard)
            _bufferStream.DSPPriority = - 4000
            _bufferStream.Start()
            ...
            Dim fft(2048) As Single
            Bass.BASS_ChannelGetData(_bufferStream.BufferStream, fft, CInt(BASSData.BASS_DATA_FFT4096))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.#ctor">
            <summary>
            Creates a new instance of the Stream Buffer DSP, not assigning the DSP yet.
            </summary>
            <remarks>The DSP is not automatically assigned by this constructor! You must set the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> and <see cref="P:Un4seen.Bass.Misc.BaseDSP.DSPPriority"/> manually prior to assigning the DSP.
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> to assign the DSP to the channel. Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            <para>The channel does not have to be playing to set a DSP function, they can be set before and while playing.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the Stream Buffer DSP, which already assigns the DSP (<see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> will be called automatically).
            </summary>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="priority">The priority of the DSP, which determines it's position in the DSP chain - DSPs with higher priority are called before those with lower.</param>
            <remarks>The DSP is automatically assigned by this constructor!
            <para>Use <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> to remove the DSP (you can (re)assign the DSP at any time again by calling <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream">
            <summary>
            Gets the buffered BASS stream (the created custom stream).
            </summary>
            <remarks>You might use this stream channel handle to call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> or <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> in order to retrive the FFT or level data.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStreamFlags">
            <summary>
            Gets the channel flags of the <seealso cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> being used.
            </summary>
            <remarks>The channel flags are actually being the same as from the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>, but if you have FLOATDSP enabled the FLOAT flag will be added automatically.
            In addition <seealso cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> will always be a decoding stream!</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.OutputHandle">
            <summary>
            Gets or Sets a buffered output BASS stream to synchronize the position with (0 = use a non-synchronized direct buffer).
            </summary>
            <remarks>When not setting this property (or setting to 0) the internal buffer position will not be synchronized, which means the buffer reflects the immediate sample data as received in the DSP.
            This is perfect, if you want to create an exact shadow copy (clone) of the decoding <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>. In this case use the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> member to e.g. feed it to another
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.IsOutputBuffered">
            <summary>
            Gets or Sets, if the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> should be buffered or not (default is <see langword="true"/>).
            </summary>
            <remarks>If set to <see langword="true"/>, the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> position will be buffered. This option is useful, if you want to use it with a buffered output stream.
            If set to <see langword="false"/> the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> will not be buffered, which is usefull when used with unbuffered outputs (e.g. ASIO).</remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBuffer">
            <summary>
            Gets or Sets the buffer length in milliseconds to be used (between 1 and 5000).
            </summary>
            <remarks>The buffer length needs to be as big as the BASS_CONFIG_BUFFER setting used to create the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            <para>Normally there is no need set this value, since it will be calculated accordingly to the current BASS_CONFIG_BUFFER setting.
            But this implies, that you haven't changed the BASS_CONFIG_BUFFER between the creation of the stream an using this DSP.
            So if you have changed the BASS_CONFIG_BUFFER setting in the meantime, you must provide the new BASS_CONFIG_BUFFER size.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBufferLength">
            <summary>
            Gets the buffer length in bytes which is being used.
            </summary>
            <remarks>
            This is the translated <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.ConfigBuffer"/> value.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.ClearBuffer">
            <summary>
            Clears the internal buffer (zeros all elements) and resets the buffer pointer.
            </summary>
            <remarks>
            Use this method e.g. when you paused/stoped the original <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/>.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferPosition">
            <summary>
            Gets or Sets the current buffer position in bytes.
            </summary>
            <remarks>This member is maintained automatically depending on the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.IsOutputBuffered"/> property and the current buffer state.
            So normally there is no need to modify this value. However if you have a real need you might do so.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnChannelChanged">
            <summary>
            Occures when the <see cref="P:Un4seen.Bass.Misc.BaseDSP.ChannelHandle"/> has been changed. 
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnBypassChanged">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.SetBypass(System.Boolean)"/> method was called.
            Actually clears the internal copy buffer.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnStarted">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Start"/> method was called.
            Actually creates the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> custom stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.OnStopped">
            <summary>
            Occures when the <see cref="M:Un4seen.Bass.Misc.BaseDSP.Stop"/> method was called.
            Actually frees the <see cref="P:Un4seen.Bass.Misc.DSP_BufferStream.BufferStream"/> custom stream here.
            </summary>
            <remarks>NOT for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.DSPCallback(System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            User defined DSP callback function which does the stream copy operation. Not for direct use in your application!
            </summary>
            <param name="handle">The DSP handle.</param>
            <param name="channel">Channel that the DSP is being applied to.</param>
            <param name="buffer">The buffer to apply the DSP to. The sample data is as follows: 8-bit samples are unsigned, 16-bit samples are signed, 32-bit floating-point samples range from -1 to +1 (not clipped, so can actually be outside this range).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">The user instance data given (see <see cref="P:Un4seen.Bass.Misc.BaseDSP.User"/>).</param>
            <remarks>Not for direct use in your application!</remarks>
        </member>
        <member name="M:Un4seen.Bass.Misc.DSP_BufferStream.ToString">
            <summary>
            Returns the name of the DSP.
            </summary>
            <returns>The name of the DSP.</returns>
        </member>
        <member name="T:Un4seen.Bass.Utils">
            <summary>
            BASS.NET API helper and misc. class containing some general useful methods.
            </summary>
            <remarks>Contains basically some generic converter utilities.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeByte(System.Byte,System.Byte)">
            <summary>
            Returns an unsigned byte value which is composed out of a low and high 4-bit.
            </summary>
            <param name="lowBits">The significant part for the lower 4-bit.</param>
            <param name="highBits">The significant part for the higher 4-bit.</param>
            <returns>The combined unsigned byte value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeWord(System.Byte,System.Byte)">
            <summary>
            Returns an signed Int16 value which is composed out of a low and high byte.
            </summary>
            <param name="lowByte">The significant part for the lower 8-bit.</param>
            <param name="highByte">The significant part for the higher 8-bit.</param>
            <returns>The combined signed Int16 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong(System.Int16,System.Int16)">
            <summary>
            Returns an signed Int32 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int32 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong(System.Int32,System.Int32)">
            <summary>
            Returns an signed Int32 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int32 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong64(System.Int32,System.Int32)">
            <summary>
            Returns an signed Int64 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int64 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.MakeLong64(System.Int64,System.Int64)">
            <summary>
            Returns an signed Int64 value which is composed out of a low and high value.
            </summary>
            <param name="lowWord">The significant part for the lower 16-bit.</param>
            <param name="highWord">The significant part for the higher 16-bit.</param>
            <returns>The combined signed Int64 value.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HighWord(System.Int32)">
            <summary>
            Returns the higher 16-bit of an signed Int32 as a short value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the higher significant 16-bit.</param>
            <returns>The higher 16-bit value as a short.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HighWord32(System.Int32)">
            <summary>
            Returns the higher 16-bit of an signed Int32 as an integer value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the higher significant 16-bit.</param>
            <returns>The higher 16-bit value as an integer.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HighWord(System.Int64)">
            <summary>
            Returns the higher 32-bit of an signed Int64 as an integer value.
            </summary>
            <param name="qWord">The signed Int64 value from which to extract the higher significant 32-bit.</param>
            <returns>The higher 32-bit value as an integer.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LowWord(System.Int32)">
            <summary>
            Returns the lower 16-bit of an signed Int32 as a short value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the lower significant 16-bit.</param>
            <returns>The lower 16-bit value as a short.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LowWord32(System.Int32)">
            <summary>
            Returns the lower 16-bit of an signed Int32 as an integer value.
            </summary>
            <param name="dWord">The signed Int32 value from which to extract the lower significant 16-bit.</param>
            <returns>The lower 16-bit value as an integer.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LowWord(System.Int64)">
            <summary>
            Returns the lower 32-bit of an signed Int64 as an integer value
            </summary>
            <param name="qWord">The signed Int64 value from which to extract the lower significant 32-bit.</param>
            <returns>The lower 32-bit value as an integer</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.LevelToDB(System.Int32,System.Int32)">
            <summary>
            Converts any integer level value to its dB value.
            </summary>
            <param name="level">The integer level to convert.</param>
            <param name="maxLevel">The maximum value allowed as an integer level value (e.g. use 32768 for stream levels)</param>
            <returns>The dB value (from 0dB to -infinite).</returns>
            <remarks>If you pass a level greater than maxLevel positive dB values will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.LevelToDB(System.Double,System.Double)">
            <summary>
            Converts any level value to its dB value.
            </summary>
            <param name="level">The level to convert, as a double value.</param>
            <param name="maxLevel">The maximum value allowed as a double level value (e.g. use 32768.0 for 16-bit stream levels or use 1.0 for 32-bit floating streams).</param>
            <returns>The dB value (from 0dB to -infinite).</returns>
            <remarks>If you pass a level greater than maxLevel positive dB values will be returned.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Int32)">
            <summary>
            Converts any dB level value to its level value (integer).
            </summary>
            <param name="dB">The dB level to convert.</param>
            <param name="maxLevel">The maximum value allowed as an integer level value (e.g. use 32768 for stream levels)</param>
            <returns>The integer level value (from 0 to maxLevel).</returns>
            <remarks>If you pass a positive dB value then the return value will be greater than maxLevel.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DBToLevel(System.Double,System.Double)">
            <summary>
            Converts any dB level value to its level value (double).
            </summary>
            <param name="dB">The dB level to convert.</param>
            <param name="maxLevel">The maximum value allowed as a double level value (e.g. use 1.0 for floating-point stream levels)</param>
            <returns>The double level value (from 0 to maxLevel).</returns>
            <remarks>If you pass a positive dB value then the return value will be greater than maxLevel.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.FixTimespan(System.Double)">
            <summary>
            Converts a second value as reveived by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> to a string representation.
            </summary>
            <param name="seconds">A value representing seconds.</param>
            <returns>The seconds as a string in the format: [-][d.]hh:mm:ss[.ff]</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.FixTimespan(System.Double,System.String)">
            <summary>
            Converts a second value as reveived by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelBytes2Seconds(System.Int32,System.Int64)"/> to a string representation.
            </summary>
            <param name="seconds">A value representing seconds.</param>
            <param name="format">One of the following constants:
            <list type="table">
            <item><term>HHMM</term><description></description>hours:minutes, e.g. 00:03</item>
            <item><term>HHMMSS</term><description>hours:minutes:seconds, e.g. 00:03:17</description></item>
            <item><term>MMSS</term><description>minutes:seconds, e.g. 03:17</description></item>
            <item><term>MMSSFF</term><description>minutes:seconds.milliseconds, e.g. 03:17.25</description></item>
            <item><term>MMSSFFF</term><description>minutes:seconds.milliseconds, e.g. 03:17.257</description></item>
            <item><term>MMSSF</term><description>minutes:seconds.milliseconds, e.g. 03:17.2</description></item>
            <item><term>HHMMSSFF</term><description>hours:minutes:seconds.milliseconds, e.g. 00:03:17.25</description></item>
            <item><term>HHMMSSFFF</term><description>hours:minutes:seconds.milliseconds, e.g. 00:03:17.257</description></item>
            <item><term>HHMMSSF</term><description>hours:minutes:seconds.milliseconds, e.g. 00:03:17.2</description></item>
            <item><term>SMPTE24</term><description>hours:minutes:seconds:frames (with 24fps)</description></item>
            <item><term>SMPTE25</term><description>hours:minutes:seconds:frames (with 25fps)</description></item>
            <item><term>SMPTE30</term><description>hours:minutes:seconds:frames (with 30fps)</description></item>
            <item><term>SMPTE50</term><description>hours:minutes:seconds:frames (with 50fps)</description></item>
            <item><term>SMPTE60</term><description>hours:minutes:seconds:frames (with 60fps)</description></item>
            <item><term>all others</term><description>Will be converted according to the standard DateTimeFormatInfo pattern as specified in the <paramref name="format"/> parameter.</description></item>
            </list>
            </param>
            <returns>The seconds as a string in the given format.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.FFTFrequency2Index(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the index of a specific frequency for FFT data.
            </summary>
            <param name="frequency">The frequency (in Hz) for which to get the index.</param>
            <param name="length">The FFT data length (e.g. 4096 for BASS_DATA_FFT4096).</param>
            <param name="samplerate">The sampling rate of the device or stream (e.g. 44100).</param>
            <returns>The index within the FFT data array (max. to length/2 -1).</returns>
            <remarks>Example: If the stream is 44100Hz, then 16500Hz will be around bin 191 of a 512 sample FFT (512*16500/44100).
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 a tone at 540Hz will be at: 540*4096/44100 = 50 (so a bit of the energy will be in fft[51], but mostly in fft[50]).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.FFTIndex2Frequency(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the frequency of a specific index in FFT data.
            </summary>
            <param name="index">The index within the FFT data array (half the requested).</param>
            <param name="length">The FFT data length (e.g. 4096 for BASS_DATA_FFT4096).</param>
            <param name="samplerate">The sampling rate of the device or stream (e.g. 44100).</param>
            <returns>The frequency (in Hz) which is represented by the index.</returns>
            <remarks>Example: If the stream is 44100Hz, then bin 191 of a 512 sample FFT (191*44100/512) will represent 16451Hz.
            Or, if you are using BASS_DATA_FFT4096 on a stream with a sample rate of 44100 an index of 50 will represent a tone of 538Hz: 50*44100/4096 = 50.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to an unsigned 8-bit sample.
            </summary>
            <param name="sample">The unsigned 8-bit sample to convert.</param>
            <returns>A byte array representing the converted 8-bit unsigned sample (byte[1]).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to an 8-bit unsigned sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 8-bit sample (byte[1]).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Single)">
            <summary>
            Converts a float 32-bit signed sample to an 8-bit unsigned sample.
            </summary>
            <param name="sample">The 32-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 8-bit unsigned sample (byte[1]).</returns>
            <remarks>Note: values greater 1.0 or less than -1.0 are capped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to a 16-bit signed sample.
            </summary>
            <param name="sample">The 8-bit unsigned sample to convert.</param>
            <returns>A byte array representing the converted 16-bit signed sample (byte[2]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to a 16-bit signed sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 16-bit signed sample (byte[2]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Single)">
            <summary>
            Converts a float 32-bit signed sample to a 16-bit signed sample.
            </summary>
            <param name="sample">The 32-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 16-bit signed sample (byte[2]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.
            <para>Note: values greater 1.0 or less than -1.0 are capped.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to a 24-bit signed sample.
            </summary>
            <param name="sample">The 8-bit unsigned sample to convert.</param>
            <returns>A byte array representing the converted 24-bit signed sample (byte[3]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to a 24-bit signed sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 24-bit signed sample (byte[3]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Single)">
            <summary>
            Converts a float 32-bit signed sample to a 24-bit signed sample.
            </summary>
            <param name="sample">The 32-bit signed sample to convert.</param>
            <returns>A byte array representing the converted 24-bit signed sample (byte[3]).</returns>
            <remarks>The byte order is represented in the "Little Endian" format as saved on Intel platforms (meaning lower byte first, the LSB is stored at index 0).
            If you need a "Big Endian" format just traverse the array from the back.
            <para>Note: values greater 1.0 or less than -1.0 are capped.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo32Bit(System.Byte)">
            <summary>
            Converts an 8-bit unsigned sample to a float 32-bit signed sample.
            </summary>
            <param name="sample">The 8-bit unsigned sample to convert.</param>
            <returns>A float 32-bit signed value representing the converted 8-bit unsigned sample.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo32Bit(System.Int16)">
            <summary>
            Converts a 16-bit signed sample to a float 32-bit signed sample.
            </summary>
            <param name="sample">The 16-bit signed sample to convert.</param>
            <returns>A float 32-bit signed value representing the converted 16-bit signed sample.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo32Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to a float 32-bit signed sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A float 32-bit signed value representing the converted sample.</returns>
            <remarks>The length of the byte array determines the value to convert. A length of 1 will be treated as an 8-bit sample, a length of 2 will be treated as a 16-bit sample, a length of 3 will be treated as a 24-bit sample etc.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo24Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to a 24-bit signed sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A int 24-bit signed value representing the converted sample.</returns>
            <remarks>The length of the byte array must be at least 3 (however only the last 3 elements are evaluated).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo16Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to a 16-bit signed sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A short 16-bit signed value representing the converted sample.</returns>
            <remarks>The length of the byte array must be at least 2 (however only the last 2 elements are evaluated).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleTo8Bit(System.Byte[])">
            <summary>
            Converts a byte array (in "Little Endian" notation) to an 8-bit unsigned sample.
            </summary>
            <param name="sample">The byte array sample to convert (must by in "Little Endian", low byte first notation).</param>
            <returns>A byte 8-bit unsigned value representing the converted sample.</returns>
            <remarks>The length of the byte array must be at least 1 (however only the last element is evaluated).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.Semitone2Samplerate(System.Single,System.Int32)">
            <summary>
            Calculates a new samplerate according to a shift of an original samplerate by a number of semitones.
            </summary>
            <remarks>A semitone, or half-step is a musical interval. An octave is 12 semitones wide.
            Changing a samplerate in semitones will result in faster resp. slower playback - speed.</remarks>
            <param name="origfreq">The original samplerate which should be changed.</param>
            <param name="semitones">The number of semitones for which the original samplerate should be changed (negative values will slow down, positve numbers will fasten).</param>
            <returns>The resulting samplerate which was changed by the number of given semitones.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BPM2Seconds(System.Single)">
            <summary>
            Calculates the length of one beat for a given BPM value.
            </summary>
            <param name="bpm">The BPM value to translate.</param>
            <returns>The length in seconds of one beat (or -1 if bpm is zero).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.Seconds2BPM(System.Double)">
            <summary>
            Calculates the BPM value which represented the given length for one beat.
            </summary>
            <param name="seconds">The length of one beat in seconds.</param>
            <returns>The translated BPM value (or -1 if seconds is zero).</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.ByteToHex(System.Byte[])">
            <summary>
            Converts a byte array to a hex string.
            </summary>
            <param name="buffer">The buffer to convert.</param>
            <returns>The converted hex string.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.HexToByte(System.String,System.Int32)">
            <summary>
            Converts a hex string to a byte array.
            </summary>
            <param name="hexString">The hex string to convert in the format 'XX XX XX... XX'.</param>
            <param name="length">The length of the resulting string (use -1 to convert all).</param>
            <returns>The converted byte array.</returns>
            <remarks>
            If <paramref name="length"/> specifies more elements than contained in the <paramref name="hexString"/>
            the resulting byte array will be padded by zeros.
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.Utils.Is64Bit">
            <summary>
            Returns <see langword="true"/>, if running in a 64-bit environment - else false (32-bit).
            </summary>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringAnsi(System.IntPtr)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Ansi *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="ansiPtr">The IntPtr which represents the address of the first character of the unmanaged *char (string, 8-bit).</param>
            <returns>The translated unicode string.</returns>
            <remarks>This method actually expands the original 8-bit chars to unicode 16-bit chars as required by .NET (since here each string a unicode ;-).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringAnsi(System.IntPtr,System.Int32)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Ansi *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="ansiPtr">The IntPtr which represents the address of the first character of the unmanaged *char (string, 8-bit).</param>
            <param name="len">The number of bytes to decode.</param>
            <returns>The translated unicode string.</returns>
            <remarks>This method actually expands the original 8-bit chars to unicode 16-bit chars as required by .NET (since here each string a unicode ;-).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUnicode(System.IntPtr)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Unicode *char (string, 16-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="unicodePtr">The IntPtr which represents the address of the first character of the unmanaged *char (string, 16-bit).</param>
            <returns>The translated unicode string.</returns>
            <remarks>This method actually expands the original chars to unicode 16-bit chars as required by .NET (since here each string a unicode ;-).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUnicode(System.IntPtr,System.Int32)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Unicode *char (string, 16-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="unicodePtr">The IntPtr which represents the address of the first character of the unmanaged *char (string, 16-bit).</param>
            <param name="len">The number of bytes to decode.</param>
            <returns>The translated unicode string.</returns>
            <remarks>This method actually expands the original chars to unicode 16-bit chars as required by .NET (since here each string a unicode ;-).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringLatin1(System.IntPtr,System.Int32@)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated Latin-1 (ISO-8859-1) *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="latin1Ptr">The IntPtr which represents the address of the first character of the unmanaged *char (string, Latin-1, 8-bit).</param>
            <param name="len">Returns the number of bytes read (the length of the decoded string).</param>
            <returns>The translated unicode string.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUtf8orLatin1(System.IntPtr,System.Int32@)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing either a null-terminated UTF-8 or Latin-1 *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="utf8Ptr">The IntPtr which represents the address of the first character of the unmanaged *char (string, Latin-1 or UTF-8, 8-bit).</param>
            <param name="len">Returns the number of bytes read (the length of the decoded string).</param>
            <returns>The translated unicode string.</returns>
            <remarks>
            Actually this method tries to encode the pointer to both UTF-8 and Latin-1.
            It returns the UTF-8 string if it is valid and shorter as it's Latin-1 counterpart.
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUtf8(System.IntPtr,System.Int32@)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated UTF-8 *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="utf8Ptr">The IntPtr which represents the address of the first character of the unmanaged *char (string, UTF-8, 8-bit).</param>
            <param name="len">Returns the number of bytes read (the length of the decoded string).</param>
            <returns>The translated unicode string.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrAsStringUtf8(System.IntPtr)">
            <summary>
            Translates an IntPtr into a .NET managed string.
            <para>Sometime BASS returns an IntPtr which actually represents a pointer to a memory block containing a null-terminated UTF-8 *char (string, 8-bit).
            This method does this translation for you and returns the actual string.</para>
            </summary>
            <param name="utf8Ptr">The IntPtr which represents the address of the first character of the unmanaged *char (string, UTF-8, 8-bit).</param>
            <returns>The translated unicode string.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntAsObject(System.IntPtr,System.Type)">
            <summary>
            Translates an IntPtr into a .NET managed object of a given <see cref="T:System.Type"/>.
            <para>Sometime BASS returns a pointer which actually represents a memory block containing a structured object.
            This method does this translation for you and returns the actual object.</para>
            </summary>
            <param name="ptr">The pointer which represents the address of the structured object.</param>
            <param name="structureType">The <see cref="T:System.Type"/> of object to be created. This type object must represent a formatted class or structure.</param>
            <returns>The managed object of the specified type.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetVersion">
            <summary>
            Returns the version of the BASS.NET API (Bass.Net.dll)
            </summary>
            <returns>The version of the Bass.Net.dll</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermAnsi(System.IntPtr)">
            <summary>
            Retrieves an array of strings from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of null-terminated Ansi strings.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one text as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermUtf8(System.IntPtr)">
            <summary>
            Retrieves an array of strings from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of null-terminated UTF-8 strings.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one text as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermUnicode(System.IntPtr)">
            <summary>
            Retrieves an array of strings from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of null-terminated UNICODE strings.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns><see langword="null"/> or an array of strings. Each array element will represent one text as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermInt32(System.IntPtr)">
            <summary>
            Retrieves an array of int from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of Int32 values terminated by a 0 value.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns><see langword="null"/> or an array of int. Each array element will represent one Int32 value as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.IntPtrToArrayNullTermInt16(System.IntPtr)">
            <summary>
            Retrieves an array of int from a given unmanaged memory location.
            <para>NOTE: This method evaluates the pointer as 'a series/array of Int16 values terminated by a 0 value.</para>
            </summary>
            <param name="pointer">The pointer to the unmanaged memory block.</param>
            <returns><see langword="null"/> or an array of int. Each array element will represent one Int16 value as obtained from the IntPtr.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.StringToNullTermAnsi(System.String,System.IntPtr)">
            <summary>
            Copies the contents of a managed string into unmanaged memory, 
            converting into ANSI format as it copies and appends a null-terminator.
            </summary>
            <param name="text">The managed string to copy to <paramref name="target"/>.</param>
            <param name="target">The address, in unmanaged memory, to where <paramref name="text"/> should be copied.</param>
        </member>
        <member name="M:Un4seen.Bass.Utils.StringToNullTermUnicode(System.String,System.IntPtr)">
            <summary>
            Copies the contents of a managed string into unmanaged memory 
            and appends a null-terminator.
            </summary>
            <param name="text">The managed string to copy to <paramref name="target"/>.</param>
            <param name="target">The address, in unmanaged memory, to where <paramref name="text"/> should be copied.</param>
        </member>
        <member name="M:Un4seen.Bass.Utils.StringToNullTermUtf8(System.String,System.IntPtr)">
            <summary>
            Copies the contents of a managed string into unmanaged memory, 
            converting into UFT-8 format as it copies and appends a null-terminator.
            </summary>
            <param name="text">The managed string to copy to <paramref name="target"/>.</param>
            <param name="target">The address, in unmanaged memory, to where <paramref name="text"/> should be copied.</param>
        </member>
        <member name="M:Un4seen.Bass.Utils.StringToNullTermAnsi(System.String[],System.IntPtr,System.Boolean)">
            <summary>
            Copies the contents of a managed string array into unmanaged memory, 
            converting each element into ANSI format as it copies and appends a null-terminator.
            </summary>
            <param name="text">The managed string array to copy to <paramref name="target"/>.</param>
            <param name="target">The address, in unmanaged memory, to where <paramref name="text"/> should be copied.</param>
            <param name="addCRLF">Add a carriage return and line feed (&quot;\r\n&quot;) to each string element if missing?</param>
            <remarks>An additional final null-terminator is added as well, so that the last element will end with
             a double null-terminator.
             Note, that empty string array elements will be skipped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.StringToNullTermUnicode(System.String[],System.IntPtr,System.Boolean)">
            <summary>
            Copies the contents of a managed string array into unmanaged memory
            and appends a null-terminator.
            </summary>
            <param name="text"></param>
            <param name="target"></param>
            <param name="addCRLF"></param>
            <remarks>An additional final null-terminator is added as well, so that the last element will end with a 
             a double null-terminator.
             Note, that empty array elements will be skipped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.StringToNullTermUtf8(System.String[],System.IntPtr,System.Boolean)">
            <summary>
            Copies the contents of a managed string array into unmanaged memory, 
            converting each element into UTF-8 format as it copies and appends a null-terminator.
            </summary>
            <param name="text">The string array</param>
            <param name="target"></param>
            <param name="addCRLF"></param>
            <remarks>An additional final null-terminator is added as well, so that the last element will end with a 
             a double null-terminator.
             Note, that empty array elements will be skipped.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.ChannelNumberToString(System.Int32)">
            <summary>
            Converts a channel number to a string.
            </summary>
            <param name="chans">The number of channels.</param>
            <returns>The description of number of channels.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSChannelTypeToString(Un4seen.Bass.BASSChannelType)">
            <summary>
            Converts a <see cref="T:Un4seen.Bass.BASSChannelType"/> to a character representation describing the channel type or file type. Returns e.g. 'WMA', 'FLAC', 'MP3' etc.
            </summary>
            <param name="ctype">The <see cref="T:Un4seen.Bass.BASSChannelType"/> for which to get the description.</param>
            <returns>The description of the channel type.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSTagTypeToString(Un4seen.Bass.BASSTag)">
            <summary>
            Converts a <see cref="T:Un4seen.Bass.BASSTag"/> to a character representation describing the tag type. Returns e.g. 'ID3v1', 'ID3v2', 'WMA', 'APE' etc.
            </summary>
            <param name="tagType">The <see cref="T:Un4seen.Bass.BASSTag"/> for which to get the description.</param>
            <returns>The description of the tag type.</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)">
            <summary>
            Returns the supported stream file extensions of the given add-on file (e.g. "bassflac.dll").
            <para>Use <see langword="null"/> to retrieve the native supported stream file extensions of Bass.</para>
            <para>Use "music" to retrive the native supported music file extensions of Bass.</para>
            </summary>
            <param name="file">The file name and/or path of the bass add-on dll from which to retrieve the supported file extensions (or <see langword="null"/> or "music").</param>
            <returns>A list of supported file extensions (pattern-like, semicolon-seperated, e.g. "*.wma;*.wmv").</returns>
            <remarks>
            Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)">
            <summary>
            Returns the supported stream file name of the given add-on file (e.g. "bassflac.dll").
            <para>Use <see langword="null"/> to retrieve the native supported stream file name of Bass.</para>
            <para>Use "music" to retrive the native supported music name of Bass.</para>
            </summary>
            <param name="file">The file name and/or path of the bass add-on dll from which to retrieve the supported file name (or <see langword="null"/> or "music").</param>
            <returns>The name of the supported audio format (e.g. "Windows Media Audio").</returns>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.Collections.Generic.Dictionary{System.Int32,System.String},System.Boolean)">
            <summary>
            Returns the supported stream file extensions for all loaded plugins.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="includeBASS"><see langword="true"/>, if also the native BASS formats should be added.</param>
            <returns>The supported stream file extension string (*.ext1;*.ext2;...*.extN)</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally and might include all native BASS extensions.
            <para>Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            string exts = Utils.BASSAddOnGetSupportedFileExtensions(loadedPlugIns, true);
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            Dim exts As String = Utils.BASSAddOnGetSupportedFileExtensions(loadedPlugIns, True)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or <see langword="null"/>, if only the plain formats should be returned.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally and also includes all native BASS formats.
            <para>Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetSupportedFileFilter(loadedPlugIns, "All supported Audio Files");
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, "All supported Audio Files")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String,System.Boolean)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or <see langword="null"/>, if only the plain formats should be returned.</param>
            <param name="includeBASS"><see langword="true"/>, if also the native BASS formats should be added.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally.
            <para>Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetSupportedFileFilter(loadedPlugIns, null, false);
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, Nothing, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String,System.Boolean,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or <see langword="null"/>, if only the plain formats should be returned.</param>
            <param name="includeBASS"><see langword="true"/>, if also the native BASS formats should be added.</param>
            <param name="extra">A list of additional filter entries to add (key=name; value=extension; e.g. 'Playlist' - '*.pls').</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileName(System.String)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally.
            <para>Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetPluginFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or <see langword="null"/>, if only the plain formats should be returned.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally and also includes all native BASS formats.
            <para>Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, "All supported Audio Files");
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, "All supported Audio Files")
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnGetPluginFileFilter(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String,System.Boolean)">
            <summary>
            Returns a file filter which can be used in a standard 'OpenFileDialog'.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method.</param>
            <param name="allFormatName">The name of the first entry which will describe all available formats. Or <see langword="null"/>, if only the plain formats should be returned.</param>
            <param name="includeBASS"><see langword="true"/>, if also the native BASS formats should be added.</param>
            <returns>The file filter string which can be used in a standard 'OpenFileDialog' in the format:
            allFormatName|AllExtensions|FormatName1|externtions1|FormatName2|externtions2...</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Bass.BASS_PluginGetInfo(System.Int32)"/> and <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally.
            <para>Note: This list reports a set of file extensions which might be supported.
            There is no guarantee that the list is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
            <example>
            <code>
            Dictionary&lt;int, string&gt; loadedPlugIns = Bass.BASS_PluginLoadDirectory(dir);
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, null, false);
            </code>
            <code lang="vbnet">
            Dim loadedPlugIns As Dictionary(Of Integer, String) = Bass.BASS_PluginLoadDirectory(dir)
            openFileDialog.Filter = Utils.BASSAddOnGetPluginFileFilter(loadedPlugIns, Nothing, False)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.Utils.BASSAddOnIsFileSupported(System.Collections.Generic.Dictionary{System.Int32,System.String},System.String)">
            <summary>
            Checks if a certain file is supported by the currently loaded add-ons.
            </summary>
            <param name="plugins">The hash table as returned by the <see cref="M:Un4seen.Bass.Bass.BASS_PluginLoadDirectory(System.String)"/> method or <see langword="null"/> to only check BASS extensions.</param>
            <param name="filename">The audio filename to check,</param>
            <returns><see langword="true"/>, if the audio file is supported by any of the loaded plugins.</returns>
            <remarks>This method uses <see cref="M:Un4seen.Bass.Utils.BASSAddOnGetSupportedFileExtensions(System.String)"/> internally.
            <para>Note: There is no guarantee that the check is complete or might contain formats not being supported on your particular OS/machine (due to additional or missing audio codecs).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.AbsSignMax(System.Int16,System.Int16)">
            <summary>
            Returns the absolute signed maximum value of two values.
            </summary>
            <param name="val1">The first value to compare.</param>
            <param name="val2">The second value to compare.</param>
            <returns>The signed value of the parameter whose absolute value is greater.</returns>
            <remarks>The two values are compared by their absolute unsigned value but are returned with their signed value.
            E.g. -10000 will be returned by comparing -10000 and +8000.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.AbsSignMax(System.Single,System.Single)">
            <summary>
            Returns the absolute signed maximum value of two values.
            </summary>
            <param name="val1">The first value to compare.</param>
            <param name="val2">The second value to compare.</param>
            <returns>The signed value of the parameter whose absolute value is greater.</returns>
            <remarks>The two values are compared by their absolute unsigned value but are returned with their signed value.
            E.g. -10000 will be returned by comparing -10000 and +8000.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.SampleDither(System.Double,System.Double,System.Double)">
            <summary>
            Applies a dither to a single sample value.
            </summary>
            <param name="sample">The sample data to add a dither to (e.g. an 8- or 16-bit sample value as a double value).</param>
            <param name="factor">The bit depth factor for the dither (typically between 0.3 and 0.9).</param>
            <param name="max">The maximum sample data range (e.g. 256 for 8-bit samples or 32768 for 16-bit samples).</param>
            <returns>The dithered sample value: </returns>
            <remarks>Dithering adds a low level white noise to the sample data before truncating for the purpose of minimizing quantization error.
            <para>Dithering here is implemented as a triangular probability density function (TPDF), actually a factor-bit triangular dither.</para>
            <para>All parameters here are implemented as double values for maximum precision and performance. 
            However, you might also pass 8-bit(byte) or 16-bit(short) values and then simply cast back the return value.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 16-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 16-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 32-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 32-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 8-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The 8-bit buffer to get the level from.</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size, use -1 to scan the whole buffer size).</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The buffer pointer to the sample data (e.g. as obtained in a <see cref="T:Un4seen.Bass.DSPPROC"/>).</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="bps">The bytes per sample (or bitwidth) - which can be either 1, 2 or 4 bytes per sample or 8, 16 or 32 bits per sample.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size) - no range check is applied here!.</param>
            <returns>If successful, the level of the left channel is returned in the low word (low 16-bits), and the level of the right channel is returned in the high word (high 16-bits). If the channel is mono, then the low word is duplicated in the high word.</returns>
            <remarks>
            <para>Structure of the return value (int = 32-bit):
            <code lang="none">
            |               32-bit              |
            |    right-peak    |   left-peak    |
            </code>
            </para>
            <para>Each peak level ranges linearly from 0 (silent) to +32767 (max).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetLevel2(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but with individual offset and length.
            </summary>
            <param name="buffer">The buffer pointer to the sample data (e.g. as obtained in a <see cref="T:Un4seen.Bass.DSPPROC"/>).</param>
            <param name="chans">The number of channels to use (1=mono, 2=stereo). In case of mono the left and right channel will contain the same value.</param>
            <param name="bps">The bytes per sample (or bitwidth) - which can be either 1, 2 or 4 bytes per sample or 8, 16 or 32 bits per sample.</param>
            <param name="startIndex">The starting index (sample offset, not byte offset!) within the buffer from where to to get the level (use -1 to start from the beginning).</param>
            <param name="length">Number of samples (not bytes!) to use (startIndex + length must be less than the buffer size) - no range check is applied here!.</param>
            <returns>If successful, the level of the left channel is returned in the low Dword (low 32-bits), and the level of the right channel is returned in the high Dword (high 32-bits).
            Each Dword (32-bit) carries the maximum peak level value in the high word (high 16-bit) and the the minimum peak level value in the low word (low 16-bit).
            If the channel is mono, then the low Dword is duplicated in the high Dword.</returns>
            <remarks>
            <para>Structure of one element (long = 64-bit):
            <code lang="none">
            |               64-bit              |
            |      right       |      left      |
            |max.peak|min.peak|max.peak|min.peak|
            </code>
            </para>
            <para>Each peak level ranges linearly from -32768 to 0 (silent) to +32767.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DecodeAllData(System.Int32,System.Boolean)">
            <summary>
            Decodes all the available data of the given channel right away.
            </summary>
            <param name="channel">The channel handle who's channel data should be decoded (should typically be a decoding channel).</param>
            <param name="autoFree"><see langword="true"/>, if the channel should be freed (via <see cref="M:Un4seen.Bass.Bass.BASS_StreamFree(System.Int32)"/>) when all the data has been decoded.</param>
            <returns>The total number of bytes actually decoded.</returns>
            <remarks>Internally <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> will be called in a loop as long as the channel is active (BASS_ACTIVE_PLAYING).
            This method might be useful, if you want to quickly decode all the data of the channel to e.g. feed it through a DSP.
            <para>When using with a mixer channel (<see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)"/>) make sure to use the <see cref="F:Un4seen.Bass.BASSFlag.BASS_MIXER_END"/> flag, since otherwise the mixer channel would never end.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DetectCuePoints(System.String,System.Single,System.Double@,System.Double@,System.Double,System.Double,System.Int32)">
            <summary>
            Detects the cue-in and -out points of a given audio file.
            </summary>
            <param name="filename">The audio file to analyze.</param>
            <param name="blockSize">The block-size in seconds which will be used to scan the file (between 0.1 and 30 seconds).</param>
            <param name="cueInPos">Returns the cue-in position in seconds according to <paramref name="dBIn"/>.</param>
            <param name="cueOutPos">Returns the cue-out position in seconds according to <paramref name="dBOut"/>.</param>
            <param name="dBIn">The threshold in dB to be used to detect the <paramref name="cueInPos"/>.</param>
            <param name="dBOut">The threshold in dB to be used to detect the <paramref name="cueOutPos"/>.</param>
            <param name="findZeroCrossing">Position adjustment flag. 0=no adjustment, 1=move to zero-crossing sample to avoid clicks, 2=move to quiter sample (threshold/2) to avoid clicks.</param>
            <returns><see langword="true"/> on success - else <see langword="false"/>.</returns>
            <remarks>If <paramref name="findZeroCrossing"/> is set to 1 the zero-crossing determination will only be performed within the last analyzed <paramref name="blockSize"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DetectCuePoints(System.Int32,System.Single,System.Double@,System.Double@,System.Double,System.Double,System.Int32)">
            <summary>
            Detects the cue-in and -out points of a given decoding stream.
            </summary>
            <param name="decodingStream">The decoding stream to analyze (should be created with the BASS_STREAM_PRESCAN flag).</param>
            <param name="blockSize">The block-size in seconds which will be used to scan the file (between 0.1 and 30 seconds).</param>
            <param name="cueInPos">Returns the cue-in position in seconds according to <paramref name="dBIn"/>.</param>
            <param name="cueOutPos">Returns the cue-out position in seconds according to <paramref name="dBOut"/>.</param>
            <param name="dBIn">The threshold in dB to be used to detect the <paramref name="cueInPos"/>.</param>
            <param name="dBOut">The threshold in dB to be used to detect the <paramref name="cueOutPos"/>.</param>
            <param name="findZeroCrossing">Position adjustment flag. 0=no adjustment, 1=move to zero-crossing sample to avoid clicks, 2=move to quiter sample (threshold/2) to avoid clicks.</param>
            <returns><see langword="true"/> on success - else <see langword="false"/> (Note: <paramref name="decodingStream"/> must be a decoding stream and can not be 0).</returns>
            <remarks>If <paramref name="findZeroCrossing"/> is set to 1 the zero-crossing determination will only be performed within the last analyzed <paramref name="blockSize"/>.</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.DetectNextLevel(System.Int32,System.Single,System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Finds the next position with a certain volume level.
            </summary>
            <param name="decodingStream">The decoding stream to analyze (should be created with the BASS_STREAM_PRESCAN flag).</param>
            <param name="blockSize">The block-size in seconds which will be used to scan the file (between 0.1 and 30 seconds).</param>
            <param name="startpos">The position in seconds where to start the search.</param>
            <param name="dB">The threshold in dB (e.g. -12.0dB) which should be searched.</param>
            <param name="reverse">Search forward (<see langword="false"/>) or backward (<see langword="true"/>).</param>
            <param name="findZeroCrossing">If set to <see langword="true"/> the returned position will be adjusted to the next resp. previous zero crossing in order to avoid clicks.</param>
            <returns>The position with the respective volume level (if the level could not be detected, then startpos will be returned).</returns>
            <remarks>As this method calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> internally the current position of the <paramref name="decodingStream"/> might be changed.
            So if you need to preserve this position you must remember it before calling this method and set it afterwards yourself (via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetPosition(System.Int32,Un4seen.Bass.BASSMode)"/> and <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetPosition(System.Int32,System.Int64,Un4seen.Bass.BASSMode)"/>).</remarks>
        </member>
        <member name="M:Un4seen.Bass.Utils.GetNormalizationGain(System.String,System.Single,System.Double,System.Double,System.Single@)">
            <summary>
            Determines a gain factor (normalization), so that the maximum peak level of the stream will be at 0 dB.
            </summary>
            <param name="filename">The audio file to analyze.</param>
            <param name="blockSize">The block-size in seconds which will be used to scan the file (between 0.1 and 30 seconds).</param>
            <param name="startpos">The position (in seconds) where to start the calculation (between 0 and file duration, or -1 to scan from the beginning).</param>
            <param name="endpos">The position (in seconds) til where to perform the calculation (between 0 and file duration, or -1 to scan til the end; must be bigger than startpos).</param>
            <param name="peak">Returns the maximum peak level as a float value between 0.0 (silence) and 1.0 (0dB).</param>
            <returns>The gain factor as a float value (or -1 on error) - a value of 1 means no amplification.</returns>
            <remarks>
            You might use the gain factor as a multiplier to the sample data to apply a volume adjustment, so that the maximum peak level of the audio samples is at 0 dB.
            </remarks>
        </member>
        <member name="T:Un4seen.Bass.BASSTimer">
            <summary>
            Implements a secure Timer, which raises an event in defined intervals.
            </summary>
            <remarks>This timer implementation is based on the <see cref="T:System.Threading.Timer"/>, but is optimized to be used in multi-threading environments as well as UI threads.
            <para>This Timer uses a <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event handler which will be raised every <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> milliseconds once the <see cref="M:Un4seen.Bass.BASSTimer.Start"/> method was called and the timer is activated.</para>
            <para>This implementation ensures, that the <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from a UI thread, the specified event delegate will also be called in that UI thread.</para>
            <para>Use the <see cref="M:Un4seen.Bass.BASSTimer.Stop"/> method to deactivate the Timer.</para>
            <para>You might change the <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> at any time. If the Timer has already been activated, this will also take immediate effect (the next <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will be raised after the new interval value).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.#ctor">
            <summary>
            Creates a new Timer instance using a default interval of 50ms.
            </summary>
            <remarks>The timer will not be activated automatically. Call <see cref="M:Un4seen.Bass.BASSTimer.Start"/> to activate the timer.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.#ctor(System.Int32)">
            <summary>
            Creates a new Timer instance using the given interval.
            </summary>
            <param name="interval">The interval in milliseconds at which the <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event should be raised.</param>
            <remarks>The timer will not be activated automatically. Call <see cref="M:Un4seen.Bass.BASSTimer.Start"/> to activate the timer.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
            <remarks>Do not make this method virtual. A derived class should not be able to override this method.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="E:Un4seen.Bass.BASSTimer.Tick">
            <summary>
            Event handler used to notify that the timer has elapsed.
            </summary>
            <remarks>This event will be raised, if the Timer has been started (see <see cref="M:Un4seen.Bass.BASSTimer.Start"/>) and the <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> has been elapsed.
            <para>Note: This implementation ensures, that the event will be executed in the main thread the subscriber executes in!
            So when subscribing to this event from UI thread, the specified event delegate will also be called in that UI thread.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASSTimer.Interval">
            <summary>
            Gets or Sets the number of milliseconds between two <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> events.
            </summary>
            <remarks>To get the interval in seconds you need to divide this number by 1000.
            <para>The <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will only be raised, if the Timer is active (see <see cref="M:Un4seen.Bass.BASSTimer.Start"/>).</para>
            <para>Specify 0 (zero) or a nagative value to inactivate the periodic signalling of the <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event - however in this case the Timer remain activated.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.Bass.BASSTimer.Enabled">
            <summary>
            Gets or Sets if the Timer is currently active.
            </summary>
            <remarks>Returns <see langword="true"/>, if the Timer is active.
            <para>Setting this property will have the same effect as calling <see cref="M:Un4seen.Bass.BASSTimer.Start"/> respectivly <see cref="M:Un4seen.Bass.BASSTimer.Stop"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Start">
            <summary>
            Activates (starts) the Timer.
            </summary>
            <remarks>After activating the Timer every <see cref="P:Un4seen.Bass.BASSTimer.Interval"/> milliseconds a <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> event will be raised.
            <para>Calling this method on an already active timer will have no effect.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSTimer.Stop">
            <summary>
            Deativates (stops) the Timer.
            </summary>
            <remarks>After deactivating the Timer no more <see cref="E:Un4seen.Bass.BASSTimer.Tick"/> events will be raised.</remarks>
        </member>
        <member name="T:Un4seen.Bass.BASSBuffer">
            <summary>
            Implements a fast and generic circular ring buffer (FiFo).
            </summary>
            <remarks>This implementation uses an internal byte array as a buffer and can be used in multi-threading environments, since all members are thread-safe.
            <para>The default size of the ring buffer is 2 seconds (when using it with 44.1kHz, 16-bit stereo sample data).</para>
            <para>This class supports multiple readers using the ring buffer (default is 1). Use the <see cref="P:Un4seen.Bass.BASSBuffer.Readers"/> property to set the maximum number of parallel readers accessing the ring buffer.</para>
            <para>The ring buffer is not a dynamic buffer, meaning it has a fixed size once created. However, the ring buffer size might be increased at any time through the <see cref="M:Un4seen.Bass.BASSBuffer.Resize(System.Single)"/> method, even if you should avoid this for performance reasons.</para>
            <para>Use the <see cref="M:Un4seen.Bass.BASSBuffer.Write(System.IntPtr,System.Int32)"/> method to add sample data to the ring buffer. And use the <see cref="M:Un4seen.Bass.BASSBuffer.Read(System.IntPtr,System.Int32,System.Int32)"/> method to retrieve sample data from the ring buffer.</para>
            <para>This class might be useful for full-duplex monitoring of a recording streams or in order to clone existing streams.</para>
            <para>In order to reduce latency, you might probably want to minimize the recording update period (see <see cref="M:Un4seen.Bass.Bass.BASS_RecordStart(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,Un4seen.Bass.RECORDPROC,System.IntPtr)"/>.
            You'll probably also want to reduce the update period (BASS_CONFIG_UPDATEPERIOD) and buffer length (BASS_CONFIG_BUFFER), to reduce output latency (see <see cref="M:Un4seen.Bass.Bass.BASS_SetConfig(Un4seen.Bass.BASSConfig,System.Int32)"/>).</para>
            </remarks>
            <example>
            BASS Recording with full-duplex monitoring:
            <code>
            private RECORDPROC _myRecProc; // make it global, so that the GC can not remove it
            private int _recHandle = 0;
            // The buffer: 44.1kHz, 16-bit, stereo (like we record!)
            private BASSBuffer _monBuffer = new BASSBuffer(2f, 44100, 2, 16);
            private int _monStream = 0;
            private STREAMPROC _monProc = null;
            ...
            // enable lower latency settings (optional)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20);
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100);
            // start recording with 20ms update period
            _myRecProc = new RECORDPROC(MyRecording);
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, _myRecProc, IntPtr.Zero);
            // setup the full-duplex monitoring
            _monProc = new STREAMPROC(MonitoringStream);
            _monStream = Bass.BASS_StreamCreate(44100, 2, 0, _monProc, IntPtr.Zero); // user = reader#
            Bass.BASS_ChannelPlay(_monStream, false);
            
            private bool MyRecording(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	monBuffer.Write(buffer, length);
            }
            
            private int MonitoringStream(int handle, IntPtr buffer, int length, IntPtr user)
            {
            	return monBuffer.Read(buffer, length, user.ToInt32());
            }
            </code>
            <code lang="vbnet">
            Private _myRecProc As RECORDPROC ' make it global, so that the GC can not remove it
            Private _recHandle As Integer = 0
            ' The buffer: 44.1kHz, 16-bit, stereo (like we record!)
            Private _monBuffer As New BASSBuffer(2F, 44100, 2, 16)
            Private _monStream As Integer = 0
            Private _monProc As STREAMPROC = Nothing
            ...
            ' enable lower latency settings (optional)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 20)
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_BUFFER, 100)
            ' start recording with 20ms update period
            _myRecProc = New RECORDPROC(MyRecording)
            _recHandle = Bass.BASS_RecordStart(44100, 2, BASSFlag.BASS_DEFAULT, 20, _myRecProc, IntPtr.Zero)
            ' setup the full-duplex monitoring
            _monProc = New STREAMPROC(AddressOf MonitoringStream)
            _monStream = Bass.BASS_StreamCreate(44100, 2, 0, _monProc, IntPtr.Zero) ' user = reader#
            Bass.BASS_ChannelPlay(_monStream, False)
            
            Private Function MyRecording(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Boolean
              monBuffer.Write(buffer, length)
            End Function
            
            Private Function MonitoringStream(handle As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              Return monBuffer.Read(buffer, length, user.ToInt32())
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.#ctor">
            <summary>
            Default Constructor using the default buffer size.
            </summary>
            <remarks>The default size of the buffer is 2 seconds (when using it with 44.1kHz, 16-bit stereo sample data).</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.#ctor(System.Single,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an instance of the ring buffer with a size acconding to the given parameters.
            </summary>
            <param name="seconds">The length of the buffer in seconds (e.g. 2.0 for 2 seconds or 0.2 for 200ms).</param>
            <param name="samplerate">The samplerate in Hz to use.</param>
            <param name="chans">The number of channels to use.</param>
            <param name="bps">Bytes per Sample (1 = 8-bit, 2 = 16-bit or 4 = 32-bit sample data, but you might also use 8, 16 or 32 here directly).</param>
            <remarks>The internal buffer size is calculated accordingly to the above parameters, rounded to the next sample mathich the given bytes per sample.
            <para>The buffer size is calculated as: seconds * samplerate * chans * bps</para>
            </remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Dispose">
            <summary>
            Implement IDisposable.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.BufferLength">
            <summary>
            Gets the total length in bytes of the ring buffer.
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.Bps">
            <summary>
            Gets the Bytes per sample used with the ring buffer (1=8-bit, 2=16-bit default, 4=32-bit).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.SampleRate">
            <summary>
            Gets the sample rate in Hz used with the ring buffer (default is 44100 Hz).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.NumChans">
            <summary>
            Gets the number of channels used with the ring buffer (1=mono, 2=stereo default, etc).
            </summary>
        </member>
        <member name="P:Un4seen.Bass.BASSBuffer.Readers">
            <summary>
            Gets or Sets the number of parallel Readers which can be used with the ring buffer.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Clear">
            <summary>
            Clears the ring buffer (zeros all elements) and resets all read and write pointers.
            </summary>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Resize(System.Single)">
            <summary>
            Resizes (enlarges) the ring buffer by the given factor.
            </summary>
            <param name="factor">The factor to use for resizing (the buffer size is multiplied by this factor). Must be greater than 1.0.</param>
            <remarks>Shrinking the buffer size is not allowed.</remarks>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Space(System.Int32)">
            <summary>
            Returns the number of bytes available in the ring buffer for writing until an overflow of the read pointer will happen.
            </summary>
            <param name="reader">The zero-based index of the reader to use (0=first reader) or -1 to get the smallest available space for all readers.</param>
            <remarks>In order to convert the available space in the buffer to number of samples, simply devide the result by the bytes per sample
            (e.g. if the result is 56780 and you are using the buffer with 16-bit stereo sample data, the number of sample are 56780/2 = 28390 samples or 14195 stereo pairs).
            <para>Note, that there is never a real physical write limitation, since writing to the buffer always has priority.
            Meaning if there is not sufficient space left between the write pointer position and the last read pointer position, this fact is simply ignored. The data will be written anyhow.
            However, this will result in an overflow, so that the next read operation will only have the overflown sample data available - resulting in a gap in the sound.</para>
            </remarks>
            <returns>Returns the number of bytes available in the ring buffer for writing until an overflow of the read pointer will happen (space between the current write pointer position and the read pointer position).</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Count(System.Int32)">
            <summary>
            Returns the number of bytes available in the ring buffer for reading.
            </summary>
            <param name="reader">The zero-based index of the reader to use (0=first reader) or -1 to get the biggest number of bytes for all readers.</param>
            <remarks>In order to convert the bytes in the buffer to number of samples, simply devide the result by the bytes per sample
            (e.g. if the result is 56780 and you are using the buffer with 16-bit stereo sample data, the number of sample are 56780/2 = 28390 samples or 14195 stereo pairs).</remarks>
            <returns>The number of bytes available in the ring buffer for reading (between the current read pointer position and the write pointer position).</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Write(System.IntPtr,System.Int32)">
            <summary>
            Writes (add) the given number of sample data to the ring buffer.
            </summary>
            <param name="buffer">The pointer to the buffer containing the sample data to write to the ring buffer (e.g. as provided by a <see cref="T:Un4seen.Bass.RECORDPROC"/>, <see cref="T:Un4seen.Bass.DSPPROC"/> etc. or even by <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>).</param>
            <param name="length">The number of BYTES to write to the ring buffer (from the <paramref name="buffer"/>).</param>
            <returns>The number of bytes actually written to the ring buffer.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes (add) the given number of sample data to the ring buffer.
            </summary>
            <param name="buffer">The byte array containing the sample data to write to the ring buffer.</param>
            <param name="length">The number of BYTES to write to the ring buffer (from the <paramref name="buffer"/>).</param>
            <returns>The number of bytes actually written to the ring buffer.</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Read(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Reads (removes) the given number of sample data from the ring buffer.
            </summary>
            <param name="buffer">The pointer to the buffer where the read sample data should be written to (e.g. as provided by a <see cref="T:Un4seen.Bass.STREAMPROC"/>).</param>
            <param name="length">The number of BYTES to read from the ring buffer (which will be written to the <paramref name="buffer"/>).</param>
            <param name="reader">The zero-based index of the reader to use (0=first reader).</param>
            <returns>The number of bytes actually read from the ring buffer (which be be less than requested).</returns>
        </member>
        <member name="M:Un4seen.Bass.BASSBuffer.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads (removes) the given number of sample data from the ring buffer.
            </summary>
            <param name="buffer">The byte array where the read sample data should be written to (must be initialized and large enough to keep the data).</param>
            <param name="length">The number of BYTES to read from the ring buffer (which will be written to the <paramref name="buffer"/>).</param>
            <param name="reader">The zero-based index of the reader to use (0=first reader).</param>
            <returns>The number of bytes actually read from the ring buffer (which might be less than requested).</returns>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsio">
            <summary>
            .NET API wrapper for BASSASIO.DLL
            <para>Requires: bassasio.dll - ASIO driver library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSASIO is basically a wrapper for ASIO drivers, with the addition of channel joining, format conversion and resampling.</para>
            <para>BASSASIO requires a soundcard with ASIO drivers installed. It also makes use of SSE2 and 3DNow optimizations, but is fully functional without them.
            BASS is not required by BASSASIO, but BASS can of course be used to decode, apply DSP/FX, etc.</para>
            <para>Note, that Bass.Net automatically tries to initialize BASSASIO to use with unicode.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.#cctor">
            <summary>
            Base static contructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetUnicode(System.Boolean)">
            <summary>
            Sets the character set used in device information text.
            </summary>
            <param name="unicode">Use Unicode? If FALSE, ANSI is used, else UTF-16 is used.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function determines the character set that is used in the <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> structure and in <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDevice(System.Guid,System.String,System.String)"/> function calls.
            It does not affect ASIO channel names in the <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> and <see cref="T:Un4seen.BassAsio.BASS_ASIO_INFO"/> structure.
            <para>The character set choice is finalised in the first <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/>, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDevice(System.Guid,System.String,System.String)"/> or <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call, and it cannot be changed after that. The default is to use ANSI.</para>
            <para>Note: Bass.Net will invoke this method automatically to ensure it is always set to Unicode!</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>This function is only available before any devices have been enumerated.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode">
            <summary>
            Retrieves the error code for the most recent BASSASIO function call in the current thread.
            </summary>
            <returns>If no error occured during the last BASSASIO function call then BASS_OK is returned, else one of the <see cref="T:Un4seen.Bass.BASSError"/> values is returned. 
            See the function description for an explanation of what the error code means.</returns>
            <remarks>Error codes are stored for each thread. So if you happen to call 2 or more BASSASIO functions at the same time, they will not interfere with eachother's error codes.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfoInternal(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)">
            <summary>
            Retrieves information on an Asio device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Asio devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all available devices:
            <code>
            BASS_ASIO_DEVICEINFO info = new BASS_ASIO_DEVICEINFO();
            for (int n=0; BassAsio.BASS_ASIO_GetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_ASIO_DEVICEINFO()
            While (BassAsio.BASS_ASIO_GetDeviceInfo(n, info))
              Console.WriteLine(info.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on an Asio device.
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Asio devices for a setup dialog. 
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_ASIO_DEVICEINFO info;
            for (int n = 0; (info = BassAsio.BASS_ASIO_GetDeviceInfo(n)) != null; n++)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_ASIO_DEVICEINFO()
            While Not (info Is Nothing)
              info = BassAsio.BASS_ASIO_GetDeviceDescription(n)
              If Not (info Is Nothing) Then
                ...
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfos">
            <summary>
            Returns all available Asio devices.
            </summary>
            <returns>An array of <see cref="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO"/> elements representing the available Asio devices.</returns>
            <remarks>Uses <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceCount">
            <summary>
            Returns the total number of available Asio devices.
            </summary>
            <returns>Number of ASIO devices available.</returns>
            <remarks>Uses <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)">
            <summary>
            Sets the device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = first device.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>The device context setting is used by any function that may result in a BASS_ERROR_INIT error (except this function), which is the majority of them. When one if those functions is called, it will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASSASIO will automatically select the lowest device that is initialized. 
            This means that when using a single device, there is no need to use this function - BASSASIO will automatically use the device that's initialized. Even if you free the device, and initialize another, BASSASIO will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Get the sample rate of device 2:
            <code>
            // select device 2
            BassAsio.BASS_ASIO_SetDevice(2);
            // get the sample rate
            double rate = BassAsio.BASS_ASIO_GetRate();
            </code>
            <code lang="vbnet">
            ' select device 2
            BassAsio.BASS_ASIO_SetDevice(2)
            ' get the sample rate
            Dim rate As Double = BassAsio.BASS_ASIO_GetRate()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDevice">
            <summary>
            Retrieves the Asio device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/>to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called - there are no initialized devices.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDevicePtr(System.IntPtr,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="clsid"></param>
            <param name="driver"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDeviceGuid(System.Guid,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="clsid"></param>
            <param name="driver"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDevicePtrUnicode(System.IntPtr,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="clsid"></param>
            <param name="driver"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDeviceGuidUnicode(System.Guid,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="clsid"></param>
            <param name="driver"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_AddDevice(System.Guid,System.String,System.String)">
            <summary>
            Adds a driver to the device list.
            </summary>
            <param name="clsid">The driver's class ID.</param>
            <param name="driver">The filename of the driver.</param>
            <param name="name">An optional description of the driver.</param>
            <returns>If successful, the new device number is returned (which might be used in a subsequent <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call), else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/>to get the error code.</returns>
            <remarks>
            <para>A list of installed ASIO drivers is kept in the Windows registry, which is where BASSASIO gets its device list from, 
            but it is also possible to add unregistered drivers (eg. private drivers) to the list via this function. 
            If successful, the returned device number can be used in a <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call to use the driver.</para>
            <para>The driver and name strings are expected to be in ANSI form unless Unicode device information has been enabled via BASS_ASIO_SetUnicode, in which case they are expected to be in UTF-16 form</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_FILEOPEN</term><description>The <paramref name="driver"/> file does not exist.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)">
            <summary>
            Initializes an Asio device/driver.
            </summary>
            <param name="device">The device to use... 0 = first device, -1 = first available device. <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> can be used to get the total number of devices.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.BassAsio.BASSASIOInit"/>):
            <list type="table">
            <item><term>BASS_ASIO_THREAD</term><description>Host the driver in a dedicated thread, else the current thread.</description></item>
            <item><term>BASS_ASIO_JOINORDER</term><description>Place joined channels in the order in which <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)"/> was called to join them, else place them in numerically ascending order.</description></item>
            <item><term>BASS_ASIO_VOLRAMP</term><description>Ramp volume changes (of output channels).</description></item>
            </list>
            </param>
            <returns>If the device was successfully initialized, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function must be successfully called before any input or output can be performed. When the first available device is initialized, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> can be used afterwards to find out which device that is.</para>
            <para>The ASIO driver is accessed via a COM object using the single-threaded apartment model, which means that requests to the driver go through the thread that initialized it, so the thread needs to exist as long as the driver remains initialized.
            The thread should also have a message queue. If device initializing and releasing from multiple threads is required, or the application does not have a message queue (eg. a console application), then the BASS_ASIO_THREAD flag can be used to have BASSASIO create a dedicated thread to host the ASIO driver.</para>
            <para>Simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> is used to switch the current device. 
            When successful, BASS_ASIO_Init automatically sets the current thread's device to the one that was just initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>A device has already been initialized. You must call <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Free"/> before you can initialize again.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The driver couldn't be initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Free">
            <summary>
            Releases the Asio device/driver.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Make sure to free each Asio device you have initialized with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/>, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> is used to switch the current device.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetVersion">
            <summary>
            Retrieves the version number of the BASSASIO.DLL that is loaded.
            </summary>
            <returns>The BASSASIO version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSASIO supports all the BASSASIO functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.BassAsio.BassAsio.BASSASIOVERSION"/> to check the major revision.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassAsio.BASS_ASIO_GetVersion()) != BassAsio.BASSASIOVERSION )
            {
              MessageBox.Show(this, "Wrong BassAsio Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassAsio.BASS_ASIO_GetVersion()) &lt;&gt; BassAsio.BASSASIOVERSION Then
              MessageBox.Show(Me, "Wrong BassAsio Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassAsio.BASS_ASIO_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassAsio Version!");
            }
            </code>
            <code lang="vbnet">
            If BassAsio.BASS_ASIO_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassAsio Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the BASSASIO.DLL that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSASIO version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSASIO supports all the BASSASIO functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.</remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassAsio.BASS_ASIO_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassAsio Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassAsio.BASS_ASIO_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassAsio Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop">
            <summary>
            Stops the current Asio device.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device hasn't been started.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetInfo(Un4seen.BassAsio.BASS_ASIO_INFO)">
            <summary>
            Retrieves information on the Asio device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_INFO"/> class to store the information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the number of inputs and outputs:
            <code>
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            BASS_ASIO_INFO info = new BASS_ASIO_INFO();
            if ( BassAsio.BASS_ASIO_GetInfo(info) )
            {
            	Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            Dim info As New BASS_ASIO_INFO()
            If BassAsio.BASS_ASIO_GetInfo(info) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetInfo">
            <summary>
            Retrieves information on the Asio device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_INFO"/> class on success - else <see langword="null"/>.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSASIO API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the number of inputs and outputs of the current Asio device:
            <code>
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            BASS_ASIO_INFO info = BassAsio.BASS_ASIO_GetInfo();
            if ( info != null )
            {
            	Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            Dim info As BASS_ASIO_INFO = BassAsio.BASS_ASIO_GetInfo()
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetRate(System.Double)">
            <summary>
            Sets the Asio device's sample rate.
            </summary>
            <param name="rate">The sample rate.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When it's not possible to set the device to the rate wanted, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)"/> can be used to overcome that.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The sample rate is not supported by the device/drivers.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set the Asio device and channel sample rate to the same as the underlying BASS decoding stream, in order to save resampling:
            <code>
            // get the channel info of the decoding stream
            BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(streamDecoding);
            // set the source rate
            BassAsio.BASS_ASIO_ChannelSetRate(false, 0, (double)info.freq);
            // try to set the device rate too (saves resampling)
            BassAsio.BASS_ASIO_SetRate( (double)info.freq );
            </code>
            <code lang="vbnet">
            ' get the channel info of the decoding stream
            Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(streamDecoding)
            ' set the source rate
            BassAsio.BASS_ASIO_ChannelSetRate(False, 0, CDbl(info.freq))
            ' try to set the device rate too (saves resampling)
            BassAsio.BASS_ASIO_SetRate(CDbl(info.freq))
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_StartOld(System.Int32)">
            <summary>
            
            </summary>
            <param name="buflen"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_StartInternal(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="buflen"></param>
            <param name="threads"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)">
            <summary>
            Starts the current Asio device.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length (use -1 to request the preferred buffer length).</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Before starting the device, channels must be enabled using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/>. Once started, channels can't be enabled or disabled until the device is stopped, using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/>.
            <para>The default number of processing threads is 1, which means that the enabled channels' ASIOPROC functions get called in series (starting with the lowest input channel). 
            Multiple channels can be processed in parallel if multiple threads are created for that purpose via the threads parameter. 
            All input channels will be processed before any output channels are, so that full duplex is unaffected. The number of threads is automatically capped at the number required to process all enabled channels simultaneously.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been started.</description></item>
            <item><term>BASS_ERROR_NOCHAN</term><description>No channels have been enabled.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// and join the next channels to it
            	BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the Garbage Collector
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the Garbage Collector
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32,System.Int32)">
            <summary>
            Starts the current Asio device.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length (use -1 to request the preferred buffer length).</param>
            <param name="threads">The number of processing threads to use... 0 = use current number.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Before starting the device, channels must be enabled using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/>. Once started, channels can't be enabled or disabled until the device is stopped, using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/>.
            <para>The default number of processing threads is 1, which means that the enabled channels' ASIOPROC functions get called in series (starting with the lowest input channel). 
            Multiple channels can be processed in parallel if multiple threads are created for that purpose via the threads parameter. 
            All input channels will be processed before any output channels are, so that full duplex is unaffected. The number of threads is automatically capped at the number required to process all enabled channels simultaneously.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>The device has already been started.</description></item>
            <item><term>BASS_ERROR_NOCHAN</term><description>No channels have been enabled.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// and join the next channels to it
            	BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the Garbage Collector
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the Garbage Collector
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_IsStarted">
            <summary>
            Checks, if the current Asio device has been started.
            </summary>
            <returns>Returns <see langword="true"/>, if the device has been started, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Lock(System.Boolean)">
            <summary>
            Locks the device to the current thread.
            </summary>
            <param name="dolock">If <see langword="false"/>, unlock the device, else lock it.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Locking a device prevents other threads from performing most functions on it, including the channel processing. 
            Other threads wanting to access a locked device will block until it is unlocked, so it should only be locked very briefly. 
            A device must be unlocked in the same thread that it was locked.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ControlPanel">
            <summary>
            Displays the current Asio driver's control panel.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_CheckRate(System.Double)">
            <summary>
            Checks if a sample rate is supported by the device.
            </summary>
            <param name="rate">The sample rate to check.</param>
            <returns>If the sample rate is supported, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The sample rate is not supported by the device/drivers.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetRate">
            <summary>
            Retrieves the current Asio device's sample rate.
            </summary>
            <returns>If succesful, the sample rate is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetLatency(System.Boolean)">
            <summary>
            Retrieves the latency of input or output channels of the current Asio device
            </summary>
            <param name="input">Get the input latency? <see langword="false"/>=the output latency.</param>
            <returns>If successful, the latency in samples is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The latency is the delay between the sound being recorded and reaching an <see cref="T:Un4seen.BassAsio.ASIOPROC"/>, in the case of input channels. And the delay between the sample data being fed to an <see cref="T:Un4seen.BassAsio.ASIOPROC"/> and actually being heard, in the case of output channels. 
            The latency is dependant on the buffer size, as specified in the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> call. So the latency should be checked after making that call, not before.</para>
            <para>The latency time can by calculated be dividing the sample latency by the device sample rate. When a channel is being resampled, the sample latency will change, but the effective latency time remains constant.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the input and output latency, in milliseconds:
            <code>
            // get the sample rate
            double rate = BassAsio.BASS_ASIO_GetRate();
            Console.WriteLine("Input Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(true) * 1000.0 / rate);
            Console.WriteLine("Output Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(false) * 1000.0 / rate);
            </code>
            <code lang="vbnet">
            Dim rate As Double = BassAsio.BASS_ASIO_GetRate()
            Console.WriteLine("Input Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(True) * 1000.0 / rate)
            Console.WriteLine("Output Latency = {0} ms", BassAsio.BASS_ASIO_GetLatency(False) * 1000.0 / rate)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetCPU">
            <summary>
            Retrieves the current CPU usage of BASSASIO.
            </summary>
            <returns>The BASSASIO CPU usage as a percentage of total CPU time.</returns>
            <remarks>This function includes the time taken by the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback functions.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Monitor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the direct input monitoring state.
            </summary>
            <param name="input">The input channel to set the monitoring state of... -1 = all.</param>
            <param name="output">The suggested output channel for the monitoring.</param>
            <param name="gain">Suggested Gain, ranging from 0 to 0x7fffffff (-inf to +12 dB), 0x20000000 equals 0 dB.</param>
            <param name="state">Monitoring state... 0 = off, 1 = on. Other settings may be possible depending on the drivers, e.g.:
            <para>0 = input monitoring off.</para>
            <para>1 = input monitoring on.</para>
            <para>2 = playback monitoring off.</para>
            <para>3 = playback monitoring on.</para>
            </param>
            <param name="pan">Suggested Pan, ranging from 0 = left to 0x7fffffff = right (centre should be 0x40000000).</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>If the hardware does not support patching and mixing a straight 1 to 1 routing is suggested. 
            The driver should ignore all the information of ASIOMonitor it cannot deal with, usually these might be either or all of output, gain, pan.
            <para>Output is the base channel of a stereo channel pair, i.e. output is always an even channel (0,2,4...). 
            If an odd input channel should be monitored and no panning or output routing can be applied, the driver has to use the next higher output (imply a hard right pan).
            Note that the output, gain and pan settings are just suggestions, and may be ignored by the device/driver.</para>
            <para>Some cards/drivers might also support direct output monitoring, in such case use the <paramref name="input"/> parameter to denote the output channel to monitor and specify an appropriate <paramref name="state"/> value.</para>
            <para>ADM has originally been based on a mono in - stereo out scheme. Meaning if you need to monitor a stereo input channel pair you need to call this twice, both using the same output value, but using an odd and an even input value.
            In such case set the odd input to pan hard left and the even input to pan hard right.</para>
            <para>Also note, that if you have channels in-between not activated in ASIO these will not counted. 
            So if for example channels 3 and 4 are inactive, ADM input 3 is related to the physical input channel 5!</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetNotify(Un4seen.BassAsio.ASIONOTIFYPROC,System.IntPtr)">
            <summary>
            Sets a notification callback on the ASIO driver.
            </summary>
            <param name="proc">User defined notification function... NULL = disable notifications.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            A previously set notification callback can be changed (or removed) at any time, by calling this function again.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(System.Int32,System.IntPtr)">
            <summary>
            Provides access to the driver's 'future' function.
            </summary>
            <param name="selector">Operation code.</param>
            <param name="param">Pointer to the operation's parameters, if applicable.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks> This method is a general purpose extension method serving various purposes (e.g. see <see cref="T:Un4seen.BassAsio.BASSASIOFuture"/>).
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The <paramref name="selector"/> is not supported by the driver.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(Un4seen.BassAsio.BASSASIOFuture,System.Object)">
            <summary>
            Provides access to the driver's 'future' function.
            </summary>
            <param name="selector">Operation code.</param>
            <param name="param">Pointer to the operation's parameters, if applicable.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks> This method is a general purpose extension method serving various purposes (e.g. see <see cref="T:Un4seen.BassAsio.BASSASIOFuture"/>).
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The <paramref name="selector"/> is not supported by the driver.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDSD(System.Boolean)">
            <summary>
            Sets the device's sample format to DSD or PCM.
            </summary>
            <param name="dsd">Set the sample format to DSD?</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            When a device is switched between PCM and DSD formats, the ASIO channels' format will change accordingly, as reported by <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/>.
            Any <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetFormat(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOFormat)"/> and <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)"/> settings that have been applied will be reset to defaults. 
            Other channel settings are unchanged.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>DSD is not supported by the device/driver.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)">
            <summary>
            Retrieves information on an Asio channel.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> class to store the information at.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the information of all channels:
            <code>
            BASS_ASIO_CHANNELINFO info = new BASS_ASIO_CHANNELINFO();
            int chan = 0;
            while (true)
            {
            	if (!BassAsio.BASS_ASIO_ChannelGetInfo(false, chan, info))
            		break;
            	Console.WriteLine( info.ToString() );
            	chan++;
            }
            </code>
            <code lang="vbnet">
            Dim info As New BASS_ASIO_CHANNELINFO()
            Dim chan As Integer = 0
            While True
              If Not BassAsio.BASS_ASIO_ChannelGetInfo(False, chan, info) Then
                Exit While
              End If
              Console.WriteLine(info.ToString())
              chan += 1
            End While
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32)">
            <summary>
            Retrieves information on an Asio channel.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If successful, an instance of the <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Display the information of the first channel:
            <code>
            BASS_ASIO_CHANNELINFO info = BassAsio.BASS_ASIO_ChannelGetInfo(false, 0);
            if (info != null)
            {
              Console.WriteLine( info.ToString() );
            }
            </code>
            <code lang="vbnet">
            Dim info As BASS_ASIO_CHANNELINFO = BassAsio.BASS_ASIO_ChannelGetInfo(False, 0)
            If Not (info Is Nothing) Then
              Console.WriteLine(info.ToString())
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)">
            <summary>
            Enable/disable processing of an Asio channel.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="proc">The user defined function to process the channel... <see langword="null"/> = disable the channel.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>All ASIO channels are mono. Stereo (and above) channels can be formed by joining multiple channels together using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)"/>.</para>
            <para>Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> to begin processing the enabled channels.</para>
            <para>You might also use this function on an already enabled ASIO channel if you just want to change the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> which should be used.
            However changing the callback procedure to <see langword="null"/> would disable the channel - which is only possible, if the ASIO device is stopped.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before (dis)enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// and join the next channels to it
            	BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            	// since we joined the channels, the next commands will apply to all channles joined
            	// so setting the values to the first channels changes them all automatically
            	// set the source format (float, as the decoding channel is)
            	BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the Garbage Collector
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
              ' since we joined the channels, the next commands will apply to all channles joined
              ' so setting the values to the first channels changes them all automatically
              ' set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the Garbage Collector
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnableBASS(System.Boolean,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Enables a channel, and sets it to use a BASS channel.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="handle">The BASS channel handle.</param>
            <param name="join">Join the next ASIO channels according to the number of audio channels in the BASS channel?</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows BASS channels to be used directly, without needing an <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback function. 
            The ASIO channel's format and rate are set accordingly. If the BASS channel is not mono then multiple ASIO channels should also be joined accordingly. 
            That can be done automatically via the <paramref name="join"/> parameter, or manually with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)"/>. 
            If the device does not have enough channels, the BASSmix add-on can be used to downmix the BASS channel.</para>
            <para>In the case of output channels, the BASS channel must have the BASS_STREAM_DECODE flag set. 
            In the case of input channels, the BASS channel must be a 'push' stream, created with <see cref="M:Un4seen.Bass.Bass.BASS_StreamCreatePush(System.Int32,System.Int32,Un4seen.Bass.BASSFlag,System.IntPtr)"/>, which will receive the data from the input channel(s).</para>
            <para>Raw DSD streams are supported (with the BASSDSD add-on) but the device needs to have been successfully set to DSD mode first with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDSD(System.Boolean)"/>. 
            The device's sample rate should also be set to the DSD stream's rate (its BASS_ATTRIB_DSD_RATE attribute) via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetRate(System.Double)"/>.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS library is not loaded.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before (dis)enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            <item><term>BASS_ERROR_HANDLE</term><description><paramref name="handle"/> is invalid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>8-bit BASS channels are not supported; the BASS_SAMPLE_FLOAT flag can be used to avoid them.</description></item>
            <item><term>BASS_ERROR_NOCHAN</term><description>The device does not have enough channels to accommodate the BASS channel.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)">
            <summary>
            Join a channel to another.
            </summary>
            <param name="input">Dealing with input channels? <see langword="false"/> = output channels.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="channel2">The channel to join it to... -1 = remove current join.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>All ASIO channels are mono. By joining them, stereo (and above) channels can be formed, making it simpler to process stereo (and above) sample data.</para>
            <para>By default, channels can only be joined to preceding channels. For example, channel 1 can be joined to channel 0, but not vice versa.
            The BASS_ASIO_JOINORDER flag can be used in the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call to remove that restriction. When joining a group of channels, there should be one channel enabled via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> with the rest joined to it - 
            do not join a channel to a channel that is itself joined to another channel. Mirror channels, setup using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnableMirror(System.Int32,System.Boolean,System.Int32)"/>, cannot be joined with.</para>
            <para>If a channel has two or more other channels joined to it, then the joined channels will default to being in numerically ascending order in the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback function's sample data unless the BASS_ASIO_JOINORDER flag was used in the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call, 
            in which case they will be in the order in which they were joined via this function. In the latter case, if this function is called on an already joined channel, the channel will be moved to the end of the joined group.</para>
            <para>While a channel is joined to another, it automatically takes on the attributes of the other channel - the other channel's settings determine the sample format, the sample rate and whether it is enabled.
            The volume setting remains individual though, allowing balance control over the joined channels.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before (dis)enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>It is not possible to join channels that do not have the same sample format.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // enable processing of output channel 0
            BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, 0);
            // join channel 1 to it
            BassAsio.BASS_ASIO_ChannelJoin(false, 1, 0);
            </code>
            <code lang="vbnet">
            ' enable processing of output channel 0
            BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, 0)
            ' join channel 1 to it
            BassAsio.BASS_ASIO_ChannelJoin(False, 1, 0)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetFormat(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOFormat)">
            <summary>
            Sets a channel's sample format.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="format">The sample format. One of the following (see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/>):
            <list type="table">
            <item><term>BASS_ASIO_FORMAT_16BIT</term><description>16-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_24BIT</term><description>24-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_32BIT</term><description>32-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_FLOAT</term><description>32-bit floating-point.</description></item>
            <item><term>BASS_ASIO_FORMAT_DSD_LSB</term><description>DSD with LSB first.</description></item>
            <item><term>BASS_ASIO_FORMAT_DSD_MSB</term><description>DSD with MSB first.</description></item>
            <item><term>BASS_ASIO_FORMAT_DITHER</term><description>flag: apply dither (TDPF) to the output.</description></item>
            </list>
            </param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>The sample format can vary between ASIO devices/drivers, which could mean a lot of extra/duplicate code being required. To avoid that extra work, BASSASIO can automatically convert the sample data, whenever necessary, to/from a format of your choice. 
            The native format of a channel can be retrieved via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/>.</para>
            <para>The PCM format options are only available when the device's format is PCM, and the DSD format options are only available when the device's format is DSD. 
            If a device supports both, it can be switched between DSD and PCM via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetDSD(System.Boolean)"/>.</para>
            <para>For performance reasons, it's best not to use 24-bit sample data whenever possible, as 24-bit data requires a bit more processing than the other formats.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="format"/> is.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Format conversion is not available for the channel's native sample format (please report).</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set output channel 0 to use floating-point sample data:
            <code>
            BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)">
            <summary>
            Sets a channel's sample rate.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="rate">The sample rate... 0 = device rate.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>For optimal quality and performance, it is best to set the device to the sample rate you want via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetRate(System.Double)"/>, but that's not always possible. 
            Which is where this function and resampling comes into play. 16 point sinc interpolation is used, giving a good blend of sound quality and performance. It is also SSE2 and 3DNow optimized for an extra boost with supporting CPUs.</para>
            <para>When a channel's sample rate is the same as the device rate, resampling is bypassed, so there's no unnecessary performance hit.</para>
            <para>Resampling is not supported when the sample format is DSD.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="rate"/> is below 0.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Format conversion is not available for the channel's native sample format (please report).</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // set the device rate
            BassAsio.BASS_ASIO_SetRate(44100);
            // set the channel's rate
            BassAsio.BASS_ASIO_ChannelSetRate(false, 0, 44100);
            </code>
            <code lang="vbnet">
            ' set the device rate
            BassAsio.BASS_ASIO_SetRate(44100)
            ' set the channel's rate
            BassAsio.BASS_ASIO_ChannelSetRate(False, 0, 44100)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)">
            <summary>
            Resets the attributes of a channel (or all channels).
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first, -1 = all channels.</param>
            <param name="flags">The attributes to reset. A combination of the following (see <see cref="T:Un4seen.BassAsio.BASSASIOReset"/>):
            <list type="table">
            <item><term>BASS_ASIO_RESET_ENABLE</term><description>Disable the channel.</description></item>
            <item><term>BASS_ASIO_RESET_JOIN</term><description>Unjoin the channel.</description></item>
            <item><term>BASS_ASIO_RESET_PAUSE</term><description>Unpause the channel.</description></item>
            <item><term>BASS_ASIO_RESET_FORMAT</term><description>Set the channel's sample format to the native format.</description></item>
            <item><term>BASS_ASIO_RESET_RATE</term><description>Set the channel's sample rate to the device rate.</description></item>
            <item><term>BASS_ASIO_RESET_VOLUME</term><description>Set the channel's volume to normal (1.0).</description></item>
            <item><term>BASS_ASIO_RESET_JOINED</term><description>Also reset any channels that are joined to the specified channel. This can be used in combination with BASS_ASIO_RESET_JOIN to unjoin all channels from the specified one.</description></item>
            </list>
            </param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>When resetting all channels (channel = -1), the resetting only applies to all channels of the specified type, ie. input or output, not both.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="flags"/> is.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before disabling or unjoining channels.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Disable all output channels and remove all joins between them:
            <code>
            BassAsio.BASS_ASIO_ChannelReset(false, -1, BASSASIOReset.BASS_ASIO_RESET_ENABLE | BASSASIOReset.BASS_ASIO_RESET_JOIN);
            </code>
            <code lang="vbnet">
            BassAsio.BASS_ASIO_ChannelReset(False, -1, BASSASIOReset.BASS_ASIO_RESET_ENABLE Or BASSASIOReset.BASS_ASIO_RESET_JOIN);
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelPause(System.Boolean,System.Int32)">
            <summary>
            Suspends processing of a channel (or all channels).
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first, -1 = all channels.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Channels can only be disabled when the device is stopped. When you want to stop processing only some of the enabled channels, there are few ways that could be done. You could quickly stop the device, disable the unwanted channels, and restart the device. 
            In the case of output channels, you could fill the channels' buffers with silence (0s) in the <see cref="T:Un4seen.BassAsio.ASIOPROC"/>. Or you could pause the channels, using this function. 
            The less channels BASSASIO has to process, the less CPU it'll use, so stopping and restarting the device would be the most efficient, but that could cause a slight break in the sound of the other channels. 
            Filling the buffers with silence is the least efficient, as BASSASIO will still process the data as if it was "normal", but it does mean that other channels are unaffected. 
            Pausing is a compromise between the two - the channels will still be enabled, but BASSASIO will bypass any additional processing (resampling/etc) that may normally be required.</para>
            <para>Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)"/> to resume processing of a paused channel.</para>
            <para>When pausing all channels (channel = -1), it only applies to all channels of the specified type, ie. input or output, not both.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelIsActive(System.Boolean,System.Int32)">
            <summary>
            Checks if a channel is enabled for processing.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>The return value is one of the folowing (see <see cref="T:Un4seen.BassAsio.BASSASIOActive"/>):
            <list type="table">
            <item><term>BASS_ASIO_ACTIVE_DISABLED</term><description>The channel is not enabled.</description></item>
            <item><term>BASS_ASIO_ACTIVE_ENABLED</term><description>The channel is enabled.</description></item>
            <item><term>BASS_ASIO_ACTIVE_PAUSED</term><description>The channel is enabled and paused.</description></item>
            </list>
            </returns>
            <remarks>
            When a channel is joined to another, the status of the other channel is returned, as that is what determines whether the channel is enabled for processing - whether it's been enabled itself is of no consequence while it is joined to another. 
            For example, if channel B is joined to channel A, and channel A is not enabled, then neither is channel B.
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetFormat(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's sample format.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If an error occurs, -1 (BASS_ASIO_FORMAT_UNKNOWN) is returned, use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.
            <para>If successful, one of the following is returned (see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/>):
            <list type="table">
            <item><term>BASS_ASIO_FORMAT_16BIT</term><description>16-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_24BIT</term><description>24-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_32BIT</term><description>32-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_FLOAT</term><description>32-bit floating-point.</description></item>
            <item><term>BASS_ASIO_FORMAT_DSD_LSB</term><description>DSD with LSB first.</description></item>
            <item><term>BASS_ASIO_FORMAT_DSD_MSB</term><description>DSD with MSB first.</description></item>
            <item><term>BASS_ASIO_FORMAT_UNKNOWN</term><description>Unknown format, an error occured.</description></item>
            </list>
            </para>
            </returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetRate(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's sample rate.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <returns>If succesful, the channel's sample rate is returned (0 = device rate), else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetLevel(System.Boolean,System.Int32)">
            <summary>
            Retrieves the level (peak amplitude) of a channel.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first. The <see cref="F:Un4seen.BassAsio.BASSASIOLevel.BASS_ASIO_LEVEL_RMS"/> flag can optionally be used to get the RMS level, otherwise the peak level is given.</param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code. 
            If successful, the level of the channel is returned, ranging from 0 (silent) to 1 (max). If the channel's native sample format is floating-point, it is actually possible for the level to go above 1.</returns>
            <remarks>This function measures the level of a single channel, and is not affected by any other channels that are joined with it.
            <para>Volume settings made via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)"/> affect the level reading of output channels, but not input channels.</para>
            <para>When an input channel is paused, it is still possible to get its level. Paused output channels will have a level of 0.</para>
            <para>Level retrieval is not supported when the sample format is DSD.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device hasn't been started, or the channel isn't enabled.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Level retrieval is not supported for the channel's sample format (please report).</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            // get the linear level
            float level = BassAsio.BASS_ASIO_ChannelSetVolume(false, 0);
            // translate it to logarithmic dB 
            double db = 20.0 * Math.Log10(level);
            </code>
            <code lang="vbnet">
            ' get the linear level
            Dim level As Single = BassAsio.BASS_ASIO_ChannelSetVolume(False, 0)
            ' translate it to logarithmic dB 
            Dim db As Double = 20.0 * Math.Log10(level)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnableMirror(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Enables an output channel, and makes it mirror another channel.
            </summary>
            <param name="channel">The output channel number... 0 = first.</param>
            <param name="input2">Mirroring an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel2">The channel to mirror.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This function allows an input or output channel to be duplicated in other output channel. This can be achieved using normal <see cref="T:Un4seen.BassAsio.ASIOPROC"/> processing, but it's more efficient to let BASSASIO simply copy the data from one channel to another.</para>
            <para>Mirror channels can't be joined together to form multi-channel mirrors. Instead, to mirror multiple channels, an individual mirror should be setup for each of them.</para>
            <para>After <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> has been called to begin processing, it's not possible to setup new mirror channels, but it is still possible to change the channel that a mirror is mirroring.</para>
            <para>When mirroring an output channel that hasn't been enabled, the mirror channel will just produce silence. When mirroring an input channel that hasn't already been enabled, the channel is automatically enabled for processing when <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> is called, so that it can be mirrored. 
            If the mirror is switched to a disabled input channel once processing has begun, then it will produce silence.</para>
            <para>A mirror channel can be made to have a different volume level to the channel that it's mirroring, using <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)"/>. The volume setting is cumulative. 
            For example, if the mirror channel has a volume setting of 0.5 and the mirrored channel has a volume setting of 0.4, the effective volume of the mirror channel will be 0.2 (0.5 x 0.4).</para>
            <para><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> can be used to disable a mirror channel.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device has been started - it needs to be stopped before enabling channels.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>At least one of the channels is invalid.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>It is not possible to mirror channels that do not have the same sample format.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Enable output channel 0, and mirror it to channel 1 for stereo output:
            <code>
            using Un4seen.Bass;
            using Un4seen.BassAsio;
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// now setup ASIO
            	_myAsioProc = new ASIOPROC(AsioCallback);
            	// enable 1st output channel...(0=first)
            	BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
            	// mirror it to channel 1
            	BassAsio.BASS_ASIO_ChannelEnableMirror(1, false, 0);
            	// and start playing it...start output using default buffer/latency
            	BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the GC
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
            	// Note: 'user' contains the underlying stream channel (see above)
            	// We can simply use the bass method to get some data from a decoding channel 
            	// and store it to the asio buffer in the same moment...
            	return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Imports Un4seen.Bass
            Imports Un4seen.BassAsio
            ...
            Bass.BASS_Init(-1, 44100, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile("test.mp3", 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AddressOf AsioCallback)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              // mirror it to channel 1
              BassAsio.BASS_ASIO_ChannelEnableMirror(1, False, 0)
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the GC
            Private Function AsioCallback(input As Boolean, channel As Integer, buffer As IntPtr, 
                                          length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)">
            <summary>
            Sets a channel's volume.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first, -1 = master.</param>
            <param name="volume">The volume level... 0 (silent)...1.0 (normal). Above 1.0 amplifies the sound.</param>
            <returns>If succesful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para></para>
            <para>Apart from the master volume (channel = -1), this function applies a volume level to a single channel, and does not affect any other channels that are joined with it. 
            This allows balance control over joined channels, by setting the individual volume levels accordingly. The final level of a channel is <i>master volume x channel volume</i>.</para>
            <para>The volume "curve" is linear, but logarithmic levels can be easily used. See the example below.</para>
            <para>ASIO drivers do not provide volume control themselves, so the volume adjustments are applied to the sample data by BASSASIO. 
            This also means that changes do not persist across sessions, and the channel volume levels will always start at 1.0.</para>
            <para>When the channel's sample format is DSD, a 0 volume setting will mute the channel and anything else will be treated as 1.0 (normal).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid, or <paramref name="volume"/> is below 0.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            Set a logarithmic volume level:
            <code>
            // translate logarithmic dB level to linear
            float volume = (float)Math.Pow(10d, db / 20d);
            // apply it
            BassAsio.BASS_ASIO_ChannelSetVolume(false, 0 , volume);
            </code>
            <code lang="vbnet">
            ' translate logarithmic dB level to linear
            Dim volume As Single = CSng(Math.Pow(10.0, db / 20.0))
            ' apply it
            BassAsio.BASS_ASIO_ChannelSetVolume(False, 0, volume)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetVolume(System.Boolean,System.Int32)">
            <summary>
            Retrieves a channel's volume setting.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first, -1 = master.</param>
            <returns>If successful, the channel's volume setting is returned, else -1 is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>To set a channel volume use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetVolume(System.Boolean,System.Int32,System.Single)"/>.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>The <paramref name="input"/> and <paramref name="channel"/> combination is invalid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsio.BASSASIOVERSION">
            <summary>
            Current BASSASIO version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOInit">
            <summary>
            Initialization flags to be used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOInit.BASS_ASIO_DEFAULT">
            <summary>
            Host the driver in the current thread.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOInit.BASS_ASIO_THREAD">
            <summary>
            Host the driver in a dedicated thread.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOInit.BASS_ASIO_JOINORDER">
            <summary>
            Order joined channels by when they were joined.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOInit.BASS_ASIO_VOLRAMP">
            <summary>
            Ramp volume changes (of output channels)?
            <para>Volume changes take effect from the next ASIO buffer update cycle.
            BASSASIO doesn't currently ramp volume changes, so there will be a sudden jump/step between the old and new levels, which can cause a click if the step is large.</para>
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOFormat">
            <summary>
            BassAsio sample formats to be used with <see cref="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO"/> and <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_UNKNOWN">
            <summary>
            Unknown format. Error.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_16BIT">
            <summary>
            16-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_24BIT">
            <summary>
            24-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_32BIT">
            <summary>
            32-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT">
            <summary>
            32-bit floating-point.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_DSD_LSB">
            <summary>
            DSD (LSB 1st)
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_DSD_MSB">
            <summary>
            DSD (MSB 1st)
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFormat.BASS_ASIO_FORMAT_DITHER">
            <summary>
            Flag: apply dither (TPDF) when converting from floating-point to integer.
            <para>Dither is optional rather than automatic because it destroys bit-perfect output; you probably don't want to enable it unless you're applying DSP (including volume changes).
            When the output is floating-point (eg. in shared mode), the flag will have no effect.</para>
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOReset">
            <summary>
            BassAsio attributes to be used when to reset a channel with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_ENABLE">
            <summary>
            Disable the channel.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_JOIN">
            <summary>
            Unjoin the channel.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_PAUSE">
            <summary>
            Unpause the channel.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_FORMAT">
            <summary>
            Set the channel's sample format to the native format.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_RATE">
            <summary>
            Set the channel's sample rate to the device rate.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_VOLUME">
            <summary>
            Reset volume to 1.0
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOReset.BASS_ASIO_RESET_JOINED">
            <summary>
            Flag: apply to joined channels too
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOActive">
            <summary>
            BassAsio active values return by <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelIsActive(System.Boolean,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOActive.BASS_ASIO_ACTIVE_DISABLED">
            <summary>
            The channel is not enabled.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOActive.BASS_ASIO_ACTIVE_ENABLED">
            <summary>
            The channel is enabled.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOActive.BASS_ASIO_ACTIVE_PAUSED">
            <summary>
            The channel is enabled and paused.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIONotify">
            <summary>
            BassAsio notify values as used in the <see cref="T:Un4seen.BassAsio.ASIONOTIFYPROC"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIONotify.BASS_ASIO_NOTIFY_RATE">
            <summary>
            The device's sample rate has changed. The new rate is available from <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetRate"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIONotify.BASS_ASIO_NOTIFY_RESET">
            <summary>
            The driver has requested a reset/reinitialization; for example, following a change of the default buffer size. This request can be ignored, but if a reinitialization is performed, it should not be done within the callback.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOFuture">
            <summary>
            BassAsio Future values that might be used with the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(System.Int32,System.IntPtr)"/> method.
            <para>Note: Other/Additional values might be possible - see your drivers manual for details.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_EnableTimeCodeRead">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_DisableTimeCodeRead">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_SetInputMonitor">
            <summary>
            ASIOInputMonitor* in params
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_Transport">
            <summary>
            ASIOTransportParameters* in params
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_SetInputGain">
            <summary>
            ASIOChannelControls* in params, apply gain
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_GetInputMeter">
            <summary>
            ASIOChannelControls* in params, fill meter
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_SetOutputGain">
            <summary>
            ASIOChannelControls* in params, apply gain
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_GetOutputMeter">
            <summary>
            ASIOChannelControls* in params, fill meter
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanInputMonitor">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanTimeInfo">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanTimeCode">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanTransport">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanInputGain">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanInputMeter">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanOutputGain">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanOutputMeter">
            <summary>
            No arguments
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_SetIoFormat">
            <summary>
            DSD support: ASIOIoFormat * in params
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_GetIoFormat">
            <summary>
            DSD support: ASIOIoFormat * in params
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOFuture.BASS_ASIO_FUTURE_CanDoIoFormat">
            <summary>
            DSD support: ASIOIoFormat * in params
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASSASIOLevel">
            <summary>
            Level retrieval flags (to be used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetLevel(System.Boolean,System.Int32)"/>).
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOLevel.BASS_ASIO_LEVEL_PEAK">
            <summary>
            Retrieves peak levels
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASSASIOLevel.BASS_ASIO_LEVEL_RMS">
            <summary>
            Optional Flag: If set it returns RMS levels instead of peak leavels
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDeviceInfo(System.Int32,Un4seen.BassAsio.BASS_ASIO_DEVICEINFO)"/> to retrieve information on an asio device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.driver">
            <summary>
            The filename of the driver being used.
            <para>Further information can be obtained from the file using the GetFileVersionInfo Win32 API function.</para>
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_DEVICEINFO.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns>A description of the decive info object (name).</returns>
        </member>
        <member name="T:Un4seen.BassAsio.BASS_ASIO_INFO">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetInfo(Un4seen.BassAsio.BASS_ASIO_INFO)"/> to retrieve information on the current device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.name">
            <summary>
            The name of the device/driver.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.version">
            <summary>
            The driver version.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.inputs">
            <summary>
            The number of input channels available.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.outputs">
            <summary>
            The number of output channels available.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufmin">
            <summary>
            The minimum buffer length, in samples.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufmax">
            <summary>
            The maximum buffer length, in samples.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufpref">
            <summary>
            The preferred/default buffer length, in samples.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.bufgran">
            <summary>
            The buffer length granularity, that is the smallest possible length change... -1 = the possible buffer lengths increase in powers of 2.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_INFO.initflags">
            <summary>
            The flags parameter of the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_INFO.ToString">
            <summary>
            A description of the decive info object (the driver/device name).
            </summary>
            <returns>The name of the device/driver.</returns>
        </member>
        <member name="T:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelGetInfo(System.Boolean,System.Int32,Un4seen.BassAsio.BASS_ASIO_CHANNELINFO)"/> to retrieve information on the current device.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.group">
            <summary>
            The channel's group.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.format">
            <summary>
            The channel's sample format, one of the following (see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/>):
            <list type="table">
            <item><term>BASS_ASIO_FORMAT_16BIT</term><description>16-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_24BIT</term><description>24-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_32BIT</term><description>32-bit integer.</description></item>
            <item><term>BASS_ASIO_FORMAT_FLOAT</term><description>32-bit floating-point.</description></item>
            <item><term>BASS_ASIO_FORMAT_DSD_LSB</term><description>DSD with LSB first.</description></item>
            <item><term>BASS_ASIO_FORMAT_DSD_MSB</term><description>DSD with MSB first.</description></item>
            </list>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.name">
            <summary>
            The name of the channel.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BASS_ASIO_CHANNELINFO.ToString">
            <summary>
            A description of the channel info object (name).
            </summary>
            <returns>The name of the channel.</returns>
        </member>
        <member name="T:Un4seen.BassAsio.ASIOInputMonitor">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(System.Int32,System.IntPtr)"/> and the SetInputMonitor selector.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOInputMonitor.input">
            <summary>
            this input was set to monitor (or off), -1: all
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOInputMonitor.output">
            <summary>
            suggested output for monitoring the input (if so)
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOInputMonitor.gain">
            <summary>
            suggested gain, ranging 0 - 0x7fffffffL (-inf to +12 dB)
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOInputMonitor.state">
            <summary>
            TRUE = on, FALSE = off
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOInputMonitor.pan">
            <summary>
            suggested pan, 0 = all left, 0x7fffffff = right
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.ASIOInputMonitor.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.ASIOChannelControls">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(System.Int32,System.IntPtr)"/> and the Get/SetInput resp. Get/SetOutput selector.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOChannelControls.channel">
            <summary>
            the channel index
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOChannelControls.isInput">
            <summary>
            TRUE = input, FALSE = Output
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOChannelControls.gain">
            <summary>
            the gain value, ranging 0 - 0x7fffffffL (-inf to +12 dB)
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOChannelControls.meter">
            <summary>
            returned meter value, ranging 0 - 0x7fffffffL (-inf to +12 dB)
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOChannelControls.future">
            <summary>
            up to 32 chars
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.ASIOChannelControls.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.ASIOTransportParameters">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(System.Int32,System.IntPtr)"/> and the Transport selector.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOTransportParameters.command">
            <summary>
            One of the following command values (other might be optinally available):
            <para>
            <list type="table">
            <item><term>Start</term><description>1</description></item>
            <item><term>Stop</term><description>2</description></item>
            <item><term>Locate</term><description>3</description></item>
            <item><term>PunchIn</term><description>4</description></item>
            <item><term>PunchOut</term><description>5</description></item>
            <item><term>ArmOn</term><description>6</description></item>
            <item><term>ArmOff</term><description>7</description></item>
            <item><term>MonitorOn</term><description>8</description></item>
            <item><term>MonitorOff</term><description>9</description></item>
            <item><term>Arm</term><description>10</description></item>
            <item><term>Monitor</term><description>11</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOTransportParameters.samplePosition">
            <summary>
            number of samples data type is 64 bit integer
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOTransportParameters.track">
            <summary>
            track index
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOTransportParameters.trackSwitches">
            <summary>
            512 tracks on/off
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOTransportParameters.future">
            <summary>
            up to 64 chars
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.ASIOTransportParameters.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.ASIOIoFormat">
            <summary>
            Used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Future(System.Int32,System.IntPtr)"/> and the DSD IoFormat selector.
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOIoFormat.formatType">
            <summary>
            One of the following format values:
            <para>
            <list type="table">
            <item><term>FormatInvalid</term><description>-1</description></item>
            <item><term>PCMFormat </term><description>0</description></item>
            <item><term>DSDFormat </term><description>1</description></item>
            </list>
            </para>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.ASIOIoFormat.future">
            <summary>
            up to 508 chars
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.ASIOIoFormat.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.ASIOPROC">
            <summary>
            User defined ASIO channel callback function (to be used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/>).
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel.</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data (input channel), or in which to put the data to output (output channel).</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> was called.</param>
            <returns>In the case of an output channel, the number of bytes written to the buffer (a negative number will be treated as 0). The return value is ignored with input channels.</returns>
            <remarks>
            <para>ASIO is a low latency system, so a channel callback function should obviously be as quick as possible. <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetCPU"/> can be used to monitor that.</para>
            <para>When multiple channels are joined together, the sample data of the channels is interleaved; the channel that was enabled via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> comes first, followed by the channels that have been joined to it.
            The order of the joined channels defaults to numerically ascending order unless the BASS_ASIO_JOINORDER flag was used in the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Init(System.Int32,Un4seen.BassAsio.BASSASIOInit)"/> call, in which case they will be in the order in which <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelJoin(System.Boolean,System.Int32,System.Int32)"/> was called to join then.</para>
            <para>When an output channel's function returns less data than requested, the remainder of the buffer is filled with silence, and some processing is saved by that. 
            When 0 is returned, the level of processing is the same as if the channel had been paused with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelPause(System.Boolean,System.Int32)"/>, ie. the ASIO buffer is simply filled with silence and all additional processing (resampling/etc) is bypassed.</para>
            <para>ASIO is a low latency system, so a channel callback function should obviously be as quick as possible. 
            <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetCPU"/> can be used to monitor that. Do not call the <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/> or <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Free"/> functions from within an ASIO callback. 
            Also, if it is an output channel, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetFormat(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOFormat)"/> and <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelSetRate(System.Boolean,System.Int32,System.Double)"/> should not be used on the channel being processed by the callback.</para>
            <para>Prior to calling this function, BASSASIO will set the thread's device context to the device that the channel belongs to. So when using multiple devices, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDevice"/> can be used to determine which device the channel is on.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            </remarks>
            <example>
            Streaming a file via BASS to ASIO:
            <code>
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              // now setup ASIO
              _myAsioProc = new ASIOPROC(AsioCallback);
              // get the stream channel info
              BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
              // enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, new IntPtr(stream));
              // and join the next channels to it
              for (int a=1; a&lt;info.chans; a++)
                BassAsio.BASS_ASIO_ChannelJoin(false, a, 0);
              // since we joined the channels, the next commands will apply to all channles joined
              // so setting the values to the first channels changes them all automatically
              // set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
              // set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(false, 0, (double)info.freq);
              // try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate( (double)info.freq );
              // and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0);
            }
            ...
            private ASIOPROC _myAsioProc; // make it global, so that it can not be removed by the GC
            private int AsioCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
              // Note: 'user' contains the underlying stream channel (see above)
              // We can simply use the bass method to get some data from a decoding channel 
              // and store it to the asio buffer in the same moment...
              return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length);
            }
            </code>
            <code lang="vbnet">
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' now setup ASIO
              _myAsioProc = New ASIOPROC(AsioCallback)
              ' get the stream channel info
              Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, New IntPtr(stream))
              ' and join the next channels to it
              Dim a As Integer
              For a = 1 To info.chans - 1
                BassAsio.BASS_ASIO_ChannelJoin(False, a, 0)
              Next a
              ' since we joined the channels, the next commands will apply to all channles joined
              ' so setting the values to the first channels changes them all automatically
              ' set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
              ' set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(False, 0, CDbl(info.freq))
              ' try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate(CDbl(info.freq))
              ' and start playing it...start output using default buffer/latency
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            Private _myAsioProc As ASIOPROC ' make it global, so that it can not be removed by the GC
            Private Function AsioCallback(input As Boolean, channel As Integer, 
                                          buffer As IntPtr, length As Integer, user As IntPtr) As Integer
              ' Note: 'user' contains the underlying stream channel (see above)
              ' We can simply use the bass method to get some data from a decoding channel 
              ' and store it to the asio buffer in the same moment...
              Return Bass.BASS_ChannelGetData(user.ToInt32(), buffer, length)
            End Function
            </code>
            Setting up a full-duplex input to output handler:
            <code>
            private byte[] _fullDuplexAsioBuffer;
            private int _numchans = 2;
            
            private void SetFullDuplex()
            {
                BASS_ASIO_INFO info = BassAsio.BASS_ASIO_GetInfo();
                _fullDuplexAsioBuffer = new byte[info.bufmax * _numchans * 4];
                ...
            }
            
            private int AsioToAsioFullDuplexCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
            {
                if (input)
                {
                    if (_fullDuplexAsioBuffer.Length &lt; length)
                        _fullDuplexAsioBuffer = new byte[length];
                    Marshal.Copy(buffer, _fullDuplexAsioBuffer, 0, length);
                    return 0;
                }
                else
                {
                    if (length &gt; _fullDuplexAsioBuffer.Length)
                        length = _fullDuplexAsioBuffer.Length;
                    Marshal.Copy(_fullDuplexAsioBuffer, 0, buffer, length);
                    return length;
                }
            }
            </code>
            <code lang="vbnet">
            Private _fullDuplexAsioBuffer As Byte()
            Private _numchans As Integer = 2
            
            Private Sub SetFullDuplex() 
                Dim info As BASS_ASIO_INFO = BassAsio.BASS_ASIO_GetInfo() 
                _fullDuplexAsioBuffer = New Byte(info.bufmax * _numchans * 4 - 1) {}
                ...
            End Sub 
            
            Private Function AsioToAsioFullDuplexCallback(ByVal input As Boolean, ByVal channel As Integer, 
                                                          ByVal buffer As IntPtr, ByVal length As Integer, 
                                                          ByVal user As IntPtr) As Integer 
                If input Then 
                    If _fullDuplexAsioBuffer.Length &lt; length Then
                       _fullDuplexAsioBuffer = New Byte(length - 1) {} 
                    End If 
                    Marshal.Copy(buffer, _fullDuplexAsioBuffer, 0, length) 
                    Return 0 
                Else 
                    If length &gt; _fullDuplexAsioBuffer.Length Then 
                       length = _fullDuplexAsioBuffer.Length 
                    End If 
                    Marshal.Copy(_fullDuplexAsioBuffer, 0, buffer, length) 
                    Return length 
                End If 
            End Function 
            </code>
            </example>
        </member>
        <member name="T:Un4seen.BassAsio.ASIONOTIFYPROC">
            <summary>
            User defined notification callback function (to be used with <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetNotify(Un4seen.BassAsio.ASIONOTIFYPROC,System.IntPtr)"/>).
            </summary>
            <param name="notify">The notification, one of the following:
            <list type="table">
            <item><term>BASS_ASIO_NOTIFY_RATE</term><description>The device's sample rate has changed. The new rate is available from <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetRate"/>.</description></item>
            <item><term>BASS_ASIO_NOTIFY_RESET</term><description>The driver has requested a reset/reinitialization; for example, following a change of the default buffer size. This request can be ignored, but if a reinitialization is performed, it should not be done within the callback.</description></item>
            </list>
            </param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_SetNotify(Un4seen.BassAsio.ASIONOTIFYPROC,System.IntPtr)"/> was called.</param>
            <remarks>
            When using multiple devices, <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetDevice"/> can be used to determine which the notification applies to.
            </remarks>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandler">
            <summary>
            This class provides ready-made members for direct and more simple ASIO usage together with BASS channels.
            </summary>
            <remarks>
            You might use this class for almost all use cases in terms of Asio handling, e.g.:
            <list type="table">
            <listheader><term>Scenario:</term><description>How-To:</description></listheader>
            <item><term>Asio output</term><description>A Bass decoding channel or a recording channel feeding Asio output.
            <para>Simply use the corresponding output constructor to specify the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> as well the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> to use and you are done.
            The <see cref="P:Un4seen.BassAsio.BassAsioHandler.SampleRate"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Format"/> will automatically be aligned. Use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AssignOutputChannel(System.Int32)"/> method to change the underlying bass channel on the fly.</para>
            </description></item>
            <item><term>Asio input</term><description>Directly record from Asio input.
            <para>Simply use the corresponding input constructor to specify the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.SampleRate"/>, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Format"/> you want to record at.
            To retrieve the input sample data use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> channel (e.g. setup an <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)">own DSP</see>, use it with the <see cref="!:Un4seen.Bass.Misc.WaveWriter"/> or <see cref="T:Un4seen.Bass.Misc.BaseEncoder">Encoder Framework</see>).</para>
            </description></item>
            <item><term>Asio input, full-duplex to Asio</term><description>Monitor your Asio input on any Asio output.
            <para>To enable full-duplex just call the Asio overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method (when done call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>).</para>
            </description></item>
            <item><term>Asio input, full-duplex to BASS</term><description>Monitor your Asio input on any BASS device.
            <para>To enable full-duplex just call the bass overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method (when done call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>).</para>
            </description></item>
            <item><term>DSP/FX</term><description>You can set any DSP/FX on either the input and/or the output (full-duplex).
            <para>See <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> for more details.</para>
            </description></item>
            In addition to the above this class supports overloading of the default Asio callbacks (<see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>).
            </list>
            <para>You might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Volume"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Pan"/> properties to easily control your Asio input/output settings.
            Asio mirrors are also supported via the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> and <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> methods. Mirrors have independent <see cref="P:Un4seen.BassAsio.BassAsioHandler.VolumeMirror"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.PanMirror"/> settings.</para>
            <para>Asio channels can be paused and resumed at any time by using the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Pause(System.Boolean)"/> method.
            To physically start the used Asio device the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Start(System.Int32,System.Int32)"/> method might be used. <see cref="M:Un4seen.BassAsio.BassAsioHandler.Stop"/> will unjoin, disable and stop the Asio device (if really needed).</para>
            <para>Caution: Once you created an instance of this class, the respective ASIO channels are joined and enabled.
            The used ASIO channels will NOT be unjoined or disabled automatically when an instance of this class is being disposed by the .Net Garbage Collector!
            Call the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> method manually to completely free all assigned ASIO channels, including any full-duplex and the mirror options.
            However, calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> will not stop the Asio device - this has to be done manually in any case (e.g. by calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.Stop"/>)!</para>
            <para>Note: This class internally uses <see cref="N:Un4seen.Bass"/>, so you need to provide the native BASS.dll as well when using this class.</para>
            <para>The <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> and <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> callbacks are virtual methods 
            which might be overloaded if you want to derive your own ASIO handler with any special callback handling.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (a Bass channel is feeding Asio output):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// assign ASIO output to the first device and channel
            	// and assume the ASIO format, samplerate and number of channels from the BASS stream
            	_asio = new BassAsioHandler(0, 0, stream);
            	// start ASIO
            	_asio.Start(0);
            }
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign ASIO output to the first device and channel
              ' and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = New BassAsioHandler(0, 0, stream)
              ' start ASIO
              _asio.Start(0)
            End If
            </code>
            Automatic use of the BassAsioHandler (Asio recording input, Asio full-duplex output):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0);
            // start ASIO
            _asio.Start(0);
            ...
            // when you want to disbale all associated channels, call:
            _asio.Dispose();
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0)
            ' start ASIO
            _asio.Start(0)
            ...
            ' when you want to disbale all associated channels, call:
            _asio.Dispose()
            </code>
            </example>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsioHandler.UseDedicatedThreads">
            <summary>
            Gets or Sets, if the driver should be hosted in a dedicated thread.
            </summary>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.#ctor">
            <summary>
            Default constructor - leaving all defaults and not assigning any ASIO channel.
            </summary>
            <remarks>Use this constructor, if you for example want to leverage the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> or <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> callback methods.
            In this case make sure to also set the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> property, since this member will be used in the mentioned default callback procedures.
            Also make sure, that the ASIO channel use will use matches the samplerate and the format of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>!
            </remarks>
            <example>Manual use of the BassAsioHandler:
            <code>
            private ASIOPROC _myAsioProc;
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              _asio = new BassAsioHandler();
              _asio.OutputChannel = stream;
            
              // now setup ASIO manually
              _myAsioProc = new ASIOPROC(_asio.BassToAsioOutputCallback);
              // get the stream channel info
              BASS_CHANNELINFO info = Bass.BASS_ChannelGetInfo(stream);
              // enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(false, 0, _myAsioProc, stream);
              // and join the next channels to it
              for (int a=1; a&lt;info.chans; a++)
                BassAsio.BASS_ASIO_ChannelJoin(false, a, 0);
              // since we joined the channels, the next commands will apply to all channles joined
              // so setting the values to the first channels changes them all automatically
              // set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(false, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT);
              // set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(false, 0, (double)info.freq);
              // try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate( (double)info.freq );
              // and start playing it...start output using default buffer/latency
              _asio.Start(0);
            }
            </code>
            <code lang="vbnet">
            Private _myAsioProc As ASIOPROC
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              _asio = New BassAsioHandler()
              _asio.OutputChannel = stream
            
              ' now setup ASIO manually
              _myAsioProc = New ASIOPROC(AddressOf _asio.BassToAsioOutputCallback)
              ' get the stream channel info
              Dim info As BASS_CHANNELINFO = Bass.BASS_ChannelGetInfo(stream)
              ' enable 1st output channel...(0=first)
              BassAsio.BASS_ASIO_ChannelEnable(False, 0, _myAsioProc, stream)
              ' and join the next channels to it
              Dim a As Integer
              For a = 1 To info.chans - 1
                BassAsio.BASS_ASIO_ChannelJoin(False, a, 0)
              Next a
              ' since we joined the channels, the next commands will apply to all channles joined
              ' so setting the values to the first channels changes them all automatically
              ' set the source format (float, as the decoding channel is)
              BassAsio.BASS_ASIO_ChannelSetFormat(False, 0, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT)
              ' set the source rate
              BassAsio.BASS_ASIO_ChannelSetRate(False, 0, CDbl(info.freq))
              ' try to set the device rate too (saves resampling)
              BassAsio.BASS_ASIO_SetRate(CDbl(info.freq))
              ' and start playing it...start output using default buffer/latency
              _asio.Start(0)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,Un4seen.BassAsio.BASSASIOFormat,System.Double)">
            <summary>
            Creates an instance of the ASIO handler - initializing and enabling the given ASIO device and channel.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/>=an output channel, <see langword="true"/> = an input channel (in which case the <see cref="P:Un4seen.BassAsio.BassAsioHandler.UseInput"/> will automatically set to <see langword="true"/>, so that you can use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/>.).</param>
            <param name="asioDevice">The ASIO device to use (0=first).</param>
            <param name="asioChannel">The ASIO input/output channel number (0=first).</param>
            <param name="asioNumChans">The total number of ASIO channels to use (following channels will be joined - e.g. 2 for stereo).</param>
            <param name="asioFormat">The ASIO sample format to use for the channel(s) - see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/> for details.</param>
            <param name="asioSamplerate">The desired samplerate to use with the channel(s) - use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_GetRate"/> or -1 if uncertain and to prevent resampling.
            If the ASIO device samplerate could not be set to the desired samplerate, the device's current samplerate will be taken instead.</param>
            <remarks>
            Use this constructor for either manual Asio handler use or for Asio input recording.
            <para>The following will be done internally:</para>
            <para>1. The ASIO device will be initialized (if already done, the ASIO device will just be set).</para>
            <para>2. The ASIO device's samplerate will be set to the given <paramref name="asioSamplerate"/> - if the ASIO device samplerate could not be changed the device's current samplerate will be taken!</para>
            <para>3a. If input: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>. Also <see cref="P:Un4seen.BassAsio.BassAsioHandler.UseInput"/> will be set to <see langword="true"/>, so that you can use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> to retrieve the recorded sample data.</para>
            <para>3b. If output: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>4. If the ASIO device was already started, it will be stopped when necessary (only if the ASIO channel has not yet been enabled). The device will be started again.</para>
            <para>5. Enable and join the given <paramref name="asioChannel"/> with the following channels according to the total <paramref name="asioNumChans"/>.</para>
            <para>6. Set the ASIO channel format and samplerate according to the given <paramref name="asioSamplerate"/> and <paramref name="asioFormat"/>.</para>
            <para>Note: If the given <paramref name="asioChannel"/> has already been enabled, it will be reused and not enabled and joined again!
            This means, that the channel number of the already joined channel will not be changed as well and might not match to the channel number of the given <paramref name="asioNumChans"/> parameter.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (Asio recording input, Asio full-duplex output):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0);
            // start ASIO
            _asio.Start(0);
            ...
            // when you want to disbale all associated channels, call:
            _asio.Dispose();
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0)
            ' start ASIO
            _asio.Start(0)
            ...
            ' when you want to disbale all associated channels, call:
            _asio.Dispose()
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.#ctor(System.Int32,System.Int32,System.Int32,Un4seen.BassAsio.BASSASIOFormat)">
            <summary>
            Creates an instance of the ASIO handler for output - initializing and enabling the given ASIO device and channel according to the Bass stream.
            </summary>
            <param name="asioDevice">The ASIO device to use (0=first).</param>
            <param name="asioChannel">The ASIO output channel number (0=first).</param>
            <param name="outputChannel">The BASS channel handle which should be used with ASIO output (must be a decoding or recording channel and must be either 16-bit or 32-bit).</param>
            <param name="format">The ASIO sample format to use for the channel(s) - see <see cref="T:Un4seen.BassAsio.BASSASIOFormat"/> for details. Use -1 (UNKNOWN) to apply the format automatically.</param>
            <remarks>
            Use this constructor for automatic Asio output using either a decoding or recording <paramref name="outputChannel"/>.
            <para>The following will be done internally:</para>
            <para>1. The ASIO device will be initialized (if already done, the ASIO device will just be set).</para>
            <para>2. The samplerate, format and number of channels will be determined from the given <paramref name="outputChannel"/>.</para>
            <para>3. The ASIO device will be set to the determined samplerate. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and stream samplerate are different) that the ASIO output needs to be resampled.</para>
            <para>4. Output: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>4. Enable and join the given <paramref name="asioChannel"/> with the following channels according to the total number of chans of the <paramref name="outputChannel"/>.</para>
            <para>5. Set the <paramref name="asioChannel"/> format and samplerate according to the given samplerate and format of the <paramref name="outputChannel"/>.</para>
            <para>Note: If the given <paramref name="asioChannel"/> has already been enabled, it will be reused and not enabled and joined again!
            This means, that the channel number of the already joined channel will not be changed as well and might not match to the channel number of the given <paramref name="outputChannel"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel: must be a valid BASS channel (either decoding or recording).</exception>
            <example>
            Automatic use of the BassAsioHandler (Asio output from a Bass stream):
            <code>
            private BassAsioHandler _asio;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              // assign ASIO output to the first device and channel
              // and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = new BassAsioHandler(0, 0, stream);
              // start ASIO
              _asio.Start(0);
            }
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device but 48000 (default for ASIO)
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            BassAsio.BASS_ASIO_Init(0, BASSASIOInit.BASS_ASIO_THREAD)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign ASIO output to the first device and channel
              ' and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = New BassAsioHandler(0, 0, stream)
              ' start ASIO
              _asio.Start(0)
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Dispose">
            <summary>
            Disposes an instance of this class also unjoining and disabling all used ASIO channels.
            </summary>
            <remarks>The used ASIO channel(s) will be unjoined and disabled! This means, that the ASIO device needs to stopped for a short moment!
            <para>Caution: Once you created an instance of this class, the respective ASIO channel(s) are joined and enabled.
            Calling this method will automatically unjoin and disable the used ASIO channels as well as the full-duplex and mirror channels will be removed and disabled!
            If you want to prevent this little break in the ASIO device (since the ASIO device needs to be stopped for a short moment) make sure this method is never called during the device is started.</para>
            <para>Also if you want to leave all ASIO channels enabled (even if you do not need this instance anymore) do NOT call this method! In such case you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> and <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/> manually if needed, 
            and you might also call <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelEnable(System.Boolean,System.Int32,Un4seen.BassAsio.ASIOPROC,System.IntPtr)"/> or <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelReset(System.Boolean,System.Int32,Un4seen.BassAsio.BASSASIOReset)"/> manually.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.DeviceVolume">
            <summary>
            Gets or Sets the master volume of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> between 0 (silent) and 1 (full).
            </summary>
            <remarks>Whereas the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Volume"/> and the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Pan"/> properties directly effect the internally used channel volume,
            this property effects the global ASIO device volume setting.
            <para>The volume level ranges from 0 (silent) to 1 (maximum).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.InternalAsioProc">
            <summary>
            Gets the <see cref="T:Un4seen.BassAsio.ASIOPROC"/> currently being used by the Asio handler.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Volume">
            <summary>
            Gets or Sets the volume of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> (and all joined <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between 0 (silent) and 1 (full).
            </summary>
            <remarks>Setting the volume uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Pan"/> property in case of multi-channel ASIO (<see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 1).
            <para>The volume level ranges from 0 (silent) to 1 (normal) or above 1 to amplify the sound.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.VolumeMirror">
            <summary>
            Gets or Sets the volume of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/> (and all attached <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between 0 (silent) and 1 (full).
            </summary>
            <remarks>Setting the volume uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.PanMirror"/> property in case of multi-channel ASIO (<see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 1).
            <para>The volume level ranges from 0 (silent) to 1 (normal) or above 1 to amplify the sound.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Pan">
            <summary>
            Gets or Sets the panning of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> (and all joined <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between -1 (left) to +1 (right), 0=centered.
            </summary>
            <remarks>Setting the panning uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Volume"/> property in order to calculate the individual channel volume.
            E.g. if you set the panning to -0.7 at a volume of 1.0: chan1-volume (left) = 0.3, chan2-volume (right) = 1.0.
            <para>The panning value ranges from -1 (left) to 0 (center) to +1 (right).</para>
            <para>In case of multi-channel (not stereo, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 2) the left/right positions are interleaved between the additional channels.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.PanMirror">
            <summary>
            Gets or Sets the panning of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/> (and all attached <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>) between -1 (left) to +1 (right), 0=centered.
            </summary>
            <remarks>Setting the panning uses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.VolumeMirror"/> property in order to calculate the individual channel volume.
            E.g. if you set the panning to -0.7 at a volume of 1.0: chan1-volume (left) = 0.3, chan2-volume (right) = 1.0.
            <para>The panning value ranges from -1.0 (left) to 0.0 (center) to +1.0 (right).</para>
            <para>In case of multi-channel (not stereo, <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> is greater than 2) the left/right positions are interleaved between the additional channels.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsInput">
            <summary>
            Returns <see langword="true"/>, if the ASIO handler is used with an ASIO input device.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Device">
            <summary>
            Returns the ASIO device being used by the Asio handler.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Channel">
            <summary>
            Returns the first ASIO channel being used.
            </summary>
            <remarks>The class will automatically join ASIO channels together when needed (done in the constructor).
            This property reflects the first ASIO channel being used. The <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> property will tell you how many channels are effectively joined and enabled starting with this channel.
            <para>You can not change the number of ASIO channels once joined and enabled.</para>
            <para>Caution: Once you created an instance of this class, the respective ASIO channels are joined and enabled.
            Disposing an instance of this class will not automatically unjoin and disable the used ASIO channels.
            If you want to do so, please call the appropriate overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> method manually.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsInputFullDuplex">
            <summary>
            Returns <see langword="true"/>, if the ASIO handler is used with an ASIO input device and the full-duplex option was set via <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice">
            <summary>
            Returns the full-duplex ASIO output device being used (or -1, if not used).
            </summary>
            <remarks>Note: This property might also return the full-duplex BASS device, if the related <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> overload was used.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexChannel">
            <summary>
            Returns the first full-duplex ASIO output channel being used (or -1, if not used).
            </summary>
            <remarks>Note: This property might also return -1 if the full-duplex option was used with a BASS device, if the related <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> overload was used.
            <para>If the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> is a multi-channel (the <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> property is greater than 1) this property will return the first full-duplex channel only.
            However, full-duplex always enables <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> channels, starting with this one.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.BypassFullDuplex">
            <summary>
            Gets or Sets the bypass flag for full-duplex ASIO output processing (default is <see langword="false"/>).
            </summary>
            <remarks>If this property is set to <see langword="true"/> any full-duplex output processing is bypassed.
            When setting this property to <see langword="true"/> prior to creating a full-duplex <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> via the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method this enables you to start full-duplex without processing the output yet.
            Setting this property to <see langword="false"/> will start the full-duplex output processing.
            <para>This flag will automatically set back to <see langword="false"/> when calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsMirrored">
            <summary>
            Returns if the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> is being mirrored to another output channel.
            </summary>
            <remarks>You can enable mirroring with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> method and remove it with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> method.
            <para>Mirroring allows an ASIO input or output <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to be duplicated in other output channel (the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/>).</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel">
            <summary>
            Gets the first ASIO mirror channel (or -1 if not mirrored).
            </summary>
            <remarks>You can enable mirroring with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> method and remove it with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/> method.
            <para>Mirroring allows an ASIO input or output <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to be duplicated in other output channel. The property returnes the mirror channel.</para>
            <para>If the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> is a multi-channel (the <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> property is greater than 1) this property will return the first mirrored channel only.
            However, mirroring will always mirror <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/> channels, starting with this one.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.SampleRate">
            <summary>
            Gets or Sets the actual ASIO channel sample rate in Hz (default is 48000).
            </summary>
            <remarks>By default the samplerate will automatically be adjusted according to the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> being used.
            However, you might change the samplerate for this ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> manually, which might result in resampling, since this property does not change the ASIO device samplerate.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans">
            <summary>
            Gets the total number of ASIO channel which are joined together, starting with <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>.
            </summary>
            <remarks>The class will automatically join ASIO channels together when needed (done in the constructor).
            This property reflects the total of ASIO channels used. Depending on which constructor overload you used, this number can be based on the number of channels of the given <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.
            <para>You can not change the number of ASIO channels once joined and enabled.</para>
            <para>Caution: Once you created an instance of this class, the respective ASIO channels are joined and enabled.
            Disposing an instance of this class will not automatically unjoin and disable the used ASIO channels.
            If you want to do so, please call the appropriate overload of the <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> method manually.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.Format">
            <summary>
            Gets or Sets the actual ASIO channel format (default is BASS_ASIO_FORMAT_FLOAT).
            </summary>
            <remarks>By default the format will automatically be adjusted according to the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> being used.
            However, you might change the format for this ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> manually.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel">
            <summary>
            Gets or Sets the BASS output channel handle which is used with this ASIO handler.
            </summary>
            <remarks>
            <para>When using the ASIO handler with an ASIO input device this channel is not available (unless you use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method, 
            in which case you might use this property to access the full-duplex output channel to apply DSP/FX).</para>
            <para>When using the ASIO handler with an ASIO output device this channel will be assigned once and can later be changed by calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.AssignOutputChannel(System.Int32)"/> 
            and will represent the channel feeding the ASIO output with sample data. Tyically a decoding channel must be used, 
            but a recording channel will also work, since the interal ASIO procedure being used simply calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to pull the sample data from it as needed and reqested by ASIO.</para>
            <para>Caution: Setting this parameter manually might break the ASIO chain - only assign it manually, if the BASS chanel uses the same format and samplerate as the related ASIO channel.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.IsResampling">
            <summary>
            Returns <see langword="true"/>, if resampling takes place on the used <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>.
            </summary>
            <remarks>Resampling is needed, if the ASIO channel samplerate is different than the ASIO device samplerate.
            If you are using ASIO input with the full-duplex option this property will check both, if resampling happens either on the ASIO input or on the ASIO output.</remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.InputChannel">
            <summary>
            Returns an input channel which allows you to retrieve the recorded sample data and/or apply any DSP/FX on Asio input.
            </summary>
            <remarks>When you are using ASIO with input (<see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/> must return <see langword="true"/>) and have set the <see cref="P:Un4seen.BassAsio.BassAsioHandler.UseInput"/> property to <see langword="true"/> 
            you might use this channel to setup any DSP/FX to be applied to the Asio input or just retrieve the recorded sample data. 
            Any DSP/FX set on this channel will also be passed through to the output, if you are using <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            <para>As the InputChannel is a dummy custom decoding stream you can not call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> directly on it in order to directly get the sample data;
            nor can you use it directly as a source stream for any (mixer)output!
            Instead use a <see cref="T:Un4seen.Bass.DSPPROC"/> via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> to retrieve the sample data.</para>
            <para>Note: However, you might independently set any DSP/FX on the full-duplex output using the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> instead.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandler.UseInput">
            <summary>
            Enables the use of the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> channel with ASIO input (which is the default for Asio input).
            </summary>
            <remarks>When you are using ASIO with input (<see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/> must return <see langword="true"/>) and set this property to <see langword="true"/> 
            you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> to setup any DSP/FX to be applied to the Asio input or retrieve the recorded sample data. 
            Any DSP/FX set on this channel will also be passed through to the output, if you are using <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            <para>Note: However, you might independently set any DSP/FX on the full-duplex output using the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> instead.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Start(System.Int32,System.Int32)">
            <summary>
            Starts the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length (use -1 to request the preferred buffer length).</param>
            <param name="threads">The number of processing threads to use... 0 = use current number.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> being used by the Asio handler (if not already started).
            <para>If you need to stop the Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.Stop"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Stop">
            <summary>
            Stops the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> being used by the Asio handler (if not already stopped).
            <para>If you need to start the Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.Start(System.Int32,System.Int32)"/>.</para>
            <para>Caution: If you are using multiple instances of the <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> which use the same Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> calling this method impacts the other instances as well, 
            as the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> itself is being stopped. In such case you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> to unjoin and disable only the ASIO channels used by this instance.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.StartFullDuplex(System.Int32)">
            <summary>
            Starts the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/>.
            </summary>
            <param name="buflen">Buffer length in samples... 0 = use current length.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Start(System.Int32)"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> being used by the Asio handler (if not already stopped and if used).
            <para>If you need to stop the full-duplex Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.StopFullDuplex"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.StopFullDuplex">
            <summary>
            Stops the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/>.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_Stop"/> internally on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> being used by the Asio handler (if not already stopped and if used).
            <para>If you need to start the full-duplex Asio device you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.StartFullDuplex(System.Int32)"/>.</para>
            <para>Caution: If you are using multiple instances of the <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> which use the same Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> calling this method impacts the other instances as well, 
            as the Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> itself is being stopped. In such case you might call <see cref="M:Un4seen.BassAsio.BassAsioHandler.Dispose"/> to stop the full-duplex channels used by this instance
            or consider calling <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/> to disable and remove the full-duplex option.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.Pause(System.Boolean)">
            <summary>
            Pauses or Unpauses the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>(s) being used.
            </summary>
            <param name="pause"><see langword="true"/> if you want to pause the ASIO channel(s) - <see langword="false"/> if you want to unpause.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>When in full-duplex input mode (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInputFullDuplex"/>) the related AISO input as well as the ASIO output channel(s) will be (un)paused.</remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.PauseMirror(System.Boolean)">
            <summary>
            Pauses or Unpauses the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/>(s) being used.
            </summary>
            <param name="pause"><see langword="true"/> if you want to pause the ASIO channel(s) - <see langword="false"/> if you want to unpause.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AssignOutputChannel(System.Int32)">
            <summary>
            Assigns a (new) BASS channel handle for ASIO output.
            </summary>
            <param name="outputChannel">The BASS channel handle which should be used with ASIO output (should be a decoding or recording channel and must be either 16-bit or 32-bit) - or 0 (zero) to remove an existing <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The following will be done internally:</para>
            <para>1. The current ASIO channel will be paused (if already enabled).</para>
            <para>2. The samplerate, format and number of channels will be determined from the given <paramref name="outputChannel"/>.</para>
            <para>3. The ASIO device will be set to the determined samplerate. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and stream samplerate are different) that the ASIO output needs to be resampled.</para>
            <para>4a. ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> enabled: use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>, if the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> was already enabled and joined, it will not be changed.</para>
            <para>4b. ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> disabled: Enable and join the given Asio <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> with the following channels according to the total number of chans of the <paramref name="outputChannel"/>.</para>
            <para>5. Set the ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> format and samplerate according to the given samplerate and format of the <paramref name="outputChannel"/>.</para>
            <para>6. The current ASIO channel will be unpaused (if it was paused before).</para>
            <para>This method can not be used with ASIO input (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>Tyically a decoding channel must be used, but a recording channel will also work, since the internal ASIO procedure being used simply calls <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> to pull the sample data from the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> as needed and requested by ASIO.</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid channel: must be a valid BASS channel (either decoding or recording).</exception>
            <example>
            Automatic use of the BassAsioHandler (output):
            <code>
            private BassAsioHandler _asio;
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
              // assign ASIO output to the first device and channel
              // and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = new BassAsioHandler(0, 0, stream);
              // start ASIO
              BassAsio.BASS_ASIO_Start(0);
            }
            ...
            // assign a new channel to ASIO output
            Bass.BASS_StreamFree(stream);
            int newStream = Bass.BASS_StreamCreateFile(newFileName, 0, 0, 
                                 BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT );
            _asio.AssignOutputChannel(newStream);
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign ASIO output to the first device and channel
              ' and assume the ASIO format, samplerate and number of channels from the BASS stream
              _asio = New BassAsioHandler(0, 0, stream)
              ' start ASIO
              BassAsio.BASS_ASIO_Start(0)
            End If
            ...
            ' assign a new channel to ASIO output
            Bass.BASS_StreamFree(stream)
            Dim newStream As Integer = Bass.BASS_StreamCreateFile(newFileName, 0, 0, 
                                            BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            _asio.AssignOutputChannel(newStream)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)">
            <summary>
            Sets the full-duplex option for ASIO input using the given ASIO output device and channel.
            </summary>
            <param name="asioDevice">The ASIO output device which should be used for full-duplex monitoring.</param>
            <param name="asioChannel">The ASIO output channel which should be used for full-duplex monitoring.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The full-duplex options is only available on input channels. However even a full-duplex output channel on a different ASIO device might even be used.</para>
            <para>If you want to mirror an ASIO input channel to an output channel on the same device, you might might also use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/> method instead, which is more efficient in such case.</para>
            <para>The following will be done internally:</para>
            <para>1. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> will be used (and enabled and joined, only if not enabled yet).</para>
            <para>2. A custom dummy decoding stream (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>) will be created with the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>3. The samplerate, format and number of channels will not be changed for ASIO input, since this will be used as already specified in the constructor.</para>
            <para>4. The ASIO output <paramref name="asioDevice"/> will only be stopped, if already started and the <paramref name="asioChannel"/> has not yet been enabled - it will automatically be started again if needed.</para>
            <para>5. The ASIO output device will be set to the same samplerate as the ASIO input. If this fails, the current ASIO samplerate will not be changed. In this case it might happen (if ASIO device samplerate and input samplerate are different) that the ASIO output needs to be resampled.</para>
            <para>6. The ASIO output <paramref name="asioChannel"/> will be enabled and joined (only if not already enabled) as well as the format and samplerate will be set. All according to the given number of channels, samplerate and format of the ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>.</para>
            <para>This method can not be used with ASIO output (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To disable and remove the full-duplex option call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>.</para>
            <para>The full-duplex ASIO output is provided by an internal custom dummy decoding stream <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>. You might use this stream to set up DSPs or FX on it so that these are applied on the ASIO output.</para>
            <para>You might bypass any full-duplex output procesing by setting the <see cref="P:Un4seen.BassAsio.BassAsioHandler.BypassFullDuplex"/> property to <see langword="true"/>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (Asio recording input, full-duplex Asio output):
            <code>
            private BassAsioHandler _asio;
            private DSP_PeakLevelMeter _plm;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will always be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0);
            
            // set up a ready-made DSP (here the PeakLevelMeter) on the full-duplex channel
            _plm = new DSP_PeakLevelMeter(_asio.OutputChannel, 0);
            _plm.UpdateTime = 0.1f; // 100ms
            _plm.CalcRMS = true;
            _plm.Notification += new EventHandler(OnPlmNotification);
            
            // start ASIO
            BassAsio.BASS_ASIO_Start(0);
            ...
            private void OnPlmNotification(object sender, EventArgs e)
            {
              if (_plm == null)
                return;
              // sender will be the DSP_PeakLevelMeter instance
              // you could also access it via: DSP_PeakLevelMeter p = (DSP_PeakLevelMeter)sender;
              this.progressBarPeak1Left.Value = _plm.LevelL;
              this.progressBarPeak1Right.Value = _plm.LevelR;
              this.labelLevel1.Text = String.Format( "RMS: {0:#00.0} dB   AVG: {1:#00.0} dB   Peak: {2:#00.0} dB", 
                   _plm.RMS_dBV, _plm.AVG_dBV, Math.Max(_plm.PeakHoldLevelL_dBV, _plm.PeakHoldLevelR_dBV) );
            }
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            Private _plm As DSP_PeakLevelMeter
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will always be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0)
            
            ' set up a ready-made DSP (here the PeakLevelMeter) on the full-duplex channel
            _plm = New DSP_PeakLevelMeter(_asio.OutputChannel, 0)
            _plm.UpdateTime = 0.1F ' 100ms
            _plm.CalcRMS = True
            AddHandler _plm.Notification, AddressOf OnPlmNotification
            
            ' start ASIO
            BassAsio.BASS_ASIO_Start(0)
            ...
            Private Sub OnPlmNotification(sender As Object, e As EventArgs)
              If _plm Is Nothing Then
                Return
              End If
              ' sender will be the DSP_PeakLevelMeter instance
              ' you could also access it via: 
              ' Dim p As DSP_PeakLevelMeter = CType(sender, DSP_PeakLevelMeter)
              Me.progressBarPeak1Left.Value = _plm.LevelL
              Me.progressBarPeak1Right.Value = _plm.LevelR
              Me.labelLevel1.Text = [String].Format("RMS: {0:#00.0} dB   AVG: {1:#00.0} dB   Peak: {2:#00.0} dB", 
                 _plm.RMS_dBV, _plm.AVG_dBV, Math.Max(_plm.PeakHoldLevelL_dBV, _plm.PeakHoldLevelR_dBV))
            End Sub
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)">
            <summary>
            Sets the full-duplex option for ASIO input using the given BASS output device.
            </summary>
            <param name="bassDevice">The BASS output device which should be used for full-duplex monitoring.</param>
            <param name="flags">The optional <see cref="T:Un4seen.Bass.BASSFlag"/> flags to be used to create the full-duplex monitoring <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.
            Typically only the following flags should be used: BASS_STREAM_DECODE, BASS_SAMPLE_SOFTWARE or BASS_SPEAKER_xxx.</param>
            <param name="buffered"><see langword="true"/>, if the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> should be (pre)buffered - else <see langword="false"/>.
            <para>Prebuffering of sample data is often requied for buffered output to enable a constant playback. So even if you are using a BASS_STREAM_DECODE flag you might need to prebuffer it's data.</para>
            </param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The following will be done internally:</para>
            <para>1. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> will be used (and enabled and joined, only if not enabled yet).</para>
            <para>2. The BASS output <paramref name="bassDevice"/> will be used.</para>
            <para>3. A custom push stream (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>) will be created (using the given <paramref name="flags"/>) with an internal ASIO callback feeding the stream with the sample data from the input.</para>
            <para>4. The samplerate, format and number of channels will not be changed for ASIO input, since this will be used as already specified in the constructor.</para>
            <para>5. The custom push stream will be started playing (via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) - unless the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag has been specified.</para>
            <para>This method can not be used with ASIO output (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To disable and remove the full-duplex option call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)"/>.</para>
            <para>The full-duplex BASS output is provided by the internal custom push stream <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>. You might use this stream to set up DSPs or FX on it so that these are applied on the BASS output.</para>
            <para>You might bypass any full-duplex output procesing by setting the <see cref="P:Un4seen.BassAsio.BassAsioHandler.BypassFullDuplex"/> property to <see langword="true"/>.</para>
            <para>You might use the 0 (no-sound) bass device together with the BASS_STREAM_DECODE flag in order to create a custom decoding <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> which might for example be used with an <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> or <see cref="!:Bass.Misc.WaveWriter"/> or 
            as a source for a <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">mixer channel</see>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (Asio recording input, full-duplex to BASS):
            <code>
            private BassAsioHandler _asio;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first BASS output device using the rear speakers
            // the BASS output format will always be the same as the ASIO input for full-duplex
            _asio.SetFullDuplex(1, BASSFlag.BASS_SPEAKER_REAR, true);
            
            // start ASIO
            BassAsio.BASS_ASIO_Start(0);
            _asio.ResetFullDuplex();
            
            // setup an FX on the full-duplex BASS output
            BASS_FXECHO echo = new BASS_FXECHO();
            int fxHandle = Bass.BASS_ChannelSetFX(_asio.OutputChannel, BASSFXType.BASS_FX_ECHO, 0);
            echo.Preset_Long();
            // apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo);
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first BASS output device using the rear speakers
            ' the BASS output format will always be the same as the ASIO input for full-duplex
            _asio.SetFullDuplex(1, BASSFlag.BASS_SPEAKER_REAR, True)
            
            ' start ASIO
            BassAsio.BASS_ASIO_Start(0)
            _asio.ResetFullDuplex()
            
            ' setup an FX on the full-duplex BASS output
            Dim echo As New BASS_FXECHO()
            Dim fxHandle As Integer = Bass.BASS_ChannelSetFX(_asio.OutputChannel, BASSFXType.BASS_FX_ECHO, 0)
            echo.Preset_Long()
            ' apply the effect parameters
            Bass.BASS_FXSetParameters(fxHandle, echo)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.RemoveFullDuplex(System.Boolean)">
            <summary>
            Removes the full-duplex option from ASIO input.
            </summary>
            <param name="disableOutput">Disable and unjoin the ASIO output channel? <see langword="false"/>=leave them enabled and joined.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>The full-duplex option must have been set before via <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.
            <para>The following will be done internally:</para>
            <para>1. The ASIO output <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexDevice"/> will be stopped (if already started).</para>
            <para>2. The ASIO output <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexChannel"/> will be disabled and unjoined.</para>
            <para>3. The ASIO output device will be started again (only, if it has been started before).</para>
            <para>4. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> will be stopped (if already started).</para>
            <para>5. The ASIO input <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> will be disabled.</para>
            <para>6. Any custom dummy decoding stream (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>) will be freed and the <see cref="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)"/> will again be used as the internal <see cref="T:Un4seen.BassAsio.ASIOPROC"/>.</para>
            <para>7. The ASIO input channel will be (re)enabled, the samplerate, format and number of channels will not be changed for ASIO input, since this will be used as already specified in the constructor.</para>
            <para>8. The ASIO input device will be started again (only, if it has been started before).</para>
            <para>Note: This method will only disable the <see cref="P:Un4seen.BassAsio.BassAsioHandler.FullDuplexChannel"/> if specified in the <paramref name="disableOutput"/> parameter.</para>
            <para>This method can not be used with ASIO output (see <see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To enable the full-duplex option again, call <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/>.</para>
            <para>Note, that this method also resets the <see cref="P:Un4seen.BassAsio.BassAsioHandler.BypassFullDuplex"/> property to <see langword="false"/>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (recording input, full-duplex):
            <code>
            private BassAsioHandler _asio;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the full-duplex option to the first ASIO output device and channel
            // the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0); // first output device and channel
            // start ASIO
            _asio.Start(0);
            ...
            // remove the full-duplex option and leave the channel enabled
            _asio.RemoveFullDuplex(false);
            // but pause the unused output channel
            BassAsio.BASS_ASIO_ChannelPause(false, 0);
            ...
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the full-duplex option to the first ASIO output device and channel
            ' the ASIO output format will aways be the same as the input for full-duplex
            _asio.SetFullDuplex(0, 0) ' first output device and channel
            ' start ASIO
            _asio.Start(0)
            ...
            ' remove the full-duplex option and leave the channel enabled
            _asio.RemoveFullDuplex(False)
            ' but pause the unused output channel
            BassAsio.BASS_ASIO_ChannelPause(False, 0)
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)">
            <summary>
            Mirrors the current ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to the given output channel.
            </summary>
            <param name="asioChannel">The output channel number... 0 = first.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>This function allows the input or output <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/> to be duplicated in other output channel. Mirroring is only available on the same ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/>!</para>
            <para>If you need to monitor an input channel on a different ASIO device, you might use the <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetFullDuplex(System.Int32,System.Int32)"/> method instead.</para>
            <para>The following will be done internally:</para>
            <para>1. The ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> will only be stopped, if already started - it will automatically be started again if needed.</para>
            <para>2. The ASIO output <paramref name="asioChannel"/> will be enabled and mirrored (only if not already enabled). All according to the given <see cref="P:Un4seen.BassAsio.BassAsioHandler.ChannelNumChans"/>, meaning starting with the <paramref name="asioChannel"/> this one and the next channels will be used as the mirror channels.</para>
            <para>To disable and remove the mirror option call <see cref="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror"/>.</para>
            </remarks>
            <example>
            Automatic use of the BassAsioHandler (recording input, mirrored):
            <code>
            private BassAsioHandler _asio;
            ...
            // assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = new BassAsioHandler(true, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000);
            // set the mirror option to the first ASIO output device and channel
            _asio.SetMirror(0);
            ...
            // start ASIO
            _asio.Start(0);
            ...
            // remove the mirror when not needed
            _asio.RemoveMirror();
            ...
            </code>
            <code lang="vbnet">
            Private _asio As BassAsioHandler
            ...
            ' assign ASIO input to the first device and channel (stereo, 32-bit float, 48kHz)
            _asio = New BassAsioHandler(True, 0, 0, 2, BASSASIOFormat.BASS_ASIO_FORMAT_FLOAT, 48000)
            ' set the mirror option to the first ASIO output device and channel
            _asio.SetMirror(0)
            ...
            ' start ASIO
            _asio.Start(0)
            ...
            ' remove the mirror when not needed
            _asio.RemoveMirror()
            ...
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.RemoveMirror">
            <summary>
            Removes a mirror set on the current ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Channel"/>.
            </summary>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>The mirror option must have been set before via <see cref="M:Un4seen.BassAsio.BassAsioHandler.SetMirror(System.Int32)"/>.
            <para>The following will be done internally:</para>
            <para>1. The ASIO <see cref="P:Un4seen.BassAsio.BassAsioHandler.Device"/> will be stopped (if already started).</para>
            <para>2. The ASIO output <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/> will be disabled.</para>
            <para>3. The ASIO device will be started again (only, if it has been started before).</para>
            <para>CAUTION: This method will always disable the <see cref="P:Un4seen.BassAsio.BassAsioHandler.MirrorChannel"/>(s)!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioOutputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for ASIO output.
            </summary>
            <param name="input">Dealing with an input channel? Must be <see langword="false"/>, since we are dealing with Asio output.</param>
            <param name="channel">The output channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer in which to put the data to output.</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>The number of bytes written.</returns>
            <remarks>Notes:
            <para>In order to use this default output ASIO callback (playback), you need to make sure that you use this callback only with ASIO output (<see cref="P:Un4seen.BassAsio.BassAsioHandler.IsInput"/> must be <see langword="false"/>).</para>
            <para>Furthermore the following should be considered: If the underlying stream channel <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> is at the end (all data was decoded), 
            this callback does NOT automatically pause ASIO via <see cref="M:Un4seen.BassAsio.BassAsio.BASS_ASIO_ChannelPause(System.Boolean,System.Int32)"/> or <see cref="M:Un4seen.BassAsio.BassAsioHandler.Pause(System.Boolean)"/>.
            So you need to do that by yourself (if you whish to save some performance), e.g. setup a <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">BASS_SYNC_END</see> on the <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>.
            If the underlying <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> returns less data, than requested the ASIO output buffer will be filled with 0's (silence).</para>
            <para>Internally <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> will be called on the underlying <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> to request sample data, before the sample data is send to the ASIO output.</para>
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioOutputCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // buffer is not filled
                // do your own stuff here...
                int len = base.AsioOutputCallback(input, channel, buffer, length, user);
                if (len > 0)
                {
                  // buffer is already filled
                  // do your own stuff here...
                }
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioOutputCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' buffer is already filled
                ' do your own stuff here...
                Dim len As Integer = MyBase.AsioOutputCallback(input, channel, buffer, length, user)
                If len > 0 Then
                  ' buffer is already filled
                  ' do your own stuff here...
                End If
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioInputCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for ASIO input.
            </summary>
            <param name="input">Dealing with an input channel? Must be <see langword="true"/>, since we are only dealing with Asio input.</param>
            <param name="channel">The input channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data (input channel).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>Returns 0, since we are only dealing with Asio input.</returns>
            <remarks>
            To receive the recorded sample data you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and set up a DSP on it.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioInputCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // InputChannel not applied yet
                // do your own stuff here...
                int len = base.AsioInputCallback(input, channel, buffer, length, user);
                // InputChannel already applied
                // do your own stuff here...
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioInputCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' InputChannel not applied yet
                ' do your own stuff here...
                Dim len As Integer = MyBase.AsioInputCallback(input, channel, buffer, length, user)
                ' InputChannel already applied
                ' do your own stuff here...
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioToAsioFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for full-duplex ASIO input to Asio output.
            </summary>
            <param name="input">Dealing with an input channel? <see langword="false"/> = an output channel, <see langword="true"/> = an input channel (both input and output must be supported by this callback).</param>
            <param name="channel">The input/output channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data (if input), or in which to put the data to output (if output).</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>The number of bytes written (if output), else 0 (if input).</returns>
            <remarks>
            To apply DSP/FX independetly to the input and output you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> respectively.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioToAsioFullDuplexCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // FullDuplex not applied yet
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                int len = base.AsioToAsioFullDuplexCallback(input, channel, buffer, length, user);
                // FullDuplex already applied
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioToAsioFullDuplexCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' FullDuplex not applied yet
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Dim len As Integer = MyBase.AsioToAsioFullDuplexCallback(input, channel, buffer, length, user)
                ' FullDuplex already applied
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandler.AsioToBassFullDuplexCallback(System.Boolean,System.Int32,System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassAsio.ASIOPROC"/> callback procedure which might be used for full-duplex ASIO input to Bass output.
            </summary>
            <param name="input">Dealing with an input channel? Must be <see langword="true"/>, since we are only dealing with Asio input (full-duplex output is via <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/>).</param>
            <param name="channel">The input channel number... 0 = first.</param>
            <param name="buffer">The pointer to the buffer containing the recorded data.</param>
            <param name="length">The number of BYTES to process.</param>
            <param name="user">Not used.</param>
            <returns>Returns 0, since we are only dealing with Asio input.</returns>
            <remarks>
            To apply DSP/FX independetly to the input and output you might use the <see cref="P:Un4seen.BassAsio.BassAsioHandler.InputChannel"/> and <see cref="P:Un4seen.BassAsio.BassAsioHandler.OutputChannel"/> respectively.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
            <example>
            Implementing your own callback in a derived implementation:
            <code>
            public class MyAsioHandler : BassAsioHandler
            {
            
              public override int AsioToBassFullDuplexCallback(bool input, int channel, IntPtr buffer, int length, IntPtr user)
              {
                // FullDuplex not applied yet
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                int len = base.AsioToBassFullDuplexCallback(input, channel, buffer, length, user);
                // FullDuplex already applied
                if (input)
                {
                  // do your own input stuff here...
                }
                else
                {
                  // do your own output stuff here...
                }
                return len;
              }
            
            }
            </code>
            <code lang="vbnet">
            Public Class MyAsioHandler 
              Inherits BassAsioHandler
            
              Public Overrides Function AsioToBassFullDuplexCallback(input As Boolean, channel As Integer, buffer As IntPtr, length As Integer, user As IntPtr) As Integer
                ' FullDuplex not applied yet
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Dim len As Integer = MyBase.AsioToBassFullDuplexCallback(input, channel, buffer, length, user)
                ' FullDuplex already applied
                If input Then
                  ' do your own input stuff here...
                Else
                  ' do your own output stuff here...
                End If
                Return len
              End Function
            
            End Class
            </code>
            </example>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandler.BassAsioHandlerEventHandler">
            <summary>
            Definition of the <see cref="E:Un4seen.BassAsio.BassAsioHandler.Notification"/> event handler.
            </summary>
            <remarks>
            This definition complies with the .NET Framework's standard for event handlers.
            The sender is always set to the <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> object instance that raised the event.
            </remarks>
        </member>
        <member name="E:Un4seen.BassAsio.BassAsioHandler.Notification">
            <summary>
            Event handler used to notify that an asio handler notification event (sync) has occurred.
            </summary>
            <remarks>
            <para>The <see cref="T:Un4seen.BassAsio.BassAsioHandlerEventArgs"/> contains a <see cref="T:Un4seen.BassAsio.BassAsioHandlerSyncType"/> which allows you to react to a possible sync scenarios.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandlerEventArgs">
            <summary>
            EventArgs class to be passed as the second parameter of a <see cref="E:Un4seen.BassAsio.BassAsioHandler.Notification" /> event handler.
            </summary>
            <remarks>
            This class provides all the information relevant to an event which might occur to a <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> class.
            </remarks>
        </member>
        <member name="M:Un4seen.BassAsio.BassAsioHandlerEventArgs.#ctor(Un4seen.BassAsio.BassAsioHandlerSyncType,System.Int32)">
            <summary>
            Initializes a new instance of the BassAsioHandlerEventArgs class by initializing all of its properties.
            </summary>
            <param name="syncType">The type of event which occurred (see <see cref="T:Un4seen.BassAsio.BassAsioHandlerSyncType"/>).</param>
            <param name="data">Some data which should be passed along with the notification event.</param>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandlerEventArgs.SyncType">
            <summary>
            Gets the type of sync which occurred.
            </summary>
        </member>
        <member name="P:Un4seen.BassAsio.BassAsioHandlerEventArgs.Data">
            <summary>
            Gets the data which was passed along with the event.
            </summary>
        </member>
        <member name="T:Un4seen.BassAsio.BassAsioHandlerSyncType">
            <summary>
            Types of event that has occurred with the <see cref="T:Un4seen.BassAsio.BassAsioHandler"/> class.
            </summary>
            <remarks>
            A variable of this type is passed inside the <see cref="T:Un4seen.BassAsio.BassAsioHandlerEventArgs"/> object 
            for the <see cref="E:Un4seen.BassAsio.BassAsioHandler.Notification" /> event.
            </remarks>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsioHandlerSyncType.SourceStalled">
            <summary>
            The Asio source is stalled.
            <para>data: the source stream channel which was stalled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsioHandlerSyncType.SourceResumed">
            <summary>
            The Asio source is resumed.
            <para>data: the source stream channel which was resumed.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassAsio.BassAsioHandlerSyncType.BufferUnderrun">
            <summary>
            A buffer underrun happened.
            <para>data: the source stream channel on which the underrun occurred.</para>
            <para>A buffer underrun might happen, if the BASS_ChannelGetData call on the source stream channel (OutputChannel) returns less data as requested.</para>
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BassWasapi">
            <summary>
            .NET API wrapper for BASSWASAPI.DLL
            <para>Requires: basswasapi.dll - Windows Audio Session API driver library - available @ <a href="http://www.un4seen.com">www.un4seen.com</a>.</para>
            </summary>
            <remarks>
            <para>BASSWASAPI is basically a wrapper for Windows Audio Session API drivers, with the addition of channel joining, format conversion and resampling.</para>
            <para>BASSWASAPI requires a soundcard with a Windows Session API drivers installed (Vista or above). It also makes use of SSE2 and 3DNow optimizations, but is fully functional without them.
            BASS is not required by BASSWASAPI, but BASS can of course be used to decode, apply DSP/FX, etc.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.#cctor">
            <summary>
            Base static contructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.#ctor">
            <summary>
            NOT used - all members are static!
            </summary>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetVersion">
            <summary>
            Retrieves the version number of the basswasapi.dll that is loaded.
            </summary>
            <returns>The BASSWASAPI version. For example, 0x02040103 (hex), would be version 2.4.1.3.</returns>
            <remarks>There is no guarantee that a previous or future version of BASSWASAPI supports all the BASSWASAPI functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.
            <para>You might use the global constant <see cref="F:Un4seen.BassWasapi.BassWasapi.BASSWASAPIVERSION"/> to check the major revision.</para>
            </remarks>
            <example>
            Checking the major version only:
            <code>
            if ( Utils.HighWord(BassWasapi.BASS_WASAPI_GetVersion()) != BassWasapi.BASSWASAPIVERSION )
            {
              MessageBox.Show(this, "Wrong BassWasapi Version!");
            }
            </code>
            <code lang="vbnet">
            If Utils.HighWord(BassWasapi.BASS_WASAPI_GetVersion()) &lt;&gt; BassWasapi.BASSWASAPIVERSION Then
              MessageBox.Show(Me, "Wrong BassWasapi Version!")
            End If
            </code>
            Checking for full version "2.4.1.3":
            <code>
            if (BassWasapi.BASS_WASAPI_GetVersion() &lt; Utils.MakeLong(0x0103, 0x0204))
            {
              MessageBox.Show(this, "Wrong BassWasapi Version!");
            }
            </code>
            <code lang="vbnet">
            If BassWasapi.BASS_WASAPI_GetVersion() &lt; Utils.MakeLong(&amp;H103, &amp;H204) Then
              MessageBox.Show(Me, "Wrong BassWasapi Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetVersion(System.Int32)">
            <summary>
            Retrieves the version of the basswasapi.dll that is loaded.
            </summary>
            <param name="fieldcount">The number of components to use. The fieldCount ranges from 1 to 4 (major.minor.build.revision).</param>
            <returns>The BASSWASAPI version (major.minor.build.revision).</returns>
            <remarks>There is no guarantee that a previous or future version of BASSWASAPI supports all the BASSWASAPI functions that you are using, so you should always use this function to make sure the correct version is loaded.
            It is safe to assume that future minor revisions (indicated in the LOWORD) will be fully compatible.</remarks>
            <example>
            <code>
            Version expectedVersion = new Version(2, 4);
            if (BassWasapi.BASS_WASAPI_GetVersion(2) &lt; expectedVersion)
            {
              MessageBox.Show( this, "Wrong BassWasapi Version!" );
            }
            </code>
            <code lang="vbnet">
            Dim expectedVersion As New Version(2, 4)
            If BassWasapi.BASS_WASAPI_GetVersion(2) &lt; expectedVersion Then
              MessageBox.Show(Me, "Wrong BassWasapi Version!")
            End If
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfoInternal(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO_INTERNAL@)">
            <summary>
            
            </summary>
            <param name="device"></param>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)">
            <summary>
            Retrieves information on a Wasapi device (endpoint).
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <param name="info">An instance of the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> class to store the information at.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Wasapi devices (endpoints) for a setup dialog. 
            <para>Note: Input (capture) devices can be determined by evaluating the <see cref="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.flags"/> member (which must be either BASS_DEVICE_INPUT or BASS_DEVICE_LOOPBACK).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            List all available endpoints:
            <code>
            BASS_WASAPI_DEVICEINFO info = new BASS_WASAPI_DEVICEINFO();
            for (int n=0; BassWasapi.BASS_WASAPI_GetDeviceInfo(n, info); n++)
            {
              Console.WriteLine(info.ToString());
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_WASAPI_DEVICEINFO()
            While (BassWasapi.BASS_WASAPI_GetDeviceInfo(n, info))
              Console.WriteLine(info.ToString())
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32)">
            <summary>
            Retrieves information on a Wasapi device (endpoint).
            </summary>
            <param name="device">The device to get the information of... 0 = first.</param>
            <returns>If successful, then an instance of the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> class is returned, else <see langword="null"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            This function can be used to enumerate the available Wasapi devices (endpoints) for a setup dialog. 
            <para>Note: Input (capture) devices can be determined by evaluating the <see cref="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.flags"/> member (which must be either BASS_DEVICE_INPUT or BASS_DEVICE_LOOPBACK).</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The device number specified is invalid.</description></item>
            </list>
            </para>
            </remarks>
            <example>
            <code>
            BASS_WASAPI_DEVICEINFO info;
            for (int n = 0; (info = BassWasapi.BASS_WASAPI_GetDeviceInfo(n)) != null; n++)
            {
              ...
            }
            </code>
            <code lang="vbnet">
            Dim n As Integer = 0
            Dim info As New BASS_WASAPI_DEVICEINFO()
            While Not (info Is Nothing)
              info = BassWasapi.BASS_WASAPI_GetDeviceDescription(n)
              If Not (info Is Nothing) Then
                ...
              End If
              n += 1
            End While
            </code>
            Or use the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfos"/> method for more convenience.
            </example>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfos">
            <summary>
            Returns all available Wasapi devices (endpoints).
            </summary>
            <returns>An array of <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> elements representing the available Wasapi devices (endpoints).</returns>
            <remarks>Uses <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> internally.
            <para>This function lists all available endpoits (rendering as well as capturing devices).
            Input (capture) devices can be determined by evaluating the <see cref="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.flags"/> member (which must be either BASS_DEVICE_INPUT or BASS_DEVICE_LOOPBACK).
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceCount">
            <summary>
            Returns the total number of available Wasapi devices (endpoints).
            </summary>
            <returns>Number of WASAPI devices (endpoints) available.</returns>
            <remarks>Uses <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> internally.</remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)">
            <summary>
            Sets the device to use for subsequent calls in the current thread.
            </summary>
            <param name="device">The device to use... 0 = first device.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system; instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>All of the BASSWASAPI functions that do not have their own "device" parameter make use of this device selection. When one of them is called, BASSWASAPI will check the current thread's device setting, and if no device is selected (or the selected device is not initialized), BASSWASAPI will automatically select the lowest device that is initialized. This means that when using a single device, there is no need to use this function; BASSWASAPI will automatically use the device that is initialized. Even if you free the device, and initialize another, BASSWASAPI will automatically switch to the one that is initialized.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The device has not been initialized.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDevice">
            <summary>
            Retrieves the Wasapi device setting in the current thread.
            </summary>
            <returns>If successful, the device number is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/>to get the error code.</returns>
            <remarks>As in BASS, simultaneously using multiple devices is supported in the BASSWASAPI API via a context switching system - instead of there being an extra "device" parameter in the function calls, the device to be used needs to be set via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/> prior to calling the function. The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called - there are no initialized devices.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_CheckFormat(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit)">
            <summary>
            Checks if a particular sample format is supported by a device (endpoint).
            </summary>
            <param name="device">The device to use... 0 = first device, -1 = default device, -2 = default input device. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> can be used to enumerate the available devices.</param>
            <param name="freq">The sample rate to check.</param>
            <param name="chans">The number of channels to check... 1 = mono, 2 = stereo, etc.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.BassWasapi.BASSWASAPIInit"/>):
            <list type="table">
            <item><term>BASS_WASAPI_SHARED</term><description>Check the device in shared mode.</description></item>
            <item><term>BASS_WASAPI_EXCLUSIVE</term><description>Check the device in exclusive mode.
            The HIWORD - use Utils.MakeLong(flags,format) - can be used to limit the sample formats that are checked in exclusive mode. The default is to check 32-bit floating-point, 32-bit integer, 24-bit integer, 16-bit integer, 8-bit integer, in that order. A BASS_WASAPI_FORMAT value (see BASS_WASAPI_INFO) can be used to bypass the formats that precede it in that list.</description></item>
            </list>
            </param>
            <returns>If the sample format is supported, the maximum supported resolution (a <see cref="T:Un4seen.BassWasapi.BASSWASAPIFormat"/> value) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Call this method prior to <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> in order to make sure the requested format is supported by the Wasapi output device/driver (endpoint).
            <para>Shared and exclusive modes may have different sample formats available.
            Only the "mix format" (available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>) is generally supported in shared mode.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The driver could not be initialized.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Unsupported sample format or number of channels.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_CheckFormat(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIFormat)">
            <summary>
            Checks if a particular sample format is supported by a device (endpoint) in exclusive mode.
            </summary>
            <param name="device">The device to use... 0 = first device, -1 = default device, -2 = default input device. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> can be used to enumerate the available devices.</param>
            <param name="freq">The sample rate to check.</param>
            <param name="chans">The number of channels to check... 1 = mono, 2 = stereo, etc.</param>
            <param name="format">Limit the sample format that is used in exclusive mode. The default is to try 32-bit floating-point, 32-bit integer, 24-bit integer, 16-bit integer, 8-bit integer, in that order. A BASS_WASAPI_FORMAT value (see <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/>) can be used to bypass the formats that precede it in that list.</param>
            <returns>If the sample format is supported, the maximum supported resolution (a <see cref="T:Un4seen.BassWasapi.BASSWASAPIFormat"/> value) is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>This overload always uses the BASS_WASAPI_EXCLUSIVE flag which will be applied automatically!
            The <paramref name="format"/> parameter can be used to limit the sample format that is used in exclusive mode.</para>
            <para>Call this method prior to <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> in order to make sure the requested format is supported by the Wasapi output device/driver (endpoint).</para>
            <para>Shared and exclusive modes may have different sample formats available.
            Only the "mix format" (available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>) is generally supported in shared mode.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The driver could not be initialized.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>Unsupported sample format or number of channels.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)">
            <summary>
            Initializes a Wasapi device/driver (endpoint).
            </summary>
            <param name="device">The device to use... 0 = first device, -1 = default output device, -2 = default input device, -3 = default loopback input device. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> can be used to enumerate the available devices.</param>
            <param name="freq">The sample rate to use... 0 = "mix format" sample rate.</param>
            <param name="chans">The number of channels to use... 0 = "mix format" channels, 1 = mono, 2 = stereo, etc.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.BassWasapi.BASSWASAPIInit"/>):
            <list type="table">
            <item><term>BASS_WASAPI_SHARED</term><description>Open the device in shared mode.</description></item>
            <item><term>BASS_WASAPI_EXCLUSIVE</term><description>Initialize the device in exclusive mode, else shared mode.
            The HIWORD - use Utils.MakeLong(flags,format) - can be used to limit the sample format that is used in exclusive mode. The default is to try 32-bit floating-point, 32-bit integer, 24-bit integer, 16-bit integer, 8-bit integer, in that order. A BASS_WASAPI_FORMAT value (see <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/>) can be used to bypass the formats that precede it in that list.</description></item>
            <item><term>BASS_WASAPI_AUTOFORMAT</term><description>Automatically choose another sample format if the specified format is not supported. If possible, a higher sample rate than freq will be used, rather than a lower one.</description></item>
            <item><term>BASS_WASAPI_BUFFER</term><description>Enable double buffering, for use by <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel"/>. This requires the BASS "no sound" device to have been initilized, via <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_WASAPI_EVENT</term><description>Enables the event-driven system.
            Enable event-driven buffering. BASSWASAPI will normally periodically write data to (or read data from) the device's buffer according to the period parameter, but with the event-driven system WASAPI will signal to BASSWASAPI when more data should be written to (or read from) the buffer. So the period parameter is ignored, and buffer is too in shared mode as the system will choose an appropriate buffer length. In exclusive mode, there are 2 buffers of buffer length that are processed alternately. Event-driven buffering is unavailable on loopback devices.
            </description></item>
            <item><term>BASS_WASAPI_SAMPLES</term><description><paramref name="buffer"/> and <paramref name="period"/> are in samples rather than seconds.</description></item>
            <item><term>BASS_WASAPI_DITHER</term><description>Requests to apply dither to the output.
            Dither is optional rather than automatic because it destroys bit-perfect output; you probably don't want to enable it unless you're applying DSP (including volume changes).
            When the output is floating-point (eg. in shared mode), the flag will have no effect.</description></item>
            </list>
            </param>
            <param name="buffer">The length of the device's buffer in seconds. This is a minimum and the driver may choose to use a larger buffer; <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> can be used to confirm what the buffer size is. For an output device, the buffer size determines the latency. With event-driven exclusive mode, there will be 2 buffers of this length, so the total buffer length is double.</param>
            <param name="period">The interval (in seconds or samples depending on BASS_WASAPI_SAMPLES) between callback function calls... 0 = use default. If the specified period is below the minimum update period, it will automatically be raised to that. This is ignored when the BASS_WASAPI_EVENT flag is specified, except in shared mode when buffer = 0 on Windows 10 (see remarks).
            <para>The update period specifies the time between <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> calls.
            The <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> (see <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>) "minperiod" and "defperiod" values are actually minimum/default update periods.
            </para>
            </param>
            <param name="proc">The user defined function to process the channel. Use <see langword="null"/> to create a Wasapi "push" device (to which you can feed sample data via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If the device was successfully initialized, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>For convenience, devices are always initialized to use their highest sample resolution and that is then converted to 32-bit floating-point, so that WASAPIPROC callback functions and the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> functions are always dealing with the same sample format.
            The device's sample format can be obtained via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/>.</para>
            <para>WASAPI does not support arbitrary sample formats, like DirectSound does. In particular, only the "mix format" (available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>) is generally supported in shared mode.
            <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_CheckFormat(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit)"/> can be used to check whether a particular sample format is supported. The BASSmix add-on can be used to play (or record) in otherwise unsupported sample formats, as well as playing multiple sources.</para>
            <para>A loopback device can only be used when the corresponding output device is not being used in exclusive mode, and it will only deliver data when the ouput device does; if the output device produces no data, then the loopback device will capture no data.</para>
            <para>Shared mode usually has a fixed period of 10ms, but Windows 10 supports shorter periods, which allows smaller buffers and lower latency. 
            A shorter period (and buffer) can be requested by setting buffer to 0 and period to the length wanted. If the requested period is lower than the device (or Windows) supports, then it will be automatically raised to the minimum supported. 
            It will also be rounded up if it does not match the device's granularity. The actual period in use can be determined from the (minimum) amount of data that gets requested from the WASAPIPROC callback function. 
            The shared mode period is a system-wide setting that affects all users of the device, particular those using event-driven buffering; they will be asked to provide data at the new period. 
            If another process is already using a non-default period, then it will not be possible to set a different period until they finish; the existing period will have to be used in the meantime.</para>
            <para>The initialized device will not begin processing data until <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start"/> is called.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system; instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/> is used to switch the current device.
            When successful, <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> automatically sets the current thread's device to the one that was just initialized.</para>
            <para>When using the default output or input device, <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDevice"/> can be used to find out which device it was mapped to.</para>
            <para>In SHARED mode you must initialize the device with the current WASAPI mixer sample rate and number of channels (see the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> "mixfreq" and "mixchans" properties).</para>
            <para>In EXCLUSIVE mode you might use any sample rate and number of channels which are supported by the device/driver.</para>
            <para>This function must be successfully called before any input or output can be performed.</para>
            <para>In EXCLUSIVE mode, the "period" value will affect what's an acceptable "buffer" value (it appears that the buffer must be at least 4x the period).
            In SHARED mode, it's the other way round, the "period" will be reduced to fit the "buffer" if necessary (with a minimum of the "defperiod" value).
            The system will limit them to an acceptable range, so for example, you could use a very small value (eg. 0.0001) for both, to get the minimum possible latency.</para>
            <para>Note: When initializing an input (capture or loopback) device, it might be the case, that the device is automatically muted once initialized.
            You can use the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetMute(Un4seen.BassWasapi.BASSWASAPIVolume)"/>/<see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetMute(Un4seen.BassWasapi.BASSWASAPIVolume,System.Boolean)"/> methods to check and probably toggle this.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>A device has already been initialized. You must call <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Free"/> before you can initialize again.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>Event-driven buffering and exclusive mode are unavailable on loopback devices.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified (a WASAPIPROC must be provided for an input device).</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The driver could not be initialized.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported by the device. If the BASS_WASAPI_AUTOFORMAT flag was specified, no other format could be found either.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The BASS "no sound" device has not been initialized.</description></item>
            <item><term>BASS_ERROR_BUSY</term><description>The device is busy (eg. in "exclusive" use by another process).</description></item>
            <item><term>BASS_ERROR_WASAPI_BUFFER</term><description><paramref name="buffer"/> is too large or small (exclusive mode only).</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery error.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,Un4seen.BassWasapi.BASSWASAPIFormat,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)">
            <summary>
            Initializes a Wasapi device/driver (endpoint) in exclusive mode.
            </summary>
            <param name="device">The device to use... 0 = first device, -1 = default output device, -2 = default input device. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> can be used to enumerate the available devices.</param>
            <param name="freq">The sample rate to use... 0 = "mix format" sample rate.</param>
            <param name="chans">The number of channels to use... 0 = "mix format" channels, 1 = mono, 2 = stereo, etc.</param>
            <param name="flags">Any combination of these flags (see <see cref="T:Un4seen.BassWasapi.BASSWASAPIInit"/>):
            <list type="table">
            <item><term>BASS_WASAPI_EXCLUSIVE</term><description>This flag will be applied automatically by this overload!
            The <paramref name="format"/> parameter can be used to limit the sample format that is used in exclusive mode.</description></item>
            <item><term>BASS_WASAPI_AUTOFORMAT</term><description>Automatically choose another sample format if the specified format is not supported. If possible, a higher sample rate than freq will be used, rather than a lower one.</description></item>
            <item><term>BASS_WASAPI_BUFFER</term><description>Enable double buffering, for use by <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel"/>. This requires the BASS "no sound" device to have been initilized, via <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</description></item>
            <item><term>BASS_WASAPI_EVENT</term><description>Enables the event-driven system.
            It is only supported when a WASAPIPROC function is provided, ie. not when using <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/>.
            When used with shared mode, the user-provided 'buffer' and 'period' lengths are ignored and WASAPI decides what buffer to use (<see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> can be used to check that).
            </description></item>
            </list>
            </param>
            <param name="format">Limit the sample format that is used in exclusive mode. The default is to try 32-bit floating-point, 32-bit integer, 24-bit integer, 16-bit integer, 8-bit integer, in that order. A BASS_WASAPI_FORMAT value (see <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/>) can be used to bypass the formats that precede it in that list.</param>
            <param name="buffer">The length of the device's buffer in seconds. This is a minimum and the driver may choose to use a larger buffer; <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> can be used to confirm what the buffer size is. For an output device, the buffer size determines the latency.</param>
            <param name="period">The interval (in seconds) between callback function calls... 0 = use default. If the specified period is below the minimum update period, it will automatically be raised to that.
            <para>The update period specifies the time between <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> calls.
            The <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> (see <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>) "minperiod" and "defperiod" values are actually minimum/default update periods.
            </para>
            </param>
            <param name="proc">The user defined function to process the channel. Use <see langword="null"/> to create a Wasapi "push" device (to which you can feed sample data via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/>).</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If the device was successfully initialized, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>For convenience, devices are always initialized to use their highest sample resolution and that is then converted to 32-bit floating-point, so that WASAPIPROC callback functions and the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> functions are always dealing with the same sample format.
            The device's sample format can be obtained via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/>.</para>
            <para>WASAPI does not support arbitrary sample formats, like DirectSound does. In particular, only the "mix format" (available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>) is generally supported in shared mode.
            <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_CheckFormat(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit)"/> can be used to check whether a particular sample format is supported. The BASSmix add-on can be used to play (or record) in otherwise unsupported sample formats, as well as playing multiple sources.</para>
            <para>The initialized device will not begin processing data until <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start"/> is called.</para>
            <para>Simultaneously using multiple devices is supported in the BASS API via a context switching system; instead of there being an extra "device" parameter in the function calls, the device to be used is set prior to calling the functions. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/> is used to switch the current device.
            When successful, <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> automatically sets the current thread's device to the one that was just initialized.</para>
            <para>When using the default output or input device, <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDevice"/> can be used to find out which device it was mapped to.</para>
            <para>In SHARED mode you must initialize the device with the current WASAPI mixer sample rate and number of channels (see the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> "mixfreq" and "mixchans" properties).</para>
            <para>In EXCLUSIVE mode you might use any sample rate and number of channels which are supported by the device/driver.</para>
            <para>This function must be successfully called before any input or output can be performed.</para>
            <para>In EXCLUSIVE mode, the "period" value will affect what's an acceptable "buffer" value (it appears that the buffer must be at least 4x the period).
            In SHARED mode, it's the other way round, the "period" will be reduced to fit the "buffer" if necessary (with a minimum of the "defperiod" value).
            The system will limit them to an acceptable range, so for example, you could use a very small value (eg. 0.0001) for both, to get the minimum possible latency.</para>
            <para>Note: When initializing an input (capture or loopback) device, it might be the case, that the device is automatically muted once initialized.
            You can use the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetMute(Un4seen.BassWasapi.BASSWASAPIVolume)"/>/<see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetMute(Un4seen.BassWasapi.BASSWASAPIVolume,System.Boolean)"/> methods to check and probably toggle this.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description>The <paramref name="device"/> number specified is invalid.</description></item>
            <item><term>BASS_ERROR_ALREADY</term><description>A device has already been initialized. You must call <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Free"/> before you can initialize again.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description>An illegal parameter was specified (a WASAPIPROC must be provided for an input device).</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The driver could not be initialized.</description></item>
            <item><term>BASS_ERROR_FORMAT</term><description>The specified format is not supported by the device. If the BASS_WASAPI_AUTOFORMAT flag was specified, no other format could be found either.</description></item>
            <item><term>BASS_ERROR_INIT</term><description>The BASS "no sound" device has not been initialized.</description></item>
            <item><term>BASS_ERROR_BUSY</term><description>The device is busy (eg. in "exclusive" use by another process).</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery error.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Free">
            <summary>
            Frees the Wasapi device/driver (endpoint).
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This function should be called for all initialized devices before the program closes. Freed devices do not need to have been stopped with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Stop(System.Boolean)"/> beforehand.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)">
            <summary>
            Retrieves information on the Wasapi device being used.
            </summary>
            <param name="info">An instance of the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/> class to store the information at.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>This method can be used to get the effective settings used with an initialized WASAPI device (endpoint).
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo">
            <summary>
            Retrieves information on the Wasapi device being used.
            </summary>
            <returns>An instance of the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/> class on success - else <see langword="null"/>.</returns>
            <remarks>This method can be used to get the effective settings used with an initialized WASAPI device (endpoint).
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start">
            <summary>
            Starts processing the current Wasapi device/driver (endpoint).
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Before starting the device, it must be initialized using <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/>. Use <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Stop(System.Boolean)"/> to stop processing the device.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Stop(System.Boolean)">
            <summary>
            Stops the current Wasapi device/driver (endpoint).
            </summary>
            <param name="reset">Flush the device buffer?
            <para><see langword="true"/> will clear the output buffer. Otherwise it is like pausing, eg. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start"/> will resume playing the buffered data.</para>
            </param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>If the device buffer is left unflushed (reset=FALSE), a subsequent <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start"/> call will resume things with the buffered data, otherwise it will resume with fresh data.</para>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_START</term><description>The device hasn't been started.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_IsStarted">
            <summary>
            Checks, if the current Wasapi device/driver (endpoint) has been already started (via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start"/>).
            </summary>
            <returns>Returns <see langword="true"/>, if the device has been started, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetCPU">
            <summary>
            Retrieves the current CPU usage of BASSWASAPI.
            </summary>
            <returns>The BASSWASAPI CPU usage as a percentage of total CPU time.</returns>
            <remarks>This function includes the time taken by the <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> callback functions.</remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Lock(System.Boolean)">
            <summary>
            Locks the device to the current thread.
            </summary>
            <param name="state">If <see langword="false"/>, unlock WASAPI, else lock it.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Locking a device prevents other threads from accessing the device buffer, including a WASAPIPROC. Other threads wanting to access a locked device will block until it is unlocked, so a device should only be locked very briefly.
            A device must be unlocked in the same thread that it was locked.
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetVolume(Un4seen.BassWasapi.BASSWASAPIVolume,System.Single)">
            <summary>
            Sets the volume of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="curve">Volume curve to use, one of the following:
            <list type="table">
            <item><term>BASS_WASAPI_CURVE_DB</term><description>Logarithmic curve.</description></item>
            <item><term>BASS_WASAPI_CURVE_LINEAR</term><description>Linear curve.</description></item>
            <item><term>BASS_WASAPI_CURVE_WINDOWS</term><description>Windows' hybrid curve.</description></item>
            <item><term>BASS_WASAPI_VOL_SESSION</term><description>Set the session volume, else the device volume.</description></item>
            </list>
            </param>
            <param name="volume">The new volume to set between 0.0 (silent) and 1.0 (maximum) if linear, or else a dB level.</param>
            <returns>Returns <see langword="true"/> on success, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            Session volume only affects the current process, so other users of the device are unaffected. It has no effect on exclusive mode output, and maps to the device volume with input devices (so does affect other users).
            Session volume always uses the BASS_WASAPI_CURVE_WINDOWS curve.
            If you need to control the volume of the stream only, you need to apply that directly within the <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> yourself.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control available.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="volume"/> is invalid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetVolume(Un4seen.BassWasapi.BASSWASAPIVolume)">
            <summary>
            Retrieves the current volume level.
            </summary>
            <param name="curve">Volume curve to use, one of the following:
            <list type="table">
            <item><term>BASS_WASAPI_CURVE_DB</term><description>Logarithmic curve.</description></item>
            <item><term>BASS_WASAPI_CURVE_LINEAR</term><description>Linear curve.</description></item>
            <item><term>BASS_WASAPI_CURVE_WINDOWS</term><description>Windows' hybrid curve.</description></item>
            <item><term>BASS_WASAPI_VOL_SESSION</term><description>Get the session volume, else the device volume.</description></item>
            </list>
            </param>
            <returns>If successful, the volume level is returned, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Session volume always uses the BASS_WASAPI_CURVE_WINDOWS curve.
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)">
            <summary>
            Adds sample data to an output device buffer ("push" device).
            </summary>
            <param name="buffer">The pointer to the sample data to provide.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4). <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> with the BASS_DATA_AVAILABLE flag can be used to check how much data is queued.</param>
            <returns>If successful, the the amount of data copied from the provided buffer will be returned (which may be less than requested if it doesn't all fit in the device buffer, see the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/> "buflen" property), else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>You must have initialized the device via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> using <see langword="null"/> for the <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/>.
            <para>As much data as possible will be placed in the device's buffer; this function will have to be called again for any remainder.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, ouput will stall until more data is provided. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check how much data is buffered.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The device is being fed by a WASAPIPROC callback function, or it is an input device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.Single[],System.Int32)">
            <summary>
            Adds sample data to an output device buffer ("push" device).
            </summary>
            <param name="buffer">The array of float sample data to provide.</param>
            <param name="length">The amount of data in bytes! (buffer.Length/4). <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> with the BASS_DATA_AVAILABLE flag can be used to check how much data is queued.</param>
            <returns>If successful, the the amount of data copied from the provided buffer will be returned (which may be less than requested if it doesn't all fit in the device buffer, see the <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/> "buflen" property), else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>You must have initialized the device via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> using <see langword="null"/> for the <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/>.
            <para>As much data as possible will be placed in the device's buffer; this function will have to be called again for any remainder.</para>
            <para>Data should be provided at a rate sufficent to sustain playback. If the buffer gets exhausted, ouput will stall until more data is provided. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check how much data is buffered.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The device is being fed by a WASAPIPROC callback function, or it is an input device.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid, it must equate to a whole number of samples.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel">
            <summary>
            Retrieves the level (peak amplitude) of the current Wasapi device/driver (endpoint).
            </summary>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the level of the left channel is returned in the low word (low 16-bits, use <see cref="M:Un4seen.Bass.Utils.LowWord32(System.Int32)"/>), and the level of the right channel is returned in the high word (high 16-bits, use <see cref="M:Un4seen.Bass.Utils.HighWord32(System.Int32)"/>). If the channel is mono, then the low word is duplicated in the high word. 
            The level ranges linearly from 0 (silent) to 32768 (max). 0 will be returned when a channel is stalled.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/>, but it gets the level from the devices's buffer instead of decoding data from a channel, which means that the device doesn't miss out on any data. 
            The BASS_WASAPI_BUFFER flag needs to have been specified in the device's initialization to enable the use of this function.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The device was not initialized using buffering (BASS_WASAPI_BUFFER).</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel(System.Single[],System.Single,Un4seen.Bass.BASSLevel)">
            <summary>
            Retrieves the level of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="levels">The array in which the levels are to be returned.</param>
            <param name="length">The amount of data to inspect to calculate the level, in seconds. The maximum is 1 second. Less data than requested may be used if the full amount is not available, eg. if the device's buffer is shorter.</param>
            <param name="flags">What levels to retrieve. One of the following (see <see cref="T:Un4seen.Bass.BASSLevel"/>):
            <list type="table">
            <item><term>BASS_LEVEL_ALL</term><description>Retrieves a separate level for each channel.</description></item>
            <item><term>BASS_LEVEL_MONO</term><description>Retrieve a single mono level.</description></item>
            <item><term>BASS_LEVEL_STEREO</term><description>Get a stereo level. The left level will be from the even channels, and the right level will be from the odd channels. If there are an odd number of channels then the left and right levels will both include all channels.</description></item>
            <item><term>BASS_LEVEL_RMS</term><description>Flag: Get the RMS level. Otherwise the peak level.</description></item>
            </list>
            </param>
            <returns>On success <see langword="true"/> is returned - else <see langword="false"/>, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the requested levels are returned in the <paramref name="levels"/> array.</para>
            </returns>
            <remarks>
            This function uses <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> internally, so it behaves identically to that. 
            The BASS_WASAPI_BUFFER flag needs to have been specified in the device's initialization to enable the use of this function.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_WASAPI_BUFFER flag was not specified in the device's initialization.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel(System.Single,Un4seen.Bass.BASSLevel)">
            <summary>
            Retrieves the level of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="length">The amount of data to inspect to calculate the level, in seconds. The maximum is 1 second. Less data than requested may be used if the full amount is not available, eg. if the device's buffer is shorter.</param>
            <param name="flags">What levels to retrieve. One of the following (see <see cref="T:Un4seen.Bass.BASSLevel"/>):
            <list type="table">
            <item><term>BASS_LEVEL_ALL</term><description>Retrieves a separate level for each channel.</description></item>
            <item><term>BASS_LEVEL_MONO</term><description>Retrieve a single mono level.</description></item>
            <item><term>BASS_LEVEL_STEREO</term><description>Get a stereo level. The left level will be from the even channels, and the right level will be from the odd channels. If there are an odd number of channels then the left and right levels will both include all channels.</description></item>
            <item><term>BASS_LEVEL_RMS</term><description>Flag: Get the RMS level. Otherwise the peak level.</description></item>
            </list>
            </param>
            <returns>On success <see langword="true"/> is returned - else <see langword="false"/>, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.
            <para>If successful, the requested levels are returned.</para>
            </returns>
            <remarks>
            This function uses <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetLevel(System.Int32)"/> internally, so it behaves identically to that. 
            The BASS_WASAPI_BUFFER flag needs to have been specified in the device's initialization to enable the use of this function.
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The BASS_WASAPI_BUFFER flag was not specified in the device's initialization.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="length"/> is not valid.</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of the current Wasapi device/driver (endpoint).
            This overload uses an IntPtr to reference the buffer data.
            </summary>
            <param name="buffer">Location to write the data to.
            <para>Use "Marshal.AllocCoTaskMem" to allocate a memory buffer, use "Marshal.Copy" to copy the buffer data from unmanaged BASS to your managed code and use "Marshal.FreeCoTaskMem" to free the memory buffer when not needed anymore.</para>
            <para>Or make use of a "GCHandle" to receive data to a pinned managed object.</para>
            </param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the device has buffered (the BASS_WASAPI_BUFFER flag isn't required for this, <paramref name="buffer"/> can be <see langword="null"/> when using this flag).</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the device (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the device's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the device's buffer instead of decoding it from a channel, 
            which means that the device doesn't miss out on any data. In order to do this, the device must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>Internally, a BASS stream is used for that, so the usual BASS_DATA_xxx flags are supported. That also means that BASS needs to have been initialized first; it specifically uses the "no sound" device. 
            If the device is subsequently freed, this method call will fail.</para>
            <para>As in BASS, simultaneously using multiple devices is supported in the BASSWASAPI API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>With an output device, the BASS_DATA_AVAILABLE return value may be larger than the buffer size indicated by <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> due to additional latency in the device/driver. 
            When a mixer is feeding an output device, the BASS_DATA_AVAILABLE return value can be used with the BASS_ATTRIB_MIXER_LATENCY attribute and/or the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPositionEx(System.Int32,Un4seen.Bass.BASSMode,System.Int32)"/> function, to have the mixer account for the latency in its source position reporting and data/level retrieval.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The device was not initialized using buffering (BASS_WASAPI_BUFFER).</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.Single[],System.Int32)">
            <summary>
            Retrieves the immediate sample data (or an FFT representation of it) of the current Wasapi device/driver (endpoint).
            This overload uses a managed float[] to reference the buffer data as 32-bit!
            </summary>
            <param name="buffer">The array (float[]) to write the data to.</param>
            <param name="length">Number of bytes wanted, and/or the following flags (<see cref="T:Un4seen.Bass.BASSData"/>):
            <list type="table">
            <item><term>BASS_DATA_FLOAT</term><description>Return floating-point sample data.</description></item>
            <item><term>BASS_DATA_FFT256</term><description>256 sample FFT (returns 128 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT512</term><description>512 sample FFT (returns 256 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT1024</term><description>1024 sample FFT (returns 512 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT2048</term><description>2048 sample FFT (returns 1024 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT4096</term><description>4096 sample FFT (returns 2048 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT8192</term><description>8192 sample FFT (returns 4096 floating-point values)</description></item>
            <item><term>BASS_DATA_FFT_INDIVIDUAL</term><description>Use this flag to request separate FFT data for each channel. The size of the data returned (as listed above) is multiplied by the number channels.</description></item>
            <item><term>BASS_DATA_FFT_NOWINDOW</term><description>This flag can be used to prevent a hanning window being applied to the sample data when performing an FFT.</description></item>
            <item><term>BASS_DATA_AVAILABLE</term><description>Query the amount of data the device has buffered (the BASS_WASAPI_BUFFER flag isn't required for this, <paramref name="buffer"/> can be <see langword="null"/> when using this flag).</description></item>
            </list>
            </param>
            <returns>If an error occurs, -1 is returned, use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code. 
            <para>When requesting FFT data, the number of bytes read from the device (to perform the FFT) is returned.</para>
            <para>When requesting sample data, the number of bytes written to buffer will be returned (not necessarily the same as the number of bytes read when using the BASS_DATA_FLOAT flag).</para>
            <para>When using the BASS_DATA_AVAILABLE flag, the number of bytes in the device's buffer is returned.</para>
            </returns>
            <remarks>
            <para>This function is like the standard <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/>, but it gets the data from the device's buffer instead of decoding it from a channel, 
            which means that the device doesn't miss out on any data. In order to do this, the device must have buffering enabled, via the BASS_MIXER_BUFFER flag.</para>
            <para>As in BASS, simultaneously using multiple devices is supported in the BASSWASAPI API via a context switching system - instead of there being an extra "device" parameter in the function calls, 
            the device to be used needs to be set via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/> prior to calling the function. 
            The device setting is local to the current thread, so calling functions with different devices simultaneously in multiple threads is not a problem.</para>
            <para>With an output device, the BASS_DATA_AVAILABLE return value may be larger than the buffer size indicated by <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> due to additional latency in the device/driver. 
            When a mixer is feeding an output device, the BASS_DATA_AVAILABLE return value can be used with the BASS_ATTRIB_MIXER_LATENCY attribute and/or the <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_ChannelGetPositionEx(System.Int32,Un4seen.Bass.BASSMode,System.Int32)"/> function, to have the mixer account for the latency in its source position reporting and data/level retrieval.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>The device was not initialized using buffering (BASS_WASAPI_BUFFER).</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceLevel(System.Int32,System.Int32)">
            <summary>
            Gets the audio meter information of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="device">The device to use... 0 = first device. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> can be used to get the total number of devices.</param>
            <param name="chan">The channel number to get the audio level meter information from (0=first, -1=all).</param>
            <returns>The audio level between 0.0 (silence) and 1.0 (maximum).</returns>
            <remarks>This method returns the global session level for the device which might include the level of other applications using the same device in shared-mode.
            <para>This function gets the level from the device/driver, or WASAPI if the device does not have its own level meter. If the latter case, the level will be unavailable when exclusive mode is active.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_WASAPI</term><description>WASAPI is not available.</description></item>
            <item><term>BASS_ERROR_DEVICE</term><description><paramref name="device"/> is not valid.</description></item>
            <item><term>BASS_ERROR_DRIVER</term><description>The device driver does not support level retrieval.</description></item>
            <item><term>BASS_ERROR_ILLPARAM</term><description><paramref name="chan"/> is not valid.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetMute(Un4seen.BassWasapi.BASSWASAPIVolume,System.Boolean)">
            <summary>
            Sets the mute status of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="mode">The type of volume to set:
            <list type="table">
            <item><term>BASS_WASAPI_VOL_SESSION</term><description>Set the session volume.</description></item>
            <item><term>BASS_WASAPI_VOL_DEVICE</term><description>Set the device volume.</description></item>
            </list>
            </param>
            <param name="mute"><see langword="true"/> to mute the device, <see langword="false"/> to unmute the device.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetMute(Un4seen.BassWasapi.BASSWASAPIVolume)">
            <summary>
            Gets the mute status of the current Wasapi device/driver (endpoint).
            </summary>
            <param name="mode">The type of volume to get:
            <list type="table">
            <item><term>BASS_WASAPI_VOL_SESSION</term><description>Get the session volume.</description></item>
            <item><term>BASS_WASAPI_VOL_DEVICE</term><description>Get the device volume.</description></item>
            </list>
            </param>
            <returns>Returns <see langword="true"/>, if the device/session is muted and <see langword="false"/> if unmuted, else -1 is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            <para>When using multiple devices, the current thread's device setting (as set with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetDevice(System.Int32)"/>) determines which device this function call applies to.</para>
            <para>
            <list type="table">
            <listheader><term><see cref="T:Un4seen.Bass.BASSError">ERROR CODE</see></term><description>Description</description></listheader>
            <item><term>BASS_ERROR_INIT</term><description><see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> has not been successfully called.</description></item>
            <item><term>BASS_ERROR_NOTAVAIL</term><description>There is no volume control available.</description></item>
            <item><term>BASS_ERROR_UNKNOWN</term><description>Some other mystery problem!</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetNotify(Un4seen.BassWasapi.WASAPINOTIFYPROC,System.IntPtr)">
            <summary>
            Sets a device change notification callback.
            </summary>
            <param name="proc">User defined notification function... <see langword="null"/> = disable notifications.</param>
            <param name="user">User instance data to pass to the callback function.</param>
            <returns>If successful, <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>
            A previously set notification callback can be changed (or removed) at any time, by calling this function again.
            <para>If the BASSWASAPI DLL is loaded dynamically (eg. via LoadLibrary), this function should be called with NULL parameters prior to unloading the DLL.</para>
            </remarks>
        </member>
        <member name="F:Un4seen.BassWasapi.BassWasapi.BASSWASAPIVERSION">
            <summary>
            Current BASSWASAPI version (without minor revision).
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASSWASAPIDeviceType">
            <summary>
            BassWasapi device info types to be used with <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_NETWORKDEVICE">
            <summary>
            A network device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_SPEAKERS">
            <summary>
            A speakers device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_LINELEVEL">
            <summary>
            A line level device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_HEADPHONES">
            <summary>
            A headphone device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_MICROPHONE">
            <summary>
             A microphone device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_HEADSET">
            <summary>
             A headset device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_HANDSET">
            <summary>
             A handset device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_DIGITAL">
            <summary>
             A digital device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_SPDIF">
            <summary>
             A S/PDIF device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_HDMI">
            <summary>
             A HDMI device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceType.BASS_WASAPI_TYPE_UNKNOWN">
            <summary>
             An unknown device.
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASSWASAPIDeviceInfo">
            <summary>
            BassWasapi device info flags to be used with <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_UNKNOWN">
            <summary>
            Unknown flags.
            <para>E.g. the WASAPI device is not present.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_ENABLED">
            <summary>
            The WASAPI device is enabled (active).
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_DEFAULT">
            <summary>
            The WASAPI device is the default device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_INIT">
            <summary>
            The WASAPI device is initialized.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_LOOPBACK">
            <summary>
            The WASAPI device is a loopback device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_INPUT">
            <summary>
            The WASAPI device is an input (capture) device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_UNPLUGGED">
            <summary>
            The WASAPI device is unplugged.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIDeviceInfo.BASS_DEVICE_DISABLED">
            <summary>
            The WASAPI device is disabled.
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASSWASAPIInit">
            <summary>
            BassWasapi initialization flags to be used with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/>.
            </summary>
            <remarks>The BASS_WASAPI_CATEGORY_xxx flags might be used to request a particular audio category.
            Audio categories (selected by applications) are mapped to audio modes (defined by drivers). In order to inform the system about the usage of an audio stream, applications have the option to tag the stream with a specific audio stream category.
            </remarks>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_SHARED">
            <summary>
            Init the device (endpoint) in shared mode.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_EXCLUSIVE">
            <summary>
            Init the device (endpoint) in exclusive mode.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_AUTOFORMAT">
            <summary>
            Automatically choose another sample format if the specified format is not supported.
            If possible, a higher sample rate than freq will be used, rather than a lower one.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_BUFFER">
            <summary>
            Enable double buffering, for use by <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel"/>. 
            This requires the BASS "no sound" device to have been initilized, via <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.
            <para>Internally, a BASS stream is used for that, so the usual BASS_DATA_xxx flags are supported.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_EVENT">
            <summary>
            Enables the event-driven WASAPI system.
            <para>It is only supported when a WASAPIPROC function is provided, ie. not when using <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/>.</para>
            <para>When used with shared mode, the user-provided 'buffer' and 'period' lengths are ignored and WASAPI decides what buffer to use (<see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> can be used to check that).</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_SAMPLES">
            <summary>
            Allows 'buffer' and 'period' to be specified in samples instead of seconds in the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> call.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_DITHER">
            <summary>
            Requests to apply dither to the output.
            <para>Dither is optional rather than automatic because it destroys bit-perfect output; you probably don't want to enable it unless you're applying DSP (including volume changes).
            When the output is floating-point (eg. in shared mode), the flag will have no effect.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_RAW">
            <summary>
            Requests raw output (sets the audio category RAW for the application).
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_MASK">
            <summary>
            Flag: to mask the category flags.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_OTHER">
            <summary>
            Flags: Requests the category uncategorized streams.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_FOREGROUNDONLYMEDIA">
            <summary>
            Flags: Requests the category foreground music.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_BACKGROUNDCAPABLEMEDIA">
            <summary>
            Flags: Requests the category background music.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_COMMUNICATIONS">
            <summary>
            Flags: Requests the category VoIP, real-time chat.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_ALERTS">
            <summary>
            Flags: Requests the category alarm, ring tone, notifications.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_SOUNDEFFECTS">
            <summary>
            Flags: Requests the category beeps, dings, etc.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_GAMEEFFECTS">
            <summary>
            Flags: Requests the category in-game balls bouncing, car engine sounds, bullets, etc.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_GAMEMEDIA">
            <summary>
            Flags: Requests the category in-game music.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_GAMECHAT">
            <summary>
            Flags: Requests the category in-game communication between users.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_SPEECH">
            <summary>
            Flags: Requests the category speech input (e.g. personal assistant) and output (e.g. navigation apps).
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_MOVIE">
            <summary>
            Flags: Requests the category movies, video with dialog.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIInit.BASS_WASAPI_CATEGORY_MEDIA">
            <summary>
            Flags: Requests the default category for media playback.
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASSWASAPIFormat">
            <summary>
            BassWasapi sample formats to be used with <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIFormat.BASS_WASAPI_FORMAT_UNKNOWN">
            <summary>
            32-bit floating-point.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIFormat.BASS_WASAPI_FORMAT_FLOAT">
            <summary>
            32-bit floating-point.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIFormat.BASS_WASAPI_FORMAT_8BIT">
            <summary>
            8-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIFormat.BASS_WASAPI_FORMAT_16BIT">
            <summary>
            16-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIFormat.BASS_WASAPI_FORMAT_24BIT">
            <summary>
            24-bit integer.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIFormat.BASS_WASAPI_FORMAT_32BIT">
            <summary>
            32-bit integer.
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASSWASAPIVolume">
            <summary>
            The BassWasapi Volume curve to use with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetVolume(Un4seen.BassWasapi.BASSWASAPIVolume)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetVolume(Un4seen.BassWasapi.BASSWASAPIVolume,System.Single)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIVolume.BASS_WASAPI_CURVE_DB">
            <summary>
            Logarithmic curve.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIVolume.BASS_WASAPI_CURVE_LINEAR">
            <summary>
            Linear curve.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIVolume.BASS_WASAPI_CURVE_WINDOWS">
            <summary>
            Windows' hybrid curve.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIVolume.BASS_WASAPI_VOL_SESSION">
            <summary>
            Use the session volume.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPIVolume.BASS_WASAPI_VOL_DEVICE">
            <summary>
            Use the device volume.
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASSWASAPINotify">
            <summary>
            BassWasapi sample formats to be used with <see cref="T:Un4seen.BassWasapi.BASS_WASAPI_INFO"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPINotify.BASS_WASAPI_NOTIFY_ENABLED">
            <summary>
            The device's status has changed, ie. it has been enabled. The new status is also available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPINotify.BASS_WASAPI_NOTIFY_DISABLED">
            <summary>
            The device's status has changed, ie. it has been disabled. The new status is also available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPINotify.BASS_WASAPI_NOTIFY_DEFOUTPUT">
            <summary>
            The device is now the default input device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPINotify.BASS_WASAPI_NOTIFY_DEFINPUT">
            <summary>
            The device is now the default input device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASSWASAPINotify.BASS_WASAPI_NOTIFY_FAIL">
            <summary>
            The device has failed and been stopped. 
            <para>If the device is still enabled and shared mode was being used, then it may be that the device's sample format has changed. 
            It can be freed and reinitialized, with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Free"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/>, to resume in that case.</para>
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO">
            <summary>
            Used with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/> to retrieve information on a Wasapi device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.name">
            <summary>
            The description of the device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.id">
            <summary>
            The ID of the driver being used.
            </summary>
            <remarks>The "id" can be matched-up the <see cref="T:Un4seen.Bass.BASS_DEVICEINFO"/> "driver", to match-up the WASAPI and DirectSound device list entries.</remarks>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.type">
            <summary>
            The type of the devices. One of the <see cref="T:Un4seen.BassWasapi.BASSWASAPIDeviceType"/> values.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.flags">
            <summary>
            The device's current and input/output status. Any combination of <see cref="T:Un4seen.BassWasapi.BASSWASAPIDeviceInfo"/>.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.minperiod">
            <summary>
            The minimum update period (in seconds) of the device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.defperiod">
            <summary>
            The default update period (in seconds) of the device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.mixfreq">
            <summary>
            The shared-mode format mixers sample rate.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.mixchans">
            <summary>
            The shared-mode format mixers number of channels.
            </summary>
        </member>
        <member name="M:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.ToString">
            <summary>
            A description of the decive info object (name).
            </summary>
            <returns>The name of the device/driver.</returns>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsEnabled">
            <summary>
            The device is enabled and can be used (i.e. it is active).
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsDisabled">
            <summary>
            The device is plugged but disabled (in the windows sound control panel) and can not be used.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsUnplugged">
            <summary>
            The device is unplugged and can not be used.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsDefault">
            <summary>
            The device is the system default device.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsInitialized">
            <summary>
            The device is already initialized.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsLoopback">
            <summary>
            The device is a loopback device (capturing from output).
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.IsInput">
            <summary>
            The device is an input (capture) device.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO.SupportsRecording">
            <summary>
            The device supportes recording (either an INPUT or LOOPBACK device).
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BASS_WASAPI_INFO">
            <summary>
            Used with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetInfo(Un4seen.BassWasapi.BASS_WASAPI_INFO)"/> to retrieve information on the current device.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.initflags">
            <summary>
            The flags parameter of the <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> call.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.freq">
            <summary>
            The sample rate used.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.chans">
            <summary>
            The number of channels used (1 = mono, 2 = stereo, etc.).
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.format">
            <summary>
            The device's sample format used (one of the <see cref="T:Un4seen.BassWasapi.BASSWASAPIFormat"/>).
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.buflen">
            <summary>
            The buffer size in bytes.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.volmax">
            <summary>
            The maximum volume setting in dB.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.volmin">
            <summary>
            The minimum volume setting in dB.
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BASS_WASAPI_INFO.volstep">
            <summary>
            The volume step size in dB.
            </summary>
        </member>
        <member name="M:Un4seen.BassWasapi.BASS_WASAPI_INFO.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Un4seen.BassWasapi.BASS_WASAPI_INFO.ToString">
            <summary>
            A description of the decive info object (the format, sample rate and number of channels).
            </summary>
            <returns>The description string of the device/driver.</returns>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_INFO.IsExclusive">
            <summary>
            Is the device used in exclusive mode?
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BASS_WASAPI_INFO.IsEventDriven">
            <summary>
            Is the device used in event-driven mode?
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.WASAPIPROC">
            <summary>
            User defined WASAPI output/input processing callback function (to be used with <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/>).
            </summary>
            <param name="buffer">Pointer to the buffer to put the sample data for an output device, or to get the data from an input device. The sample data is always 32-bit floating-point.</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> was called.</param>
            <returns>In the case of an output device, the number of bytes written to the buffer. If the value is negative (high bit set), it will be treated as 0. In the case of an input device, 0 = stop the device, else continue.</returns>
            <remarks>
            <para>An output/input processing function should obviously be as quick as possible, to avoid buffer underruns (output) or overruns (input). Using a larger buffer makes that less crucial. <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> (BASS_DATA_AVAILABLE) can be used to check how much data is buffered.</para>
            <para>An output device's WASAPIPROC may return less data than requested, but be careful not to do so by too much, too often. If the buffer gets exhausted, output will stall until more data is provided. If you do return less than the requested amount of data, the number of bytes should still equate to a whole number of samples.</para>
            <para>When multiple channels are used, the sample data of the channels is interleaved. For example, with 2 channels (ie. stereo), the sample data would be arranged as channel 1, channel 2, channel 1, channel 2, channel 1, etc.</para>
            <para>When an output channel needs to be empty/silent but still enabled, the channel's function could fill the buffer with 0s to achieve that.</para>
            <para>Do not call <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Free"/> from within a callback function.</para>
            <para>Prior to calling this function, BASSWASAPI will set the thread's device context to the device that the channel belongs to. So when using multiple devices, <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDevice"/> can be used to determine which device the channel is on.</para>
            <para>NOTE: When you pass an instance of a callback delegate to one of the BASS functions, this delegate object will not be reference counted. 
            This means .NET would not know, that it might still being used by BASS. The Garbage Collector might (re)move the delegate instance, if the variable holding the delegate is not declared as global.
            So make sure to always keep your delegate instance in a variable which lives as long as BASS needs it, e.g. use a global variable or member.</para>
            <para>It is not supported to change the <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> once a device was initialized via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/>.
            If you need to change some internal processing logic during processing, you might use some kind of "if" statements within this callback procedure.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.BassWasapi.WASAPINOTIFYPROC">
            <summary>
            User defined notification callback function.
            </summary>
            <param name="notify">The notification, one of the following:
            <list type="table">
            <item><term>BASS_WASAPI_NOTIFY_CHANGE</term><description>The device's status has changed, eg. it has been enabled or disabled. The new status is available from <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetDeviceInfo(System.Int32,Un4seen.BassWasapi.BASS_WASAPI_DEVICEINFO)"/>.</description></item>
            <item><term>BASS_WASAPI_NOTIFY_DEFINPUT</term><description>The device is now the default input device.</description></item>
            <item><term>BASS_WASAPI_NOTIFY_DEFOUTPUT</term><description>The device is now the default output device.</description></item>
            </list>
            </param>
            <param name="device">The device that the notification applies to.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_SetNotify(Un4seen.BassWasapi.WASAPINOTIFYPROC,System.IntPtr)"/> was called.</param>
        </member>
        <member name="T:Un4seen.BassWasapi.BassWasapiHandler">
            <summary>
            This class provides ready-made members for direct and more simple WASAPI usage together with BASS channels.
            </summary>
            <remarks>
            You might use this class for almost all use cases in terms of Wasapi handling, e.g.:
            <list type="table">
            <listheader><term>Scenario:</term><description>How-To:</description></listheader>
            <item><term>Wasapi output</term><description>A Bass decoding channel feeding Wasapi output.
            <para>Simply create an instance of this class using an output device endpoint and then call the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.AddOutputSource(System.Int32,Un4seen.Bass.BASSFlag)"/> method to add your decoding channel(s) to be used for output.
            Now you call the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Init(System.Boolean)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Start"/> methods to actually start the Wasapi output processing.
            You might also use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InternalMixer"/> property (which returns the internally used <see cref="N:Un4seen.Bass.AddOn.Mix"/> mixer channel) to add or remove any decoding channel yourself.</para>
            </description></item>
            <item><term>Wasapi input</term><description>Directly record from Wasapi input.
            <para>Simply create an instance of this class using an input device endpoint you want to record at (this automatically sets the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.UseInput"/> property to <see langword="true"/>).
            To retrieve the input sample data use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InputChannel"/> channel (e.g. setup an <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)">own DSP</see>, use it with the <see cref="!:Un4seen.Bass.Misc.WaveWriter"/> or <see cref="T:Un4seen.Bass.Misc.BaseEncoder">Encoder Framework</see>).</para>
            </description></item>
            <item><term>Wasapi input, full-duplex to Wasapi</term><description>Monitor your Wasapi input on any Wasapi output.
            <para>Not supported directly by this class (but you can simply do this yourself, by initializing an output device with a <see langword="null"/> <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> and calling <seealso cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_PutData(System.IntPtr,System.Int32)"/> from within your input devices <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/>).</para>
            </description></item>
            <item><term>Wasapi input, full-duplex to BASS</term><description>Monitor your Wasapi input on any BASS device.
            <para>To enable full-duplex just call the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/> method (when done call <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.RemoveFullDuplex"/>).
            Note: You might also specify the "no sound" BASS device (0) and use the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> with the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/> call in order to retrieve a full-duplex decoding Bass stream, which you can now assign to an output instance of this class via <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.AddOutputSource(System.Int32,Un4seen.Bass.BASSFlag)"/> to preform a full-duplex Wasapi input to output monitoring.</para>
            </description></item>
            <item><term>DSP/FX</term><description>You can set any DSP/FX on either the input and/or the output (full-duplex).
            <para>See <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InputChannel"/> and <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InternalMixer"/> for more details.</para>
            </description></item>
            In addition to the above this class supports overloading of the default Wasapi callbacks (<see cref="M:Un4seen.BassWasapi.BassWasapiHandler.WasapiOutputCallback(System.IntPtr,System.Int32,System.IntPtr)"/>, <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.WasapiInputCallback(System.IntPtr,System.Int32,System.IntPtr)"/>).
            </list>
            <para>You might use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Volume"/> and <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Pan"/> properties to easily control your Wasapi input/output settings.</para>
            <para>Wasapi channels can be paused and resumed at any time by using the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Pause(System.Boolean)"/> method.
            To physically start the Wasapi device the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Init(System.Boolean)"/> followed by <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Start"/> methods might be used. <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Stop"/> will disable and stop the Wasapi device (if really needed).</para>
            <para>Caution: Once you created an instance of this class and called the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Init(System.Boolean)"/> method, the respective WASAPI device is enabled and a session is created.
            The used WASAPI device will be disabled and freed automatically when an instance of this class is being disposed by the .Net Garbage Collector!
            Call the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Dispose"/> method manually to free the WASAPI device, including any full-duplex options.</para>
            <para>Note: This class internally uses <see cref="N:Un4seen.Bass"/> as well as the <see cref="N:Un4seen.Bass.AddOn.Mix"/> add-on, so you need to provide the native bass.dll and the bassmix.dll as well when using this class.</para>
            </remarks>
            <example>
            Automatic use of the BassWasapiHandler (a Bass channel is feeding Wasapi output):
            <code>
            private BassWasapiHandler _wasapi;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            ...
            int stream = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                              BASSFlag.BASS_STREAM_DECODE | BASSFlag.BASS_SAMPLE_FLOAT);
            if (stream != 0)
            {
            	// assign WASAPI output in shared-mode
            	_wasapi = new BassWasapiHandler(-1, false, 48000, 2, 0f, 0f);
            	// add the source channel
            	_wasapi.AddOutputSource(stream, BASSFlag.BASS_DEFAULT)
            	// init and start WASAPI
            	_wasapi.Init();
            	_wasapi.Start();
            }
            </code>
            <code lang="vbnet">
            Private _wasapi As BassWasapiHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            ...
            Dim stream As Integer = Bass.BASS_StreamCreateFile(fileName, 0, 0, 
                                         BASSFlag.BASS_STREAM_DECODE Or BASSFlag.BASS_SAMPLE_FLOAT)
            If stream &lt;&gt; 0 Then
              ' assign WASAPI output in shared-mode
              _wasapi = new BassWasapiHandler(-1, false, 48000, 2, 0f, 0f)
              ' add the source channel
              _wasapi.AddOutputSource(stream, BASSFlag.BASS_DEFAULT)
              ' init and start WASAPI
              _wasapi.Init()
              _wasapi.Start()
            End If
            </code>
            Automatic use of the BassWasapiHandler (Wasapi recording input):
            <code>
            private BassWasapiHandler _wasapi;
            ...
            // not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0);
            // setup BASS - "no sound" device
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero);
            ...
            // assign WASAPI input in shared-mode
            _wasapi = new BassWasapiHandler(-2, false, 48000, 2, 0f, 0f);
            // init and start WASAPI
            _wasapi.Init();
            int recordStream = _wasapi.InputChannel;
            // double check, that the device is not muted externally
            if (_wasapi.DeviceMute)
                _wasapi.DeviceMute = false;
            _wasapi.Start();
            ...
            // now you can use recordStream to setup any DSP/FX etc.
            </code>
            <code lang="vbnet">
            Private _wasapi As BassWasapiHandler
            ...
            ' not playing anything via BASS, so don't need an update thread
            Bass.BASS_SetConfig(BASSConfig.BASS_CONFIG_UPDATEPERIOD, 0)
            ' setup BASS - "no sound" device
            Bass.BASS_Init(0, 48000, BASSInit.BASS_DEVICE_DEFAULT, IntPtr.Zero)
            ...
            ' assign WASAPI input in shared-mode
            _wasapi = new BassWasapiHandler(-2, false, 48000, 2, 0f, 0f)
            ' init and start WASAPI
            _wasapi.Init()
            Dim recordStream As Integer = _wasapi.InputChannel
            ' double check, that the device is not muted externally
            If _wasapi.DeviceMute Then
               _wasapi.DeviceMute = False
            End If
            _wasapi.Start()
            End If
            ...
            ' now you can use recordStream to setup any DSP/FX etc.
            </code>
            Setup a full-duplex stream on Wasapi input and pass that to an Wasapi output instance:
            <code>
            // setup a full-duplex stream
            _wasapiInput.SetFullDuplex(0, BASSFlag.BASS_STREAM_DECODE, false, 2000);
            int fullDuplexStream = _wasapiInput.OutputChannel;
            // and assign it to an output
            _wasapiOutput.AddOutputSource(fullDuplexStream, BASSFlag.BASS_DEFAULT);
            </code>
            <code lang="vbnet">
            ' setup a full-duplex stream
            _wasapiInput.SetFullDuplex(0, BASSFlag.BASS_STREAM_DECODE, False, 2000)
            Dim fullDuplexStream As Integer = _wasapiInput.OutputChannel
            ' and assign it to an output
            _wasapiOutput.AddOutputSource(fullDuplexStream, BASSFlag.BASS_DEFAULT)
            </code>
            </example>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Creates an instance of the WASAPI handler.
            </summary>
            <param name="device">The device to use... 0 = first device.</param>
            <param name="exclusive">Use the WASAPI device in exclusive mode?</param>
            <param name="freq">The sample rate to use (only used in exclusive mode, in shared mode the default mixer sample rate is used).</param>
            <param name="chans">The number of channels to use (only used in exclusive mode, in shared mode the default mixer number of channels are used).</param>
            <param name="buffer">The buffer size (in seconds) to use (set to 0 to use the default buffer length).</param>
            <param name="period">The update period (in seconds) to use (set to 0 to use the default update period).</param>
            <remarks>
            <para>The instance automatically detects according to the <paramref name="device"/> being used, if this handler will be dealing with as input (capture or loopback) or with output (rendering) endpoint device.
            You might use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/> property to validate this.</para>
            <para>Exclusive Mode: The requested number of channels are used. The requested sample rate is used.</para>
            <para>Shared Mode: The default mixer number of channels are used. The default mixer sample rate is used (the <paramref name="freq"/> parameter is ignored).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid device: the Wasapi device is invalid.</exception>
            <exception cref="T:System.NotSupportedException">Internal Mixer: the internal mixer cannot be created (e.g. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> was never called).</exception>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.#ctor(System.Int32,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Creates an instance of the WASAPI handler.
            </summary>
            <param name="device">The device to use... 0 = first device.</param>
            <param name="exclusive">Use the WASAPI device in exclusive mode?</param>
            <param name="eventSystem">Use the event-driven system?</param>
            <param name="freq">The sample rate to use (only used in exclusive mode, in shared mode the default mixer sample rate is used).</param>
            <param name="chans">The number of channels to use (only used in exclusive mode, in shared mode the default mixer number of channels are used).</param>
            <param name="buffer">The buffer size (in seconds) to use (set to 0 to use the default buffer length).</param>
            <param name="period">The update period (in seconds) to use (set to 0 to use the default update period).</param>
            <remarks>
            <para>The instance automatically detects according to the <paramref name="device"/> being used, if this handler will be dealing with as input (capture or loopback) or with output (rendering) endpoint device.
            You might use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/> property to validate this.</para>
            <para>Exclusive Mode: The requested number of channels are used. The requested sample rate is used.</para>
            <para>Shared Mode: The default mixer number of channels are used. The default mixer sample rate is used (the <paramref name="freq"/> parameter is ignored).</para>
            <para>Session volume limits the effect of <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.DeviceVolume"/> and <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.DeviceMute"/> to the current process; other users of the device are unaffected.
            Session volume has no effect on exclusive mode output, and maps to the device volume with input devices (so does affect other users).</para>
            <para>If the event-driven system is used, the (the <paramref name="buffer"/> and <paramref name="period"/> parameters are ignored in shared-mode).</para>
            </remarks>
            <exception cref="T:System.ArgumentException">Invalid device: the Wasapi device is invalid.</exception>
            <exception cref="T:System.NotSupportedException">Internal Mixer: the internal mixer cannot be created (e.g. <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/> was never called).</exception>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.Dispose">
            <summary>
            Disposes an instance of this class also stops and frees the used WASAPI device/driver (endpoint).
            </summary>
            <remarks>The used WASAPI device/driver (endpoint) will be stopped and freed!
            <para>Caution: Once you created an instance of this class and called <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Init(System.Boolean)"/>, the respective WASAPI device/driver (endpoint) is initialized.
            Calling this method will automatically stopp and free the used WASAPI device/driver (endpoint) as well as the full-duplex option will be removed!</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.Finalize">
            <summary>
            Finalization code.
            </summary>
            <remarks>This destructor will run only if the Dispose method does not get called.
            It gives your base class the opportunity to finalize. Do not provide destructors in types derived from this class.</remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.InternalWasapiProc">
            <summary>
            Gets the <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> currently being used by the Wasapi handler.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput">
            <summary>
            Returns <see langword="true"/>, if the WASAPI handler is used with a WASAPI input device (capture or loopback endpoint).
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.Exclusive">
            <summary>
            Returns <see langword="true"/>, if the WASAPI handler is used in exclusive mode - else shared mode is used.
            </summary>
            <remarks>
            <para>Exclusive mode: The device can only be used exclusivly by the application - which allows greater precision and lets you choose the output sample rate.</para>
            <para>Shared mode: The device can be shared by multiple applications. Enforces to use the default sample rate, number of channels and format.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.EventSystem">
            <summary>
            Returns <see langword="true"/>, if the WASAPI event-driven system is used - else the standard push system is used.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.Device">
            <summary>
            Returns the WASAPI device (endpoint) being used by the Wasapi handler.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.SampleRate">
            <summary>
            Gets the actual sample rate in Hz which is being used.
            </summary>
            <remarks>
            Depending if you use the Wasapi device in exclusive or shared mode the actual sample rate might be different from the sample rate requested.
            <para>In exclusive mode: The sample rate as specified in the constructor will be used.</para>
            <para>In shared mode: The default sample rate as specified in the mixer control panel will always be used.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.NumChans">
            <summary>
            Gets the actual number of channels being used with the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/>.
            </summary>
            <remarks>
            Depending if you use the Wasapi device in exclusive or shared mode the actual number of channels might be different from the number of channels requested.
            <para>In exclusive mode: The maximum available number of channels will always be used.</para>
            <para>In shared mode: The default number of channels as specified in the mixer control panel will always be used.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.BufferLength">
            <summary>
            Gets the actual buffer length (in seconds) being used with the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/>.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.UpdatePeriod">
            <summary>
            Gets the actual update period (in seconds) being used with the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/>.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.InternalMixer">
            <summary>
            Gets the internal mixer being used with this WASAPI handler (when used with an output device).
            </summary>
            <remarks>
            As WASAPI might require resampling or the used number of channels might not always match the requested number of channels
            an internal mixer stream is always created to perform these tasks.
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel">
            <summary>
            Gets the BASS output channel handle which is used with this WASAPI input handler in case of full-duplex monitoring.
            </summary>
            <remarks>
            You must call the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/> method in order to use this output channel.
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.Volume">
            <summary>
            Gets or Sets the volume of the channels between 0 (silent) and 1 (full).
            </summary>
            <remarks>
            <para>The volume level ranges from 0 (silent) to 1 (normal) or above 1 to amplify the sound.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.Pan">
            <summary>
            Gets or Sets the panning of the channels between -1 (left) to +1 (right), 0=centered.
            </summary>
            <remarks>Setting the panning uses the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Volume"/> property in order to calculate the individual channel volume.
            E.g. if you set the panning to -0.7 at a volume of 1.0: chan1-volume (left) = 0.3, chan2-volume (right) = 1.0.
            <para>The panning value ranges from -1 (left) to 0 (center) to +1 (right).</para>
            <para>In case of multi-channel (not stereo, <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.NumChans"/> is greater than 2) the left/right positions are interleaved between the additional channels.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.SessionVolume">
            <summary>
            Gets or Sets the session volume between 0 (silent) and 1 (full).
            </summary>
            <remarks>Whereas the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Volume"/> and the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Pan"/> properties directly effect the internally used channel volume,
            this property effects the session volume setting.
            Session volume only affects the current process, so other users of the device are unaffected.
            It has no effect on exclusive mode output, and maps to the device volume with input devices (so does affect other users). Session volume always uses the BASS_WASAPI_CURVE_WINDOWS curve.
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.SessionMute">
            <summary>
            Gets or Sets the mute status of the session.
            </summary>
            <remarks>
            Session volume only affects the current process, so other users of the device are unaffected.
            It has no effect on exclusive mode output, and maps to the device volume with input devices (so does affect other users). Session volume always uses the BASS_WASAPI_CURVE_WINDOWS curve.
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.DeviceVolume">
            <summary>
            Gets or Sets the linear volume of the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/> between 0 (silent) and 1 (full).
            </summary>
            <remarks>Whereas the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Volume"/> and the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Pan"/> properties directly effect the internally used channel volume,
            this property effects the global WASAPI device volume setting (which might be shared among other applications).
            <para>The volume level ranges from 0 (silent) to 1 (normal) or above 1 to amplify the sound.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.DeviceMute">
            <summary>
            Gets or Sets the mute status of the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/>.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.InputChannel">
            <summary>
            Returns an input channel which allows you to retrieve the recorded sample data and/or apply any DSP/FX on Wasapi input.
            </summary>
            <remarks>When you are using WASAPI with input (<see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/> must return <see langword="true"/>) and have set the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.UseInput"/> property to <see langword="true"/> 
            you might use this channel to setup any DSP/FX to be applied to the Wasapi input or just retrieve the recorded sample data. 
            Any DSP/FX set on this channel will also be passed through to the output, if you are using <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/>.
            <para>As the InputChannel is a dummy custom decoding stream you can not call <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> directly on it in order to directly get the sample data; 
            nor can you use it directly as a source stream for any (mixer)output!
            Instead use a <see cref="T:Un4seen.Bass.DSPPROC"/> via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetDSP(System.Int32,Un4seen.Bass.DSPPROC,System.IntPtr,System.Int32)"/> to retrieve the sample data.</para>
            <para>Note: However, you might independently set any DSP/FX on the full-duplex output using the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> instead.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.UseInput">
            <summary>
            Enables the use of the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InputChannel"/> channel with WASAPI input (which is the default for Wasapi input).
            </summary>
            <remarks>When you are using WASAPI with input (<see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/> must return <see langword="true"/>) and set this property to <see langword="true"/> 
            you might use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InputChannel"/> to setup any DSP/FX to be applied to the Wasapi input or retrieve the recorded sample data. 
            Any DSP/FX set on this channel will also be passed through to the output, if you are using <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/>.
            <para>Note: However, you might independently set any DSP/FX on the full-duplex output using the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> instead.</para>
            </remarks>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.IsInputFullDuplex">
            <summary>
            Returns <see langword="true"/>, if the WASAPI handler is used with an WASAPI input device and the full-duplex option was set via <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/>.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandler.BypassFullDuplex">
            <summary>
            Gets or Sets the bypass flag for full-duplex WASAPI output processing (default is <see langword="false"/>).
            </summary>
            <remarks>If this property is set to <see langword="true"/> any full-duplex output processing is bypassed.
            When setting this property to <see langword="true"/> prior to creating a full-duplex <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> via the <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/> method this enables you to start full-duplex without processing the output yet.
            Setting this property to <see langword="false"/> will start the full-duplex output processing.
            <para>This flag will automatically set back to <see langword="false"/> when calling <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.RemoveFullDuplex"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.Init(System.Boolean)">
            <summary>
            Initialises the WASAPI <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/> (must be called before <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Start"/>).
            </summary>
            <param name="buffered">Enable double buffering, for use by <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetData(System.IntPtr,System.Int32)"/> and <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_GetLevel"/>. 
            This requires the BASS "no sound" device to have been initilized, via <see cref="M:Un4seen.Bass.Bass.BASS_Init(System.Int32,System.Int32,Un4seen.Bass.BASSInit,System.IntPtr,System.IntPtr)"/>.</param>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.Start">
            <summary>
            Starts the WASAPI <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/>.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Start"/> internally on the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/> being used by the Wasapi handler (if not already started).
            <para>If you need to stop the WASAPI device you might call <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Stop"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.Stop">
            <summary>
            Stops the WASAPI <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/>.
            </summary>
            <returns>If successful, then <see langword="true"/> is returned, else <see langword="false"/> is returned. Use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to get the error code.</returns>
            <remarks>Calls <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Stop(System.Boolean)"/> internally on the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/> being used by the Wasapi handler (if not already stopped).
            <para>If you need to start the WASAPI device you might call <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.Start"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.Pause(System.Boolean)">
            <summary>
            Pauses or Unpauses the WASAPI <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.Device"/> being used.
            </summary>
            <param name="pause"><see langword="true"/> if you want to pause the WASAPI device - <see langword="false"/> if you want to unpause.</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to retrieve the error code).</returns>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.AddOutputSource(System.Int32,Un4seen.Bass.BASSFlag)">
            <summary>
            Adds a new source to the WASAPI handler for output.
            </summary>
            <param name="channel">The decoding stream to add to the output (must be a decoding channel).</param>
            <param name="flags">The speaker flags to use with the channel (use BASS_DEFAULT or any of the BASS_SPEAKER_xxx flags).</param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            In case the Wasapi handler is used for output an <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InternalMixer"/> is always internally created in order to handle possible resampling.
            You might use this method to add new source channels to this internal mixer in order to play them to the output.
            <para>Note, that the following flags will be added automatically as necessary: BASS_MIXER_DOWNMIX (in case you don't provide any speaker flags), BASS_MIXER_FILTER (in case the <paramref name="channel"/>'s sample rate doesn't match the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.SampleRate"/>).</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)">
            <summary>
            Sets the full-duplex option for WASAPI input using the given BASS output device.
            </summary>
            <param name="bassDevice">The BASS output device which should be used for full-duplex monitoring.</param>
            <param name="flags">The optional <see cref="T:Un4seen.Bass.BASSFlag"/> flags to be used to create the full-duplex monitoring <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/>.
            Typically only the following flags should be used: BASS_STREAM_DECODE, BASS_SAMPLE_SOFTWARE or BASS_SPEAKER_xxx.</param>
            <param name="buffered"><see langword="true"/>, if the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> should be (pre)buffered - else <see langword="false"/>.
            <para>Prebuffering of sample data is often requied for buffered output to enable a constant playback. So even if you are using a BASS_STREAM_DECODE flag you might need to prebuffer it's data.</para>
            </param>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>
            <para>The following will be done internally:</para>
            <para>1. The BASS output <paramref name="bassDevice"/> will be used.</para>
            <para>2. A custom push stream (see <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/>) will be created (using the given <paramref name="flags"/>) with an internal WASAPI callback feeding the stream with the sample data from the input.</para>
            <para>3. The samplerate, format and number of channels will not be changed for WASAPI input, since this will be used as already specified in the constructor.</para>
            <para>4. The custom push stream will be started playing (via <see cref="M:Un4seen.Bass.Bass.BASS_ChannelPlay(System.Int32,System.Boolean)"/>) - unless the <see cref="F:Un4seen.Bass.BASSFlag.BASS_STREAM_DECODE"/> flag has been specified.</para>
            <para>This method can not be used with WASAPI output (see <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To disable and remove the full-duplex option call <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.RemoveFullDuplex"/>.</para>
            <para>The full-duplex BASS output is provided by the internal custom push stream <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/>. You might use this stream to set up DSPs or FX on it so that these are applied on the BASS output.</para>
            <para>You might use the 0 (no-sound) bass device together with the BASS_STREAM_DECODE flag in order to create a custom decoding <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> which might for example be used with an <see cref="T:Un4seen.Bass.Misc.BaseEncoder"/> or <see cref="!:Bass.Misc.WaveWriter"/> or 
            as a source for a <see cref="M:Un4seen.Bass.AddOn.Mix.BassMix.BASS_Mixer_StreamCreate(System.Int32,System.Int32,Un4seen.Bass.BASSFlag)">mixer channel</see>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.RemoveFullDuplex">
            <summary>
            Removes the full-duplex option from WASAPI input.
            </summary>
            <returns>On success <see langword="true"/> is returned, else <see langword="false"/> will be returned (use <see cref="M:Un4seen.Bass.Bass.BASS_ErrorGetCode"/> to retrieve the error code).</returns>
            <remarks>The full-duplex option must have been set before via <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/>.
            <para>This method can not be used with WASAPI output (see <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/>). It will immediately return with no effect.</para>
            <para>To enable the full-duplex option again, call <see cref="M:Un4seen.BassWasapi.BassWasapiHandler.SetFullDuplex(System.Int32,Un4seen.Bass.BASSFlag,System.Boolean)"/>.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.WasapiOutputCallback(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> callback procedure which might be used for WASAPI output.
            </summary>
            <param name="buffer">The pointer to the buffer in which to put the data to output. Will always be floating point!</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> was called.</param>
            <returns>The number of bytes written.</returns>
            <remarks>Notes:
            <para>In order to use this default output WASAPI callback (playback), you need to make sure that you use this callback only with WASAPI output (<see cref="P:Un4seen.BassWasapi.BassWasapiHandler.IsInput"/> must be <see langword="false"/>).</para>
            <para>Furthermore the following should be considered: If the underlying stream channel <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> is at the end (all data was decoded), 
            this callback does NOT automatically stop WASAPI via <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Stop(System.Boolean)"/>.
            So you need to do that by yourself (if you whish to save some performance), e.g. setup a <see cref="M:Un4seen.Bass.Bass.BASS_ChannelSetSync(System.Int32,Un4seen.Bass.BASSSync,System.Int64,Un4seen.Bass.SYNCPROC,System.IntPtr)">BASS_SYNC_END</see> on the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/>.
            If the underlying <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> returns less data, than requested the WASAPI output buffer will be filled with 0's (silence).</para>
            <para>Internally <see cref="M:Un4seen.Bass.Bass.BASS_ChannelGetData(System.Int32,System.IntPtr,System.Int32)"/> will be called on the underlying <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.OutputChannel"/> to request sample data, before the sample data is send to the WASAPI output.</para>
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandler.WasapiInputCallback(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Provides a ready made <see cref="T:Un4seen.BassWasapi.WASAPIPROC"/> callback procedure which might be used for WASAPI input.
            </summary>
            <param name="buffer">The pointer to the buffer containing the sample data. Will always be floating point!</param>
            <param name="length">The number of bytes to process.</param>
            <param name="user">The user instance data given when <see cref="M:Un4seen.BassWasapi.BassWasapi.BASS_WASAPI_Init(System.Int32,System.Int32,System.Int32,Un4seen.BassWasapi.BASSWASAPIInit,System.Single,System.Single,Un4seen.BassWasapi.WASAPIPROC,System.IntPtr)"/> was called.</param>
            <returns>Will always return 0 here (as it is ignored with input channels).</returns>
            <remarks>
            To receive the recorded sample data you might use the <see cref="P:Un4seen.BassWasapi.BassWasapiHandler.InputChannel"/> and set up a DSP on it.
            <para>If you intend to overload this callback in a derive implementation make sure to call the base method to not loose any functionatily.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.BassWasapi.BassWasapiHandler.BassWasapiHandlerEventHandler">
            <summary>
            Definition of the <see cref="E:Un4seen.BassWasapi.BassWasapiHandler.Notification"/> event handler.
            </summary>
            <remarks>
            This definition complies with the .NET Framework's standard for event handlers.
            The sender is always set to the <see cref="T:Un4seen.BassWasapi.BassWasapiHandler"/> object instance that raised the event.
            </remarks>
        </member>
        <member name="E:Un4seen.BassWasapi.BassWasapiHandler.Notification">
            <summary>
            Event handler used to notify that an Wasapi handler notification event (sync) has occurred.
            </summary>
            <remarks>
            <para>The <see cref="T:Un4seen.BassWasapi.BassWasapiHandlerEventArgs"/> contains a <see cref="T:Un4seen.BassWasapi.BassWasapiHandlerSyncType"/> which allows you to react to a possible sync scenarios.</para>
            </remarks>
        </member>
        <member name="T:Un4seen.BassWasapi.BassWasapiHandlerEventArgs">
            <summary>
            EventArgs class to be passed as the second parameter of a <see cref="E:Un4seen.BassWasapi.BassWasapiHandler.Notification" /> event handler.
            </summary>
            <remarks>
            This class provides all the information relevant to an event which might occur to a <see cref="T:Un4seen.BassWasapi.BassWasapiHandler"/> class.
            </remarks>
        </member>
        <member name="M:Un4seen.BassWasapi.BassWasapiHandlerEventArgs.#ctor(Un4seen.BassWasapi.BassWasapiHandlerSyncType,System.Int32)">
            <summary>
            Initializes a new instance of the BassWasapiHandlerEventArgs class by initializing all of its properties.
            </summary>
            <param name="syncType">The type of event which occurred (see <see cref="T:Un4seen.BassWasapi.BassWasapiHandlerSyncType"/>).</param>
            <param name="data">Some data which should be passed along with the notification event.</param>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandlerEventArgs.SyncType">
            <summary>
            Gets the type of sync which occurred.
            </summary>
        </member>
        <member name="P:Un4seen.BassWasapi.BassWasapiHandlerEventArgs.Data">
            <summary>
            Gets the data which was passed along with the event.
            </summary>
        </member>
        <member name="T:Un4seen.BassWasapi.BassWasapiHandlerSyncType">
            <summary>
            Types of event that has occurred with the <see cref="T:Un4seen.BassWasapi.BassWasapiHandler"/> class.
            </summary>
            <remarks>
            A variable of this type is passed inside the <see cref="T:Un4seen.BassWasapi.BassWasapiHandlerEventArgs"/> object 
            for the <see cref="E:Un4seen.BassWasapi.BassWasapiHandler.Notification" /> event.
            </remarks>
        </member>
        <member name="F:Un4seen.BassWasapi.BassWasapiHandlerSyncType.SourceStalled">
            <summary>
            The Wasapi source is stalled.
            <para>data: the source stream channel which was stalled.</para>
            </summary>
        </member>
        <member name="F:Un4seen.BassWasapi.BassWasapiHandlerSyncType.SourceResumed">
            <summary>
            The Wasapi source is resumed.
            <para>data: the source stream channel which was resumed.</para>
            </summary>
        </member>
    </members>
</doc>
